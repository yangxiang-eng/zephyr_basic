
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00010000 <_vector_start>:
   10000:	2000d5f8 	.word	0x2000d5f8
   10004:	0001192d 	.word	0x0001192d
   10008:	000164cb 	.word	0x000164cb
   1000c:	00011901 	.word	0x00011901
   10010:	00011901 	.word	0x00011901
   10014:	00011901 	.word	0x00011901
   10018:	00011901 	.word	0x00011901
   1001c:	00011901 	.word	0x00011901
	...
   1002c:	00011655 	.word	0x00011655
   10030:	00011901 	.word	0x00011901
   10034:	00000000 	.word	0x00000000
   10038:	000115fd 	.word	0x000115fd
   1003c:	00011901 	.word	0x00011901

00010040 <_irq_vector_table>:
   10040:	000116d5 000116d5 000116d5 000116d5     ................
   10050:	000116d5 000116d5 000116d5 000116d5     ................
   10060:	000116d5 000116d5 000116d5 000116d5     ................
   10070:	000116d5 000116d5 000116d5 000116d5     ................
   10080:	000116d5 000116d5 000116d5 000116d5     ................
   10090:	000116d5 000116d5 000116d5 000116d5     ................
   100a0:	000116d5 000116d5 000116d5 000116d5     ................
   100b0:	00012b41 000116d5 000116d5 000116d5     A+..............
   100c0:	000116d5 000116d5 000116d5 000116d5     ................
   100d0:	000116d5 000116d5 000116d5 000116d5     ................
   100e0:	000116d5 000116d5 000116d5 000116d5     ................
   100f0:	000116d5 000116d5 000116d5 000116d5     ................
   10100:	000116d5 000116d5 000116d5 000116d5     ................
   10110:	000116d5 000116d5 000116d5 000116d5     ................
   10120:	000116d5 000116d5 000116d5 000116d5     ................
   10130:	000116d5 000116d5 000116d5 000116d5     ................
   10140:	000116d5                                ....

00010144 <_vector_end>:
	...

00010200 <m_firmware_info>:
   10200:	281ee6de 8fcebb4c 00005b02 0000003c     ...(L....[..<...
   10210:	000076f4 00000001 00010000 00010000     .v..............
   10220:	9102ffff 00000000 00000000 00000000     ................
	...

Disassembly of section text:

0001023c <__aeabi_uldivmod>:
   1023c:	b953      	cbnz	r3, 10254 <__aeabi_uldivmod+0x18>
   1023e:	b94a      	cbnz	r2, 10254 <__aeabi_uldivmod+0x18>
   10240:	2900      	cmp	r1, #0
   10242:	bf08      	it	eq
   10244:	2800      	cmpeq	r0, #0
   10246:	bf1c      	itt	ne
   10248:	f04f 31ff 	movne.w	r1, #4294967295
   1024c:	f04f 30ff 	movne.w	r0, #4294967295
   10250:	f000 b970 	b.w	10534 <__aeabi_idiv0>
   10254:	f1ad 0c08 	sub.w	ip, sp, #8
   10258:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1025c:	f000 f806 	bl	1026c <__udivmoddi4>
   10260:	f8dd e004 	ldr.w	lr, [sp, #4]
   10264:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   10268:	b004      	add	sp, #16
   1026a:	4770      	bx	lr

0001026c <__udivmoddi4>:
   1026c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10270:	9e08      	ldr	r6, [sp, #32]
   10272:	460d      	mov	r5, r1
   10274:	4604      	mov	r4, r0
   10276:	468a      	mov	sl, r1
   10278:	2b00      	cmp	r3, #0
   1027a:	d17f      	bne.n	1037c <__udivmoddi4+0x110>
   1027c:	428a      	cmp	r2, r1
   1027e:	4617      	mov	r7, r2
   10280:	d941      	bls.n	10306 <__udivmoddi4+0x9a>
   10282:	fab2 f282 	clz	r2, r2
   10286:	b14a      	cbz	r2, 1029c <__udivmoddi4+0x30>
   10288:	f1c2 0120 	rsb	r1, r2, #32
   1028c:	fa05 f302 	lsl.w	r3, r5, r2
   10290:	4097      	lsls	r7, r2
   10292:	4094      	lsls	r4, r2
   10294:	fa20 f101 	lsr.w	r1, r0, r1
   10298:	ea41 0a03 	orr.w	sl, r1, r3
   1029c:	ea4f 4817 	mov.w	r8, r7, lsr #16
   102a0:	ea4f 4c14 	mov.w	ip, r4, lsr #16
   102a4:	fa1f f987 	uxth.w	r9, r7
   102a8:	fbba fef8 	udiv	lr, sl, r8
   102ac:	fb08 a31e 	mls	r3, r8, lr, sl
   102b0:	fb0e f109 	mul.w	r1, lr, r9
   102b4:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
   102b8:	4299      	cmp	r1, r3
   102ba:	d906      	bls.n	102ca <__udivmoddi4+0x5e>
   102bc:	18fb      	adds	r3, r7, r3
   102be:	d202      	bcs.n	102c6 <__udivmoddi4+0x5a>
   102c0:	4299      	cmp	r1, r3
   102c2:	f200 8124 	bhi.w	1050e <__udivmoddi4+0x2a2>
   102c6:	f10e 3eff 	add.w	lr, lr, #4294967295
   102ca:	1a59      	subs	r1, r3, r1
   102cc:	b2a3      	uxth	r3, r4
   102ce:	fbb1 f0f8 	udiv	r0, r1, r8
   102d2:	fb08 1110 	mls	r1, r8, r0, r1
   102d6:	fb00 f909 	mul.w	r9, r0, r9
   102da:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   102de:	45a1      	cmp	r9, r4
   102e0:	d905      	bls.n	102ee <__udivmoddi4+0x82>
   102e2:	193c      	adds	r4, r7, r4
   102e4:	d202      	bcs.n	102ec <__udivmoddi4+0x80>
   102e6:	45a1      	cmp	r9, r4
   102e8:	f200 810e 	bhi.w	10508 <__udivmoddi4+0x29c>
   102ec:	3801      	subs	r0, #1
   102ee:	eba4 0409 	sub.w	r4, r4, r9
   102f2:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
   102f6:	2100      	movs	r1, #0
   102f8:	b11e      	cbz	r6, 10302 <__udivmoddi4+0x96>
   102fa:	40d4      	lsrs	r4, r2
   102fc:	2300      	movs	r3, #0
   102fe:	e9c6 4300 	strd	r4, r3, [r6]
   10302:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10306:	b902      	cbnz	r2, 1030a <__udivmoddi4+0x9e>
   10308:	deff      	udf	#255	; 0xff
   1030a:	fab2 f282 	clz	r2, r2
   1030e:	2a00      	cmp	r2, #0
   10310:	d14f      	bne.n	103b2 <__udivmoddi4+0x146>
   10312:	1bcb      	subs	r3, r1, r7
   10314:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   10318:	fa1f f887 	uxth.w	r8, r7
   1031c:	2101      	movs	r1, #1
   1031e:	0c25      	lsrs	r5, r4, #16
   10320:	fbb3 fcfe 	udiv	ip, r3, lr
   10324:	fb0e 301c 	mls	r0, lr, ip, r3
   10328:	462b      	mov	r3, r5
   1032a:	fb08 f90c 	mul.w	r9, r8, ip
   1032e:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
   10332:	45a9      	cmp	r9, r5
   10334:	d90a      	bls.n	1034c <__udivmoddi4+0xe0>
   10336:	197d      	adds	r5, r7, r5
   10338:	bf2c      	ite	cs
   1033a:	2301      	movcs	r3, #1
   1033c:	2300      	movcc	r3, #0
   1033e:	45a9      	cmp	r9, r5
   10340:	d902      	bls.n	10348 <__udivmoddi4+0xdc>
   10342:	2b00      	cmp	r3, #0
   10344:	f000 80d9 	beq.w	104fa <__udivmoddi4+0x28e>
   10348:	f10c 3cff 	add.w	ip, ip, #4294967295
   1034c:	eba5 0509 	sub.w	r5, r5, r9
   10350:	b2a3      	uxth	r3, r4
   10352:	fbb5 f0fe 	udiv	r0, r5, lr
   10356:	fb0e 5510 	mls	r5, lr, r0, r5
   1035a:	fb08 f800 	mul.w	r8, r8, r0
   1035e:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
   10362:	45a0      	cmp	r8, r4
   10364:	d905      	bls.n	10372 <__udivmoddi4+0x106>
   10366:	193c      	adds	r4, r7, r4
   10368:	d202      	bcs.n	10370 <__udivmoddi4+0x104>
   1036a:	45a0      	cmp	r8, r4
   1036c:	f200 80c9 	bhi.w	10502 <__udivmoddi4+0x296>
   10370:	3801      	subs	r0, #1
   10372:	eba4 0408 	sub.w	r4, r4, r8
   10376:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   1037a:	e7bd      	b.n	102f8 <__udivmoddi4+0x8c>
   1037c:	428b      	cmp	r3, r1
   1037e:	d908      	bls.n	10392 <__udivmoddi4+0x126>
   10380:	2e00      	cmp	r6, #0
   10382:	f000 80b1 	beq.w	104e8 <__udivmoddi4+0x27c>
   10386:	2100      	movs	r1, #0
   10388:	e9c6 0500 	strd	r0, r5, [r6]
   1038c:	4608      	mov	r0, r1
   1038e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10392:	fab3 f183 	clz	r1, r3
   10396:	2900      	cmp	r1, #0
   10398:	d146      	bne.n	10428 <__udivmoddi4+0x1bc>
   1039a:	42ab      	cmp	r3, r5
   1039c:	f0c0 80a7 	bcc.w	104ee <__udivmoddi4+0x282>
   103a0:	4282      	cmp	r2, r0
   103a2:	f240 80a4 	bls.w	104ee <__udivmoddi4+0x282>
   103a6:	4608      	mov	r0, r1
   103a8:	2e00      	cmp	r6, #0
   103aa:	d0aa      	beq.n	10302 <__udivmoddi4+0x96>
   103ac:	e9c6 4a00 	strd	r4, sl, [r6]
   103b0:	e7a7      	b.n	10302 <__udivmoddi4+0x96>
   103b2:	f1c2 0020 	rsb	r0, r2, #32
   103b6:	4097      	lsls	r7, r2
   103b8:	fa01 f302 	lsl.w	r3, r1, r2
   103bc:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   103c0:	40c1      	lsrs	r1, r0
   103c2:	fa24 f500 	lsr.w	r5, r4, r0
   103c6:	fa1f f887 	uxth.w	r8, r7
   103ca:	4094      	lsls	r4, r2
   103cc:	431d      	orrs	r5, r3
   103ce:	fbb1 f0fe 	udiv	r0, r1, lr
   103d2:	0c2b      	lsrs	r3, r5, #16
   103d4:	fb0e 1110 	mls	r1, lr, r0, r1
   103d8:	fb00 fc08 	mul.w	ip, r0, r8
   103dc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   103e0:	459c      	cmp	ip, r3
   103e2:	d909      	bls.n	103f8 <__udivmoddi4+0x18c>
   103e4:	18fb      	adds	r3, r7, r3
   103e6:	bf2c      	ite	cs
   103e8:	2101      	movcs	r1, #1
   103ea:	2100      	movcc	r1, #0
   103ec:	459c      	cmp	ip, r3
   103ee:	d902      	bls.n	103f6 <__udivmoddi4+0x18a>
   103f0:	2900      	cmp	r1, #0
   103f2:	f000 8095 	beq.w	10520 <__udivmoddi4+0x2b4>
   103f6:	3801      	subs	r0, #1
   103f8:	eba3 030c 	sub.w	r3, r3, ip
   103fc:	b2ad      	uxth	r5, r5
   103fe:	fbb3 f1fe 	udiv	r1, r3, lr
   10402:	fb0e 3311 	mls	r3, lr, r1, r3
   10406:	fb01 fc08 	mul.w	ip, r1, r8
   1040a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
   1040e:	45ac      	cmp	ip, r5
   10410:	d905      	bls.n	1041e <__udivmoddi4+0x1b2>
   10412:	197d      	adds	r5, r7, r5
   10414:	d202      	bcs.n	1041c <__udivmoddi4+0x1b0>
   10416:	45ac      	cmp	ip, r5
   10418:	f200 8089 	bhi.w	1052e <__udivmoddi4+0x2c2>
   1041c:	3901      	subs	r1, #1
   1041e:	eba5 030c 	sub.w	r3, r5, ip
   10422:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   10426:	e77a      	b.n	1031e <__udivmoddi4+0xb2>
   10428:	f1c1 0420 	rsb	r4, r1, #32
   1042c:	408b      	lsls	r3, r1
   1042e:	fa02 f701 	lsl.w	r7, r2, r1
   10432:	fa05 fc01 	lsl.w	ip, r5, r1
   10436:	40e2      	lsrs	r2, r4
   10438:	fa20 f804 	lsr.w	r8, r0, r4
   1043c:	40e5      	lsrs	r5, r4
   1043e:	fa00 fe01 	lsl.w	lr, r0, r1
   10442:	4313      	orrs	r3, r2
   10444:	ea48 020c 	orr.w	r2, r8, ip
   10448:	ea4f 4813 	mov.w	r8, r3, lsr #16
   1044c:	ea4f 4c12 	mov.w	ip, r2, lsr #16
   10450:	fa1f f983 	uxth.w	r9, r3
   10454:	fbb5 faf8 	udiv	sl, r5, r8
   10458:	fb08 551a 	mls	r5, r8, sl, r5
   1045c:	fb0a f009 	mul.w	r0, sl, r9
   10460:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
   10464:	4560      	cmp	r0, ip
   10466:	d90a      	bls.n	1047e <__udivmoddi4+0x212>
   10468:	eb13 0c0c 	adds.w	ip, r3, ip
   1046c:	bf2c      	ite	cs
   1046e:	2501      	movcs	r5, #1
   10470:	2500      	movcc	r5, #0
   10472:	4560      	cmp	r0, ip
   10474:	d901      	bls.n	1047a <__udivmoddi4+0x20e>
   10476:	2d00      	cmp	r5, #0
   10478:	d055      	beq.n	10526 <__udivmoddi4+0x2ba>
   1047a:	f10a 3aff 	add.w	sl, sl, #4294967295
   1047e:	ebac 0c00 	sub.w	ip, ip, r0
   10482:	b292      	uxth	r2, r2
   10484:	fbbc f0f8 	udiv	r0, ip, r8
   10488:	fb08 cc10 	mls	ip, r8, r0, ip
   1048c:	fb00 f909 	mul.w	r9, r0, r9
   10490:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
   10494:	45e1      	cmp	r9, ip
   10496:	d905      	bls.n	104a4 <__udivmoddi4+0x238>
   10498:	eb13 0c0c 	adds.w	ip, r3, ip
   1049c:	d201      	bcs.n	104a2 <__udivmoddi4+0x236>
   1049e:	45e1      	cmp	r9, ip
   104a0:	d83b      	bhi.n	1051a <__udivmoddi4+0x2ae>
   104a2:	3801      	subs	r0, #1
   104a4:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
   104a8:	ebac 0c09 	sub.w	ip, ip, r9
   104ac:	fba0 8907 	umull	r8, r9, r0, r7
   104b0:	45cc      	cmp	ip, r9
   104b2:	4645      	mov	r5, r8
   104b4:	464a      	mov	r2, r9
   104b6:	d302      	bcc.n	104be <__udivmoddi4+0x252>
   104b8:	d106      	bne.n	104c8 <__udivmoddi4+0x25c>
   104ba:	45c6      	cmp	lr, r8
   104bc:	d204      	bcs.n	104c8 <__udivmoddi4+0x25c>
   104be:	3801      	subs	r0, #1
   104c0:	ebb8 0507 	subs.w	r5, r8, r7
   104c4:	eb69 0203 	sbc.w	r2, r9, r3
   104c8:	b32e      	cbz	r6, 10516 <__udivmoddi4+0x2aa>
   104ca:	ebbe 0305 	subs.w	r3, lr, r5
   104ce:	eb6c 0c02 	sbc.w	ip, ip, r2
   104d2:	fa23 f201 	lsr.w	r2, r3, r1
   104d6:	fa0c f404 	lsl.w	r4, ip, r4
   104da:	fa2c f301 	lsr.w	r3, ip, r1
   104de:	2100      	movs	r1, #0
   104e0:	4314      	orrs	r4, r2
   104e2:	e9c6 4300 	strd	r4, r3, [r6]
   104e6:	e70c      	b.n	10302 <__udivmoddi4+0x96>
   104e8:	4631      	mov	r1, r6
   104ea:	4630      	mov	r0, r6
   104ec:	e709      	b.n	10302 <__udivmoddi4+0x96>
   104ee:	1a84      	subs	r4, r0, r2
   104f0:	eb65 0303 	sbc.w	r3, r5, r3
   104f4:	2001      	movs	r0, #1
   104f6:	469a      	mov	sl, r3
   104f8:	e756      	b.n	103a8 <__udivmoddi4+0x13c>
   104fa:	f1ac 0c02 	sub.w	ip, ip, #2
   104fe:	443d      	add	r5, r7
   10500:	e724      	b.n	1034c <__udivmoddi4+0xe0>
   10502:	3802      	subs	r0, #2
   10504:	443c      	add	r4, r7
   10506:	e734      	b.n	10372 <__udivmoddi4+0x106>
   10508:	3802      	subs	r0, #2
   1050a:	443c      	add	r4, r7
   1050c:	e6ef      	b.n	102ee <__udivmoddi4+0x82>
   1050e:	f1ae 0e02 	sub.w	lr, lr, #2
   10512:	443b      	add	r3, r7
   10514:	e6d9      	b.n	102ca <__udivmoddi4+0x5e>
   10516:	4631      	mov	r1, r6
   10518:	e6f3      	b.n	10302 <__udivmoddi4+0x96>
   1051a:	3802      	subs	r0, #2
   1051c:	449c      	add	ip, r3
   1051e:	e7c1      	b.n	104a4 <__udivmoddi4+0x238>
   10520:	3802      	subs	r0, #2
   10522:	443b      	add	r3, r7
   10524:	e768      	b.n	103f8 <__udivmoddi4+0x18c>
   10526:	f1aa 0a02 	sub.w	sl, sl, #2
   1052a:	449c      	add	ip, r3
   1052c:	e7a7      	b.n	1047e <__udivmoddi4+0x212>
   1052e:	3902      	subs	r1, #2
   10530:	443d      	add	r5, r7
   10532:	e774      	b.n	1041e <__udivmoddi4+0x1b2>

00010534 <__aeabi_idiv0>:
   10534:	4770      	bx	lr
   10536:	bf00      	nop

00010538 <my_timer_handler>:
#define BUTTON_MS 1000
struct k_timer my_timer ; 

//这是一个周期行定时器，如果需要可以在回调函数中关闭
void my_timer_handler(struct k_timer *dummy)
{
   10538:	b508      	push	{r3, lr}
	// printk("timer out\n");
	//上电闪灯
	led_off();
   1053a:	f000 f88b 	bl	10654 <led_off>
	k_timer_stop(&my_timer);
}
   1053e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		arch_syscall_invoke1(*(uintptr_t *)&timer, K_SYSCALL_K_TIMER_STOP);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_timer_stop(timer);
   10542:	4801      	ldr	r0, [pc, #4]	; (10548 <my_timer_handler+0x10>)
   10544:	f006 bd04 	b.w	16f50 <z_impl_k_timer_stop>
   10548:	2000c5b0 	.word	0x2000c5b0

0001054c <button_handler>:

}

static void button_handler(uint32_t button , uint32_t changed,PRESS_STATUS result)
{
	if(button ==BUTTON_1)
   1054c:	2801      	cmp	r0, #1
{
   1054e:	b507      	push	{r0, r1, r2, lr}
	if(button ==BUTTON_1)
   10550:	d11d      	bne.n	1058e <button_handler+0x42>
	{
		if(result ==LONG_PRESS && changed ==1)
   10552:	2a01      	cmp	r2, #1
   10554:	d111      	bne.n	1057a <button_handler+0x2e>
   10556:	2901      	cmp	r1, #1
   10558:	d10c      	bne.n	10574 <button_handler+0x28>
		{
			printk("button1 long press\n");
   1055a:	4814      	ldr	r0, [pc, #80]	; (105ac <button_handler+0x60>)
	}
	if(button ==BUTTON_2)
	{
		if(result ==LONG_PRESS && changed ==1)
		{
			printk("button2 long press\n");
   1055c:	f005 fc93 	bl	15e86 <printk>
			led_on();
   10560:	f000 f86a 	bl	10638 <led_on>
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
   10564:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   10568:	2300      	movs	r3, #0
	z_impl_k_timer_start(timer, duration, period);
   1056a:	4811      	ldr	r0, [pc, #68]	; (105b0 <button_handler+0x64>)
   1056c:	e9cd 2300 	strd	r2, r3, [sp]
   10570:	f005 fbc2 	bl	15cf8 <z_impl_k_timer_start>
			printk("button2 shot press\n");
			
		}
	}
	
   10574:	b003      	add	sp, #12
   10576:	f85d fb04 	ldr.w	pc, [sp], #4
		else if(result ==SHOT_PRESS && changed ==1)
   1057a:	2a00      	cmp	r2, #0
   1057c:	d1fa      	bne.n	10574 <button_handler+0x28>
   1057e:	2901      	cmp	r1, #1
   10580:	d1f8      	bne.n	10574 <button_handler+0x28>
			printk("button1 shot press\n");
   10582:	480c      	ldr	r0, [pc, #48]	; (105b4 <button_handler+0x68>)
   10584:	b003      	add	sp, #12
   10586:	f85d eb04 	ldr.w	lr, [sp], #4
			printk("button2 shot press\n");
   1058a:	f005 bc7c 	b.w	15e86 <printk>
	if(button ==BUTTON_2)
   1058e:	2802      	cmp	r0, #2
   10590:	d1f0      	bne.n	10574 <button_handler+0x28>
		if(result ==LONG_PRESS && changed ==1)
   10592:	2a01      	cmp	r2, #1
   10594:	d103      	bne.n	1059e <button_handler+0x52>
   10596:	2901      	cmp	r1, #1
   10598:	d1ec      	bne.n	10574 <button_handler+0x28>
			printk("button2 long press\n");
   1059a:	4807      	ldr	r0, [pc, #28]	; (105b8 <button_handler+0x6c>)
   1059c:	e7de      	b.n	1055c <button_handler+0x10>
		else if(result ==SHOT_PRESS && changed ==1)
   1059e:	2a00      	cmp	r2, #0
   105a0:	d1e8      	bne.n	10574 <button_handler+0x28>
   105a2:	2901      	cmp	r1, #1
   105a4:	d1e6      	bne.n	10574 <button_handler+0x28>
			printk("button2 shot press\n");
   105a6:	4805      	ldr	r0, [pc, #20]	; (105bc <button_handler+0x70>)
   105a8:	e7ec      	b.n	10584 <button_handler+0x38>
   105aa:	bf00      	nop
   105ac:	000173ec 	.word	0x000173ec
   105b0:	2000c5b0 	.word	0x2000c5b0
   105b4:	00017400 	.word	0x00017400
   105b8:	00017414 	.word	0x00017414
   105bc:	00017428 	.word	0x00017428

000105c0 <main>:
{
   105c0:	b513      	push	{r0, r1, r4, lr}
	k_timer_init(&my_timer , my_timer_handler,NULL);
   105c2:	4c0c      	ldr	r4, [pc, #48]	; (105f4 <main+0x34>)
	printk("hello_world\n");
   105c4:	480c      	ldr	r0, [pc, #48]	; (105f8 <main+0x38>)
   105c6:	f005 fc5e 	bl	15e86 <printk>
	led_init();
   105ca:	f000 f81b 	bl	10604 <led_init>
	k_timer_init(&my_timer , my_timer_handler,NULL);
   105ce:	2200      	movs	r2, #0
   105d0:	4620      	mov	r0, r4
   105d2:	490a      	ldr	r1, [pc, #40]	; (105fc <main+0x3c>)
   105d4:	f006 fcb0 	bl	16f38 <k_timer_init>
   105d8:	f243 3234 	movw	r2, #13108	; 0x3334
   105dc:	2300      	movs	r3, #0
   105de:	4620      	mov	r0, r4
   105e0:	e9cd 2300 	strd	r2, r3, [sp]
   105e4:	f005 fb88 	bl	15cf8 <z_impl_k_timer_start>
	button_handler_init(button_handler);
   105e8:	4805      	ldr	r0, [pc, #20]	; (10600 <main+0x40>)
}
   105ea:	b002      	add	sp, #8
   105ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	button_handler_init(button_handler);
   105f0:	f000 b8e8 	b.w	107c4 <button_handler_init>
   105f4:	2000c5b0 	.word	0x2000c5b0
   105f8:	0001743c 	.word	0x0001743c
   105fc:	00010539 	.word	0x00010539
   10600:	0001054d 	.word	0x0001054d

00010604 <led_init>:
#endif

static const struct device *dev ;

void led_init()
{
   10604:	b510      	push	{r4, lr}
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
   10606:	480a      	ldr	r0, [pc, #40]	; (10630 <led_init+0x2c>)
   10608:	f004 fbb0 	bl	14d6c <z_impl_device_get_binding>
    int ret ; 

    dev = device_get_binding(LED0);
   1060c:	4a09      	ldr	r2, [pc, #36]	; (10634 <led_init+0x30>)
   1060e:	6010      	str	r0, [r2, #0]
    if(dev ==NULL)
   10610:	b160      	cbz	r0, 1062c <led_init+0x28>
    ret = gpio_pin_configure(dev,PIN,GPIO_OUTPUT_ACTIVE|FLAGS);
    if(ret<0)
    {
        return ; 
    }
}
   10612:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
   10616:	6902      	ldr	r2, [r0, #16]
	const struct gpio_driver_api *api =
   10618:	6881      	ldr	r1, [r0, #8]
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   1061a:	6813      	ldr	r3, [r2, #0]
   1061c:	f023 0304 	bic.w	r3, r3, #4
   10620:	6013      	str	r3, [r2, #0]
	}

	return api->pin_configure(port, pin, flags);
   10622:	680b      	ldr	r3, [r1, #0]
   10624:	f44f 6220 	mov.w	r2, #2560	; 0xa00
   10628:	2102      	movs	r1, #2
   1062a:	4718      	bx	r3
   1062c:	bd10      	pop	{r4, pc}
   1062e:	bf00      	nop
   10630:	00017449 	.word	0x00017449
   10634:	2000c808 	.word	0x2000c808

00010638 <led_on>:

void led_on()
{

    gpio_pin_set(dev,PIN,1);  
   10638:	4b05      	ldr	r3, [pc, #20]	; (10650 <led_on+0x18>)
   1063a:	6818      	ldr	r0, [r3, #0]

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1063c:	6903      	ldr	r3, [r0, #16]
   1063e:	681b      	ldr	r3, [r3, #0]
   10640:	075b      	lsls	r3, r3, #29
	return api->port_set_bits_raw(port, pins);
   10642:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
   10644:	f04f 0104 	mov.w	r1, #4
	return api->port_set_bits_raw(port, pins);
   10648:	bf54      	ite	pl
   1064a:	68db      	ldrpl	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   1064c:	691b      	ldrmi	r3, [r3, #16]
   1064e:	4718      	bx	r3
   10650:	2000c808 	.word	0x2000c808

00010654 <led_off>:
}

void led_off()
{
    gpio_pin_set(dev,PIN,0);
   10654:	4b05      	ldr	r3, [pc, #20]	; (1066c <led_off+0x18>)
   10656:	6818      	ldr	r0, [r3, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   10658:	6903      	ldr	r3, [r0, #16]
   1065a:	681b      	ldr	r3, [r3, #0]
   1065c:	075b      	lsls	r3, r3, #29
	return api->port_clear_bits_raw(port, pins);
   1065e:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
   10660:	f04f 0104 	mov.w	r1, #4
	return api->port_clear_bits_raw(port, pins);
   10664:	bf54      	ite	pl
   10666:	691b      	ldrpl	r3, [r3, #16]
	return api->port_set_bits_raw(port, pins);
   10668:	68db      	ldrmi	r3, [r3, #12]
   1066a:	4718      	bx	r3
   1066c:	2000c808 	.word	0x2000c808

00010670 <gpio_add_callback.constprop.0>:
 * Note: enables to add as many callback as needed on the same port.
 */
static inline int gpio_add_callback(const struct device *port,
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
   10670:	4804      	ldr	r0, [pc, #16]	; (10684 <gpio_add_callback.constprop.0+0x14>)
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
   10672:	6883      	ldr	r3, [r0, #8]
   10674:	69db      	ldr	r3, [r3, #28]
   10676:	b113      	cbz	r3, 1067e <gpio_add_callback.constprop.0+0xe>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
   10678:	2201      	movs	r2, #1
   1067a:	4903      	ldr	r1, [pc, #12]	; (10688 <gpio_add_callback.constprop.0+0x18>)
   1067c:	4718      	bx	r3
}
   1067e:	f06f 0085 	mvn.w	r0, #133	; 0x85
   10682:	4770      	bx	lr
   10684:	00017000 	.word	0x00017000
   10688:	2000c80c 	.word	0x2000c80c

0001068c <button_pressed>:



static void button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    if (BIT(s_button1.pin) == pins && gap_button_func)
   1068c:	2a40      	cmp	r2, #64	; 0x40
{
   1068e:	b507      	push	{r0, r1, r2, lr}
    if (BIT(s_button1.pin) == pins && gap_button_func)
   10690:	d10d      	bne.n	106ae <button_pressed+0x22>
   10692:	4b0d      	ldr	r3, [pc, #52]	; (106c8 <button_pressed+0x3c>)
   10694:	681b      	ldr	r3, [r3, #0]
   10696:	b13b      	cbz	r3, 106a8 <button_pressed+0x1c>
   10698:	f640 223e 	movw	r2, #2622	; 0xa3e
   1069c:	2300      	movs	r3, #0
   1069e:	e9cd 2300 	strd	r2, r3, [sp]
   106a2:	480a      	ldr	r0, [pc, #40]	; (106cc <button_pressed+0x40>)
   106a4:	f005 fb28 	bl	15cf8 <z_impl_k_timer_start>
    else if (BIT(s_button2.pin) == pins && gap_button_func)
    {
        k_timer_start(&button2_shot_timer,K_MSEC(SHOT_MS),K_MSEC(SHOT_MS));
    }
#endif    
}
   106a8:	b003      	add	sp, #12
   106aa:	f85d fb04 	ldr.w	pc, [sp], #4
    else if (BIT(s_button2.pin) == pins && gap_button_func)
   106ae:	2a80      	cmp	r2, #128	; 0x80
   106b0:	d1fa      	bne.n	106a8 <button_pressed+0x1c>
   106b2:	4b05      	ldr	r3, [pc, #20]	; (106c8 <button_pressed+0x3c>)
   106b4:	681b      	ldr	r3, [r3, #0]
   106b6:	2b00      	cmp	r3, #0
   106b8:	d0f6      	beq.n	106a8 <button_pressed+0x1c>
   106ba:	f640 223e 	movw	r2, #2622	; 0xa3e
   106be:	2300      	movs	r3, #0
   106c0:	4803      	ldr	r0, [pc, #12]	; (106d0 <button_pressed+0x44>)
   106c2:	e9cd 2300 	strd	r2, r3, [sp]
   106c6:	e7ed      	b.n	106a4 <button_pressed+0x18>
   106c8:	2000c818 	.word	0x2000c818
   106cc:	2000c620 	.word	0x2000c620
   106d0:	2000c690 	.word	0x2000c690

000106d4 <button1_long_timer_handler>:
	return gpio_pin_get(spec->port, spec->pin);
   106d4:	2106      	movs	r1, #6
{
   106d6:	b508      	push	{r3, lr}
   106d8:	4807      	ldr	r0, [pc, #28]	; (106f8 <button1_long_timer_handler+0x24>)
   106da:	f005 fb93 	bl	15e04 <gpio_pin_get>
    if(val==1)
   106de:	2801      	cmp	r0, #1
   106e0:	4602      	mov	r2, r0
   106e2:	d108      	bne.n	106f6 <button1_long_timer_handler+0x22>
        gap_button_func(BUTTON_1 ,val , LONG_PRESS);
   106e4:	4b05      	ldr	r3, [pc, #20]	; (106fc <button1_long_timer_handler+0x28>)
   106e6:	4601      	mov	r1, r0
   106e8:	681b      	ldr	r3, [r3, #0]
   106ea:	4798      	blx	r3
}
   106ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_impl_k_timer_stop(timer);
   106f0:	4803      	ldr	r0, [pc, #12]	; (10700 <button1_long_timer_handler+0x2c>)
   106f2:	f006 bc2d 	b.w	16f50 <z_impl_k_timer_stop>
   106f6:	bd08      	pop	{r3, pc}
   106f8:	00017000 	.word	0x00017000
   106fc:	2000c818 	.word	0x2000c818
   10700:	2000c5e8 	.word	0x2000c5e8

00010704 <button2_long_timer_handler>:
   10704:	2107      	movs	r1, #7
{
   10706:	b508      	push	{r3, lr}
   10708:	4808      	ldr	r0, [pc, #32]	; (1072c <button2_long_timer_handler+0x28>)
   1070a:	f005 fb7b 	bl	15e04 <gpio_pin_get>
    if(val==1)
   1070e:	2801      	cmp	r0, #1
   10710:	4602      	mov	r2, r0
   10712:	d109      	bne.n	10728 <button2_long_timer_handler+0x24>
        gap_button_func(BUTTON_2 ,val , LONG_PRESS);
   10714:	4b06      	ldr	r3, [pc, #24]	; (10730 <button2_long_timer_handler+0x2c>)
   10716:	4601      	mov	r1, r0
   10718:	681b      	ldr	r3, [r3, #0]
   1071a:	2002      	movs	r0, #2
   1071c:	4798      	blx	r3
}
   1071e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   10722:	4804      	ldr	r0, [pc, #16]	; (10734 <button2_long_timer_handler+0x30>)
   10724:	f006 bc14 	b.w	16f50 <z_impl_k_timer_stop>
   10728:	bd08      	pop	{r3, pc}
   1072a:	bf00      	nop
   1072c:	00017000 	.word	0x00017000
   10730:	2000c818 	.word	0x2000c818
   10734:	2000c658 	.word	0x2000c658

00010738 <button1_shot_timer_handler>:
{
   10738:	b507      	push	{r0, r1, r2, lr}
   1073a:	2106      	movs	r1, #6
   1073c:	480b      	ldr	r0, [pc, #44]	; (1076c <button1_shot_timer_handler+0x34>)
   1073e:	f005 fb61 	bl	15e04 <gpio_pin_get>
    if(val ==1)
   10742:	2801      	cmp	r0, #1
   10744:	4601      	mov	r1, r0
   10746:	d10e      	bne.n	10766 <button1_shot_timer_handler+0x2e>
        gap_button_func(BUTTON_1,val,SHOT_PRESS);
   10748:	4b09      	ldr	r3, [pc, #36]	; (10770 <button1_shot_timer_handler+0x38>)
   1074a:	2200      	movs	r2, #0
   1074c:	681b      	ldr	r3, [r3, #0]
   1074e:	4798      	blx	r3
   10750:	4808      	ldr	r0, [pc, #32]	; (10774 <button1_shot_timer_handler+0x3c>)
   10752:	f006 fbfd 	bl	16f50 <z_impl_k_timer_stop>
   10756:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1075a:	2300      	movs	r3, #0
	z_impl_k_timer_start(timer, duration, period);
   1075c:	4806      	ldr	r0, [pc, #24]	; (10778 <button1_shot_timer_handler+0x40>)
   1075e:	e9cd 2300 	strd	r2, r3, [sp]
   10762:	f005 fac9 	bl	15cf8 <z_impl_k_timer_start>
}
   10766:	b003      	add	sp, #12
   10768:	f85d fb04 	ldr.w	pc, [sp], #4
   1076c:	00017000 	.word	0x00017000
   10770:	2000c818 	.word	0x2000c818
   10774:	2000c620 	.word	0x2000c620
   10778:	2000c5e8 	.word	0x2000c5e8

0001077c <button2_shot_timer_handler>:
{
   1077c:	b507      	push	{r0, r1, r2, lr}
   1077e:	2107      	movs	r1, #7
   10780:	480c      	ldr	r0, [pc, #48]	; (107b4 <button2_shot_timer_handler+0x38>)
   10782:	f005 fb3f 	bl	15e04 <gpio_pin_get>
    if(val ==1)
   10786:	2801      	cmp	r0, #1
   10788:	4601      	mov	r1, r0
   1078a:	d10f      	bne.n	107ac <button2_shot_timer_handler+0x30>
        gap_button_func(BUTTON_2,val,SHOT_PRESS);
   1078c:	4b0a      	ldr	r3, [pc, #40]	; (107b8 <button2_shot_timer_handler+0x3c>)
   1078e:	2200      	movs	r2, #0
   10790:	2002      	movs	r0, #2
   10792:	681b      	ldr	r3, [r3, #0]
   10794:	4798      	blx	r3
	z_impl_k_timer_stop(timer);
   10796:	4809      	ldr	r0, [pc, #36]	; (107bc <button2_shot_timer_handler+0x40>)
   10798:	f006 fbda 	bl	16f50 <z_impl_k_timer_stop>
   1079c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   107a0:	2300      	movs	r3, #0
	z_impl_k_timer_start(timer, duration, period);
   107a2:	4807      	ldr	r0, [pc, #28]	; (107c0 <button2_shot_timer_handler+0x44>)
   107a4:	e9cd 2300 	strd	r2, r3, [sp]
   107a8:	f005 faa6 	bl	15cf8 <z_impl_k_timer_start>
}
   107ac:	b003      	add	sp, #12
   107ae:	f85d fb04 	ldr.w	pc, [sp], #4
   107b2:	bf00      	nop
   107b4:	00017000 	.word	0x00017000
   107b8:	2000c818 	.word	0x2000c818
   107bc:	2000c690 	.word	0x2000c690
   107c0:	2000c658 	.word	0x2000c658

000107c4 <button_handler_init>:

int button_handler_init(button_handler_t button_func)
{
   107c4:	b538      	push	{r3, r4, r5, lr}
   107c6:	4604      	mov	r4, r0
    k_timer_init(&button1_long_timer,button1_long_timer_handler,NULL);
   107c8:	2200      	movs	r2, #0
   107ca:	492e      	ldr	r1, [pc, #184]	; (10884 <button_handler_init+0xc0>)
   107cc:	482e      	ldr	r0, [pc, #184]	; (10888 <button_handler_init+0xc4>)
   107ce:	f006 fbb3 	bl	16f38 <k_timer_init>
    k_timer_init(&button2_long_timer,button2_long_timer_handler,NULL);
   107d2:	2200      	movs	r2, #0
   107d4:	492d      	ldr	r1, [pc, #180]	; (1088c <button_handler_init+0xc8>)
   107d6:	482e      	ldr	r0, [pc, #184]	; (10890 <button_handler_init+0xcc>)
   107d8:	f006 fbae 	bl	16f38 <k_timer_init>
    k_timer_init(&button1_shot_timer,button1_shot_timer_handler,NULL);
   107dc:	2200      	movs	r2, #0
   107de:	492d      	ldr	r1, [pc, #180]	; (10894 <button_handler_init+0xd0>)
   107e0:	482d      	ldr	r0, [pc, #180]	; (10898 <button_handler_init+0xd4>)
   107e2:	f006 fba9 	bl	16f38 <k_timer_init>
    k_timer_init(&button2_shot_timer,button2_shot_timer_handler,NULL);
   107e6:	2200      	movs	r2, #0
   107e8:	492c      	ldr	r1, [pc, #176]	; (1089c <button_handler_init+0xd8>)
   107ea:	482d      	ldr	r0, [pc, #180]	; (108a0 <button_handler_init+0xdc>)
   107ec:	f006 fba4 	bl	16f38 <k_timer_init>
    int ret = 0;

    gap_button_func = button_func;
   107f0:	4b2c      	ldr	r3, [pc, #176]	; (108a4 <button_handler_init+0xe0>)
   107f2:	601c      	str	r4, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
   107f4:	4d2c      	ldr	r5, [pc, #176]	; (108a8 <button_handler_init+0xe4>)
   107f6:	4628      	mov	r0, r5
   107f8:	f006 f97e 	bl	16af8 <z_device_ready>
   107fc:	b1e0      	cbz	r0, 10838 <button_handler_init+0x74>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&port, *(uintptr_t *)&pin, *(uintptr_t *)&flags, K_SYSCALL_GPIO_PIN_CONFIGURE);
	}
#endif
	compiler_barrier();
	return z_impl_gpio_pin_configure(port, pin, flags);
   107fe:	f240 1211 	movw	r2, #273	; 0x111
   10802:	2106      	movs	r1, #6
   10804:	4628      	mov	r0, r5
   10806:	f005 fae3 	bl	15dd0 <z_impl_gpio_pin_configure>
    {
        printk("Error: button device %s is not ready\n", s_button1.port->name);
        return -1;
    }
    ret = gpio_pin_configure_dt(&s_button1, GPIO_INPUT);
    if (ret != 0)
   1080a:	4604      	mov	r4, r0
   1080c:	b130      	cbz	r0, 1081c <button_handler_init+0x58>
    {
        printk("Error %d: failed to configure %s pin %d\n", ret, s_button1.port->name, s_button1.pin);
   1080e:	2306      	movs	r3, #6
        return -1;
    }
    ret = gpio_pin_configure_dt(&s_button2, GPIO_INPUT);
    if (ret != 0)
    {
        printk("Error %d: failed to configure %s pin %d\n", ret, s_button2.port->name, s_button2.pin);
   10810:	4621      	mov	r1, r4
   10812:	682a      	ldr	r2, [r5, #0]
   10814:	4825      	ldr	r0, [pc, #148]	; (108ac <button_handler_init+0xe8>)
    }

    ret = gpio_pin_interrupt_configure_dt(&s_button2, GPIO_INT_EDGE_BOTH);
    if (ret != 0) 
    {
      printk("Error %d: failed to configure interrupt on %s pin %d\n", ret, s_button2.port->name, s_button2.pin);
   10816:	f005 fb36 	bl	15e86 <printk>
      return ret;
   1081a:	e013      	b.n	10844 <button_handler_init+0x80>
    ret = gpio_pin_interrupt_configure_dt(&s_button1, GPIO_INT_EDGE_BOTH);
   1081c:	4824      	ldr	r0, [pc, #144]	; (108b0 <button_handler_init+0xec>)
   1081e:	f005 fb05 	bl	15e2c <gpio_pin_interrupt_configure_dt.constprop.0>
    if (ret != 0) 
   10822:	4604      	mov	r4, r0
   10824:	b120      	cbz	r0, 10830 <button_handler_init+0x6c>
      printk("Error %d: failed to configure interrupt on %s pin %d\n", ret, s_button1.port->name, s_button1.pin);
   10826:	2306      	movs	r3, #6
      printk("Error %d: failed to configure interrupt on %s pin %d\n", ret, s_button2.port->name, s_button2.pin);
   10828:	4621      	mov	r1, r4
   1082a:	682a      	ldr	r2, [r5, #0]
   1082c:	4821      	ldr	r0, [pc, #132]	; (108b4 <button_handler_init+0xf0>)
   1082e:	e7f2      	b.n	10816 <button_handler_init+0x52>
   10830:	4628      	mov	r0, r5
   10832:	f006 f961 	bl	16af8 <z_device_ready>
   10836:	b938      	cbnz	r0, 10848 <button_handler_init+0x84>
        printk("Error: button device %s is not ready\n",  s_button2.port->name);
   10838:	6829      	ldr	r1, [r5, #0]
   1083a:	481f      	ldr	r0, [pc, #124]	; (108b8 <button_handler_init+0xf4>)
   1083c:	f005 fb23 	bl	15e86 <printk>
        return -1;
   10840:	f04f 34ff 	mov.w	r4, #4294967295
    gpio_add_callback(s_button1.port, &button_cb_data);
#endif

    printk("init button driver complete\n");
    return 0;
}
   10844:	4620      	mov	r0, r4
   10846:	bd38      	pop	{r3, r4, r5, pc}
   10848:	f240 1211 	movw	r2, #273	; 0x111
   1084c:	2107      	movs	r1, #7
   1084e:	4628      	mov	r0, r5
   10850:	f005 fabe 	bl	15dd0 <z_impl_gpio_pin_configure>
    if (ret != 0)
   10854:	4604      	mov	r4, r0
   10856:	b108      	cbz	r0, 1085c <button_handler_init+0x98>
        printk("Error %d: failed to configure %s pin %d\n", ret, s_button2.port->name, s_button2.pin);
   10858:	2307      	movs	r3, #7
   1085a:	e7d9      	b.n	10810 <button_handler_init+0x4c>
    ret = gpio_pin_interrupt_configure_dt(&s_button2, GPIO_INT_EDGE_BOTH);
   1085c:	4817      	ldr	r0, [pc, #92]	; (108bc <button_handler_init+0xf8>)
   1085e:	f005 fae5 	bl	15e2c <gpio_pin_interrupt_configure_dt.constprop.0>
    if (ret != 0) 
   10862:	4604      	mov	r4, r0
   10864:	b108      	cbz	r0, 1086a <button_handler_init+0xa6>
      printk("Error %d: failed to configure interrupt on %s pin %d\n", ret, s_button2.port->name, s_button2.pin);
   10866:	2307      	movs	r3, #7
   10868:	e7de      	b.n	10828 <button_handler_init+0x64>
	callback->handler = handler;
   1086a:	4b15      	ldr	r3, [pc, #84]	; (108c0 <button_handler_init+0xfc>)
   1086c:	4a15      	ldr	r2, [pc, #84]	; (108c4 <button_handler_init+0x100>)
   1086e:	605a      	str	r2, [r3, #4]
	callback->pin_mask = pin_mask;
   10870:	22c0      	movs	r2, #192	; 0xc0
   10872:	609a      	str	r2, [r3, #8]
    gpio_add_callback(s_button1.port, &button_cb_data);
   10874:	f7ff fefc 	bl	10670 <gpio_add_callback.constprop.0>
    gpio_add_callback(s_button2.port, &button_cb_data);
   10878:	f7ff fefa 	bl	10670 <gpio_add_callback.constprop.0>
    printk("init button driver complete\n");
   1087c:	4812      	ldr	r0, [pc, #72]	; (108c8 <button_handler_init+0x104>)
   1087e:	f005 fb02 	bl	15e86 <printk>
    return 0;
   10882:	e7df      	b.n	10844 <button_handler_init+0x80>
   10884:	000106d5 	.word	0x000106d5
   10888:	2000c5e8 	.word	0x2000c5e8
   1088c:	00010705 	.word	0x00010705
   10890:	2000c658 	.word	0x2000c658
   10894:	00010739 	.word	0x00010739
   10898:	2000c620 	.word	0x2000c620
   1089c:	0001077d 	.word	0x0001077d
   108a0:	2000c690 	.word	0x2000c690
   108a4:	2000c818 	.word	0x2000c818
   108a8:	00017000 	.word	0x00017000
   108ac:	00017476 	.word	0x00017476
   108b0:	00017298 	.word	0x00017298
   108b4:	0001749f 	.word	0x0001749f
   108b8:	00017450 	.word	0x00017450
   108bc:	000172a0 	.word	0x000172a0
   108c0:	2000c80c 	.word	0x2000c80c
   108c4:	0001068d 	.word	0x0001068d
   108c8:	000174d5 	.word	0x000174d5

000108cc <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   108cc:	680b      	ldr	r3, [r1, #0]
   108ce:	3301      	adds	r3, #1
   108d0:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   108d2:	4b01      	ldr	r3, [pc, #4]	; (108d8 <char_out+0xc>)
   108d4:	681b      	ldr	r3, [r3, #0]
   108d6:	4718      	bx	r3
   108d8:	2000c500 	.word	0x2000c500

000108dc <__printk_hook_install>:
	_char_out = fn;
   108dc:	4b01      	ldr	r3, [pc, #4]	; (108e4 <__printk_hook_install+0x8>)
   108de:	6018      	str	r0, [r3, #0]
}
   108e0:	4770      	bx	lr
   108e2:	bf00      	nop
   108e4:	2000c500 	.word	0x2000c500

000108e8 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
   108e8:	b507      	push	{r0, r1, r2, lr}
   108ea:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
   108ec:	2100      	movs	r1, #0
{
   108ee:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
   108f0:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
   108f2:	4803      	ldr	r0, [pc, #12]	; (10900 <vprintk+0x18>)
   108f4:	a901      	add	r1, sp, #4
   108f6:	f000 f8eb 	bl	10ad0 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
   108fa:	b003      	add	sp, #12
   108fc:	f85d fb04 	ldr.w	pc, [sp], #4
   10900:	000108cd 	.word	0x000108cd

00010904 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   10904:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   10908:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
   1090c:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   1090e:	f019 0808 	ands.w	r8, r9, #8
{
   10912:	4693      	mov	fp, r2
	if (processing) {
   10914:	d00d      	beq.n	10932 <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
   10916:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   10918:	bf0c      	ite	eq
   1091a:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
   1091e:	f049 0920 	orrne.w	r9, r9, #32
   10922:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   10926:	f38b 8811 	msr	BASEPRI, fp
   1092a:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   1092e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   10932:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
   10936:	2902      	cmp	r1, #2
   10938:	d107      	bne.n	1094a <process_event+0x46>
			evt = process_recheck(mgr);
   1093a:	4620      	mov	r0, r4
   1093c:	f005 fab0 	bl	15ea0 <process_recheck>
		if (evt == EVT_NOP) {
   10940:	2800      	cmp	r0, #0
   10942:	d0f0      	beq.n	10926 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
   10944:	2801      	cmp	r0, #1
   10946:	8b23      	ldrh	r3, [r4, #24]
   10948:	d150      	bne.n	109ec <process_event+0xe8>
			res = mgr->last_res;
   1094a:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1094c:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   1094e:	2f00      	cmp	r7, #0
   10950:	da15      	bge.n	1097e <process_event+0x7a>
		*clients = mgr->clients;
   10952:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   10954:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
   10958:	e9c4 8800 	strd	r8, r8, [r4]
   1095c:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
   10960:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
   10962:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   10964:	8b21      	ldrh	r1, [r4, #24]
   10966:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1096a:	45ca      	cmp	sl, r9
   1096c:	d002      	beq.n	10974 <process_event+0x70>
		if (do_monitors
   1096e:	68a3      	ldr	r3, [r4, #8]
   10970:	2b00      	cmp	r3, #0
   10972:	d15c      	bne.n	10a2e <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
   10974:	b90d      	cbnz	r5, 1097a <process_event+0x76>
		    || (transit != NULL)) {
   10976:	2e00      	cmp	r6, #0
   10978:	d074      	beq.n	10a64 <process_event+0x160>
   1097a:	2300      	movs	r3, #0
   1097c:	e058      	b.n	10a30 <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1097e:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   10982:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   10984:	2a01      	cmp	r2, #1
   10986:	d820      	bhi.n	109ca <process_event+0xc6>
		*clients = mgr->clients;
   10988:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   1098c:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   1098e:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
   10990:	b289      	uxth	r1, r1
	list->tail = NULL;
   10992:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   10996:	d10c      	bne.n	109b2 <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   10998:	2d00      	cmp	r5, #0
   1099a:	462b      	mov	r3, r5
   1099c:	bf38      	it	cc
   1099e:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   109a0:	b12b      	cbz	r3, 109ae <process_event+0xaa>
				mgr->refs += 1U;
   109a2:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   109a4:	681b      	ldr	r3, [r3, #0]
   109a6:	3201      	adds	r2, #1
   109a8:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   109aa:	2b00      	cmp	r3, #0
   109ac:	d1f8      	bne.n	109a0 <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   109ae:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   109b2:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   109b4:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   109b6:	f005 fa73 	bl	15ea0 <process_recheck>
   109ba:	4606      	mov	r6, r0
   109bc:	2800      	cmp	r0, #0
   109be:	d0d1      	beq.n	10964 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   109c0:	8b23      	ldrh	r3, [r4, #24]
   109c2:	f043 0320 	orr.w	r3, r3, #32
   109c6:	8323      	strh	r3, [r4, #24]
   109c8:	e7cb      	b.n	10962 <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
   109ca:	2b04      	cmp	r3, #4
   109cc:	d10c      	bne.n	109e8 <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   109ce:	f021 0107 	bic.w	r1, r1, #7
   109d2:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   109d4:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   109d6:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   109d8:	f005 fa62 	bl	15ea0 <process_recheck>
   109dc:	4605      	mov	r5, r0
   109de:	2800      	cmp	r0, #0
   109e0:	d0bf      	beq.n	10962 <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   109e2:	f041 0120 	orr.w	r1, r1, #32
   109e6:	8321      	strh	r1, [r4, #24]
   109e8:	2500      	movs	r5, #0
   109ea:	e7ba      	b.n	10962 <process_event+0x5e>
		} else if (evt == EVT_START) {
   109ec:	2803      	cmp	r0, #3
   109ee:	d109      	bne.n	10a04 <process_event+0x100>
			transit = mgr->transitions->start;
   109f0:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   109f2:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
   109f6:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   109f8:	f043 0306 	orr.w	r3, r3, #6
}
   109fc:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
   109fe:	8323      	strh	r3, [r4, #24]
		res = 0;
   10a00:	462f      	mov	r7, r5
   10a02:	e7af      	b.n	10964 <process_event+0x60>
		} else if (evt == EVT_STOP) {
   10a04:	2804      	cmp	r0, #4
   10a06:	d106      	bne.n	10a16 <process_event+0x112>
			transit = mgr->transitions->stop;
   10a08:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   10a0a:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
   10a0e:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   10a10:	f043 0304 	orr.w	r3, r3, #4
   10a14:	e7f2      	b.n	109fc <process_event+0xf8>
		} else if (evt == EVT_RESET) {
   10a16:	2805      	cmp	r0, #5
   10a18:	d106      	bne.n	10a28 <process_event+0x124>
			transit = mgr->transitions->reset;
   10a1a:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   10a1c:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
   10a20:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   10a22:	f043 0305 	orr.w	r3, r3, #5
   10a26:	e7e9      	b.n	109fc <process_event+0xf8>
   10a28:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
   10a2a:	462e      	mov	r6, r5
   10a2c:	e7e8      	b.n	10a00 <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
   10a2e:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   10a30:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   10a34:	8321      	strh	r1, [r4, #24]
   10a36:	f38b 8811 	msr	BASEPRI, fp
   10a3a:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
   10a3e:	bb03      	cbnz	r3, 10a82 <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
   10a40:	2d00      	cmp	r5, #0
   10a42:	d133      	bne.n	10aac <process_event+0x1a8>
			if (transit != NULL) {
   10a44:	b116      	cbz	r6, 10a4c <process_event+0x148>
				transit(mgr, transition_complete);
   10a46:	4620      	mov	r0, r4
   10a48:	4920      	ldr	r1, [pc, #128]	; (10acc <process_event+0x1c8>)
   10a4a:	47b0      	blx	r6
	__asm__ volatile(
   10a4c:	f04f 0320 	mov.w	r3, #32
   10a50:	f3ef 8b11 	mrs	fp, BASEPRI
   10a54:	f383 8812 	msr	BASEPRI_MAX, r3
   10a58:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   10a5c:	8b23      	ldrh	r3, [r4, #24]
   10a5e:	f023 0308 	bic.w	r3, r3, #8
   10a62:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   10a64:	8b23      	ldrh	r3, [r4, #24]
   10a66:	06da      	lsls	r2, r3, #27
   10a68:	d528      	bpl.n	10abc <process_event+0x1b8>
			evt = EVT_COMPLETE;
   10a6a:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   10a6c:	f023 0310 	bic.w	r3, r3, #16
   10a70:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   10a72:	f8b4 9018 	ldrh.w	r9, [r4, #24]
   10a76:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
   10a7a:	2900      	cmp	r1, #0
   10a7c:	f47f af5b 	bne.w	10936 <process_event+0x32>
out:
   10a80:	e751      	b.n	10926 <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   10a82:	68a1      	ldr	r1, [r4, #8]
   10a84:	2900      	cmp	r1, #0
   10a86:	d0db      	beq.n	10a40 <process_event+0x13c>
	return node->next;
   10a88:	680b      	ldr	r3, [r1, #0]
   10a8a:	2b00      	cmp	r3, #0
   10a8c:	bf38      	it	cc
   10a8e:	2300      	movcc	r3, #0
   10a90:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
   10a92:	4652      	mov	r2, sl
   10a94:	463b      	mov	r3, r7
   10a96:	4620      	mov	r0, r4
   10a98:	f8d1 b004 	ldr.w	fp, [r1, #4]
   10a9c:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   10a9e:	f1b9 0f00 	cmp.w	r9, #0
   10aa2:	d0cd      	beq.n	10a40 <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   10aa4:	4649      	mov	r1, r9
   10aa6:	f8d9 3000 	ldr.w	r3, [r9]
   10aaa:	e7ee      	b.n	10a8a <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   10aac:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
   10aae:	463b      	mov	r3, r7
   10ab0:	4652      	mov	r2, sl
   10ab2:	4620      	mov	r0, r4
   10ab4:	682d      	ldr	r5, [r5, #0]
   10ab6:	f005 fa0f 	bl	15ed8 <notify_one>
   10aba:	e7c1      	b.n	10a40 <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   10abc:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   10ac0:	bf1e      	ittt	ne
   10ac2:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
   10ac6:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   10ac8:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
   10aca:	e7d2      	b.n	10a72 <process_event+0x16e>
   10acc:	00015f05 	.word	0x00015f05

00010ad0 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
   10ad0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10ad4:	468b      	mov	fp, r1
   10ad6:	4692      	mov	sl, r2
   10ad8:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   10ada:	2500      	movs	r5, #0
{
   10adc:	b091      	sub	sp, #68	; 0x44
   10ade:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   10ae0:	f89a 0000 	ldrb.w	r0, [sl]
   10ae4:	b908      	cbnz	r0, 10aea <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
   10ae6:	4628      	mov	r0, r5
   10ae8:	e35e      	b.n	111a8 <cbvprintf+0x6d8>
		if (*fp != '%') {
   10aea:	2825      	cmp	r0, #37	; 0x25
   10aec:	f10a 0701 	add.w	r7, sl, #1
   10af0:	d007      	beq.n	10b02 <cbvprintf+0x32>
			OUTC('%');
   10af2:	4659      	mov	r1, fp
   10af4:	9b02      	ldr	r3, [sp, #8]
   10af6:	4798      	blx	r3
   10af8:	2800      	cmp	r0, #0
   10afa:	f2c0 8355 	blt.w	111a8 <cbvprintf+0x6d8>
   10afe:	3501      	adds	r5, #1
			break;
   10b00:	e210      	b.n	10f24 <cbvprintf+0x454>
		} state = {
   10b02:	2218      	movs	r2, #24
   10b04:	2100      	movs	r1, #0
   10b06:	a80a      	add	r0, sp, #40	; 0x28
   10b08:	f005 fd49 	bl	1659e <memset>
	if (*sp == '%') {
   10b0c:	f89a 3001 	ldrb.w	r3, [sl, #1]
   10b10:	2b25      	cmp	r3, #37	; 0x25
   10b12:	d078      	beq.n	10c06 <cbvprintf+0x136>
   10b14:	2200      	movs	r2, #0
   10b16:	4694      	mov	ip, r2
   10b18:	4616      	mov	r6, r2
   10b1a:	4696      	mov	lr, r2
   10b1c:	4610      	mov	r0, r2
   10b1e:	4639      	mov	r1, r7
		switch (*sp) {
   10b20:	f817 3b01 	ldrb.w	r3, [r7], #1
   10b24:	2b2b      	cmp	r3, #43	; 0x2b
   10b26:	f000 809d 	beq.w	10c64 <cbvprintf+0x194>
   10b2a:	f200 8094 	bhi.w	10c56 <cbvprintf+0x186>
   10b2e:	2b20      	cmp	r3, #32
   10b30:	f000 809b 	beq.w	10c6a <cbvprintf+0x19a>
   10b34:	2b23      	cmp	r3, #35	; 0x23
   10b36:	f000 809a 	beq.w	10c6e <cbvprintf+0x19e>
   10b3a:	b128      	cbz	r0, 10b48 <cbvprintf+0x78>
   10b3c:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   10b40:	f040 0004 	orr.w	r0, r0, #4
   10b44:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   10b48:	f1be 0f00 	cmp.w	lr, #0
   10b4c:	d005      	beq.n	10b5a <cbvprintf+0x8a>
   10b4e:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   10b52:	f040 0008 	orr.w	r0, r0, #8
   10b56:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   10b5a:	b12e      	cbz	r6, 10b68 <cbvprintf+0x98>
   10b5c:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   10b60:	f040 0010 	orr.w	r0, r0, #16
   10b64:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   10b68:	f1bc 0f00 	cmp.w	ip, #0
   10b6c:	d005      	beq.n	10b7a <cbvprintf+0xaa>
   10b6e:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
   10b72:	f040 0020 	orr.w	r0, r0, #32
   10b76:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
   10b7a:	b12a      	cbz	r2, 10b88 <cbvprintf+0xb8>
   10b7c:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   10b80:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   10b84:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
   10b88:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   10b8c:	f002 0044 	and.w	r0, r2, #68	; 0x44
   10b90:	2844      	cmp	r0, #68	; 0x44
   10b92:	d103      	bne.n	10b9c <cbvprintf+0xcc>
		conv->flag_zero = false;
   10b94:	f36f 1286 	bfc	r2, #6, #1
   10b98:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
   10b9c:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   10ba0:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
   10ba2:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   10ba6:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
   10baa:	d17b      	bne.n	10ca4 <cbvprintf+0x1d4>
		conv->width_star = true;
   10bac:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   10bb0:	1c4b      	adds	r3, r1, #1
   10bb2:	f042 0201 	orr.w	r2, r2, #1
   10bb6:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
   10bba:	781a      	ldrb	r2, [r3, #0]
   10bbc:	2a2e      	cmp	r2, #46	; 0x2e
   10bbe:	bf0c      	ite	eq
   10bc0:	2101      	moveq	r1, #1
   10bc2:	2100      	movne	r1, #0
   10bc4:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   10bc8:	f361 0241 	bfi	r2, r1, #1, #1
   10bcc:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
   10bd0:	d174      	bne.n	10cbc <cbvprintf+0x1ec>
	if (*sp == '*') {
   10bd2:	785a      	ldrb	r2, [r3, #1]
   10bd4:	2a2a      	cmp	r2, #42	; 0x2a
   10bd6:	d06a      	beq.n	10cae <cbvprintf+0x1de>
	size_t val = 0;
   10bd8:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
   10bda:	260a      	movs	r6, #10
   10bdc:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   10bde:	4618      	mov	r0, r3
   10be0:	f810 2b01 	ldrb.w	r2, [r0], #1
   10be4:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   10be8:	2f09      	cmp	r7, #9
   10bea:	f240 808e 	bls.w	10d0a <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
   10bee:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
   10bf2:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
   10bf4:	f3c2 0040 	ubfx	r0, r2, #1, #1
   10bf8:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
   10bfc:	f361 0241 	bfi	r2, r1, #1, #1
   10c00:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   10c04:	e05a      	b.n	10cbc <cbvprintf+0x1ec>
		conv->specifier = *sp++;
   10c06:	f10a 0702 	add.w	r7, sl, #2
   10c0a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
   10c0e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   10c12:	07d9      	lsls	r1, r3, #31
   10c14:	f140 8149 	bpl.w	10eaa <cbvprintf+0x3da>
			width = va_arg(ap, int);
   10c18:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
   10c1c:	f1b9 0f00 	cmp.w	r9, #0
   10c20:	da07      	bge.n	10c32 <cbvprintf+0x162>
				conv->flag_dash = true;
   10c22:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
   10c26:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
   10c2a:	f042 0204 	orr.w	r2, r2, #4
   10c2e:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
   10c32:	075a      	lsls	r2, r3, #29
   10c34:	f140 8142 	bpl.w	10ebc <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
   10c38:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
   10c3c:	f1b8 0f00 	cmp.w	r8, #0
   10c40:	f280 8141 	bge.w	10ec6 <cbvprintf+0x3f6>
				conv->prec_present = false;
   10c44:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   10c48:	f36f 0341 	bfc	r3, #1, #1
   10c4c:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
   10c50:	f04f 38ff 	mov.w	r8, #4294967295
   10c54:	e137      	b.n	10ec6 <cbvprintf+0x3f6>
		switch (*sp) {
   10c56:	2b2d      	cmp	r3, #45	; 0x2d
   10c58:	d00c      	beq.n	10c74 <cbvprintf+0x1a4>
   10c5a:	2b30      	cmp	r3, #48	; 0x30
   10c5c:	f47f af6d 	bne.w	10b3a <cbvprintf+0x6a>
			conv->flag_zero = true;
   10c60:	2201      	movs	r2, #1
	} while (loop);
   10c62:	e75c      	b.n	10b1e <cbvprintf+0x4e>
			conv->flag_plus = true;
   10c64:	f04f 0e01 	mov.w	lr, #1
   10c68:	e759      	b.n	10b1e <cbvprintf+0x4e>
			conv->flag_space = true;
   10c6a:	2601      	movs	r6, #1
   10c6c:	e757      	b.n	10b1e <cbvprintf+0x4e>
			conv->flag_hash = true;
   10c6e:	f04f 0c01 	mov.w	ip, #1
   10c72:	e754      	b.n	10b1e <cbvprintf+0x4e>
		switch (*sp) {
   10c74:	2001      	movs	r0, #1
   10c76:	e752      	b.n	10b1e <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
   10c78:	4633      	mov	r3, r6
   10c7a:	fb0c 0202 	mla	r2, ip, r2, r0
   10c7e:	3a30      	subs	r2, #48	; 0x30
   10c80:	461e      	mov	r6, r3
   10c82:	f816 0b01 	ldrb.w	r0, [r6], #1
   10c86:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
   10c8a:	2f09      	cmp	r7, #9
   10c8c:	d9f4      	bls.n	10c78 <cbvprintf+0x1a8>
	if (sp != wp) {
   10c8e:	4299      	cmp	r1, r3
   10c90:	d093      	beq.n	10bba <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   10c92:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
   10c96:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
   10c98:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   10c9a:	f362 0141 	bfi	r1, r2, #1, #1
   10c9e:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   10ca2:	e78a      	b.n	10bba <cbvprintf+0xea>
   10ca4:	460b      	mov	r3, r1
	size_t val = 0;
   10ca6:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   10ca8:	f04f 0c0a 	mov.w	ip, #10
   10cac:	e7e8      	b.n	10c80 <cbvprintf+0x1b0>
		conv->prec_star = true;
   10cae:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
   10cb2:	3302      	adds	r3, #2
		conv->prec_star = true;
   10cb4:	f042 0204 	orr.w	r2, r2, #4
   10cb8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
   10cbc:	461f      	mov	r7, r3
   10cbe:	f817 2b01 	ldrb.w	r2, [r7], #1
   10cc2:	2a6c      	cmp	r2, #108	; 0x6c
   10cc4:	d041      	beq.n	10d4a <cbvprintf+0x27a>
   10cc6:	d825      	bhi.n	10d14 <cbvprintf+0x244>
   10cc8:	2a68      	cmp	r2, #104	; 0x68
   10cca:	d02b      	beq.n	10d24 <cbvprintf+0x254>
   10ccc:	2a6a      	cmp	r2, #106	; 0x6a
   10cce:	d046      	beq.n	10d5e <cbvprintf+0x28e>
   10cd0:	2a4c      	cmp	r2, #76	; 0x4c
   10cd2:	d04c      	beq.n	10d6e <cbvprintf+0x29e>
   10cd4:	461f      	mov	r7, r3
	conv->specifier = *sp++;
   10cd6:	f817 2b01 	ldrb.w	r2, [r7], #1
   10cda:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
   10cde:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
   10ce0:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
   10ce4:	f200 80d9 	bhi.w	10e9a <cbvprintf+0x3ca>
   10ce8:	2a57      	cmp	r2, #87	; 0x57
   10cea:	d84d      	bhi.n	10d88 <cbvprintf+0x2b8>
   10cec:	2a41      	cmp	r2, #65	; 0x41
   10cee:	d003      	beq.n	10cf8 <cbvprintf+0x228>
   10cf0:	3a45      	subs	r2, #69	; 0x45
   10cf2:	2a02      	cmp	r2, #2
   10cf4:	f200 80d1 	bhi.w	10e9a <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
   10cf8:	2204      	movs	r2, #4
   10cfa:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   10cfe:	f362 0302 	bfi	r3, r2, #0, #3
   10d02:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
   10d06:	2301      	movs	r3, #1
			break;
   10d08:	e09e      	b.n	10e48 <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
   10d0a:	fb06 2101 	mla	r1, r6, r1, r2
   10d0e:	4603      	mov	r3, r0
   10d10:	3930      	subs	r1, #48	; 0x30
   10d12:	e764      	b.n	10bde <cbvprintf+0x10e>
	switch (*sp) {
   10d14:	2a74      	cmp	r2, #116	; 0x74
   10d16:	d026      	beq.n	10d66 <cbvprintf+0x296>
   10d18:	2a7a      	cmp	r2, #122	; 0x7a
   10d1a:	d1db      	bne.n	10cd4 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
   10d1c:	2206      	movs	r2, #6
   10d1e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   10d22:	e00d      	b.n	10d40 <cbvprintf+0x270>
		if (*++sp == 'h') {
   10d24:	785a      	ldrb	r2, [r3, #1]
   10d26:	2a68      	cmp	r2, #104	; 0x68
   10d28:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   10d2c:	d106      	bne.n	10d3c <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
   10d2e:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   10d30:	f361 02c6 	bfi	r2, r1, #3, #4
   10d34:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
   10d38:	1c9f      	adds	r7, r3, #2
   10d3a:	e7cc      	b.n	10cd6 <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
   10d3c:	4613      	mov	r3, r2
   10d3e:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
   10d40:	f362 03c6 	bfi	r3, r2, #3, #4
   10d44:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
   10d48:	e7c5      	b.n	10cd6 <cbvprintf+0x206>
		if (*++sp == 'l') {
   10d4a:	785a      	ldrb	r2, [r3, #1]
   10d4c:	2a6c      	cmp	r2, #108	; 0x6c
   10d4e:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   10d52:	d101      	bne.n	10d58 <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
   10d54:	2104      	movs	r1, #4
   10d56:	e7eb      	b.n	10d30 <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
   10d58:	4613      	mov	r3, r2
   10d5a:	2203      	movs	r2, #3
   10d5c:	e7f0      	b.n	10d40 <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
   10d5e:	2205      	movs	r2, #5
   10d60:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   10d64:	e7ec      	b.n	10d40 <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
   10d66:	2207      	movs	r2, #7
   10d68:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   10d6c:	e7e8      	b.n	10d40 <cbvprintf+0x270>
		conv->unsupported = true;
   10d6e:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   10d72:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
   10d76:	f023 0302 	bic.w	r3, r3, #2
   10d7a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   10d7e:	f043 0302 	orr.w	r3, r3, #2
   10d82:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
   10d86:	e7a6      	b.n	10cd6 <cbvprintf+0x206>
   10d88:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
   10d8c:	2920      	cmp	r1, #32
   10d8e:	f200 8084 	bhi.w	10e9a <cbvprintf+0x3ca>
   10d92:	a001      	add	r0, pc, #4	; (adr r0, 10d98 <cbvprintf+0x2c8>)
   10d94:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
   10d98:	00010e5d 	.word	0x00010e5d
   10d9c:	00010e9b 	.word	0x00010e9b
   10da0:	00010e9b 	.word	0x00010e9b
   10da4:	00010e9b 	.word	0x00010e9b
   10da8:	00010e9b 	.word	0x00010e9b
   10dac:	00010e9b 	.word	0x00010e9b
   10db0:	00010e9b 	.word	0x00010e9b
   10db4:	00010e9b 	.word	0x00010e9b
   10db8:	00010e9b 	.word	0x00010e9b
   10dbc:	00010cf9 	.word	0x00010cf9
   10dc0:	00010e9b 	.word	0x00010e9b
   10dc4:	00010e5d 	.word	0x00010e5d
   10dc8:	00010e1d 	.word	0x00010e1d
   10dcc:	00010cf9 	.word	0x00010cf9
   10dd0:	00010cf9 	.word	0x00010cf9
   10dd4:	00010cf9 	.word	0x00010cf9
   10dd8:	00010e9b 	.word	0x00010e9b
   10ddc:	00010e1d 	.word	0x00010e1d
   10de0:	00010e9b 	.word	0x00010e9b
   10de4:	00010e9b 	.word	0x00010e9b
   10de8:	00010e9b 	.word	0x00010e9b
   10dec:	00010e9b 	.word	0x00010e9b
   10df0:	00010e65 	.word	0x00010e65
   10df4:	00010e5d 	.word	0x00010e5d
   10df8:	00010e81 	.word	0x00010e81
   10dfc:	00010e9b 	.word	0x00010e9b
   10e00:	00010e9b 	.word	0x00010e9b
   10e04:	00010e81 	.word	0x00010e81
   10e08:	00010e9b 	.word	0x00010e9b
   10e0c:	00010e5d 	.word	0x00010e5d
   10e10:	00010e9b 	.word	0x00010e9b
   10e14:	00010e9b 	.word	0x00010e9b
   10e18:	00010e5d 	.word	0x00010e5d
		conv->specifier_cat = SPECIFIER_SINT;
   10e1c:	2001      	movs	r0, #1
   10e1e:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   10e22:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   10e26:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   10e2a:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   10e2c:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
   10e30:	bf02      	ittt	eq
   10e32:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
   10e36:	f041 0101 	orreq.w	r1, r1, #1
   10e3a:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
   10e3e:	2a63      	cmp	r2, #99	; 0x63
   10e40:	d131      	bne.n	10ea6 <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
   10e42:	3b00      	subs	r3, #0
   10e44:	bf18      	it	ne
   10e46:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
   10e48:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   10e4c:	f3c2 0140 	ubfx	r1, r2, #1, #1
   10e50:	430b      	orrs	r3, r1
   10e52:	f363 0241 	bfi	r2, r3, #1, #1
   10e56:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
   10e5a:	e6d8      	b.n	10c0e <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
   10e5c:	2002      	movs	r0, #2
   10e5e:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
   10e62:	e7de      	b.n	10e22 <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
   10e64:	2103      	movs	r1, #3
   10e66:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   10e6a:	f003 0378 	and.w	r3, r3, #120	; 0x78
   10e6e:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
   10e72:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   10e76:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
   10e78:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
   10e7c:	4143      	adcs	r3, r0
   10e7e:	e7e3      	b.n	10e48 <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
   10e80:	2103      	movs	r1, #3
   10e82:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   10e86:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   10e8a:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
   10e8e:	bf14      	ite	ne
   10e90:	2301      	movne	r3, #1
   10e92:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
   10e94:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
   10e98:	e7d6      	b.n	10e48 <cbvprintf+0x378>
		conv->invalid = true;
   10e9a:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   10e9e:	f043 0301 	orr.w	r3, r3, #1
   10ea2:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
   10ea6:	2300      	movs	r3, #0
   10ea8:	e7ce      	b.n	10e48 <cbvprintf+0x378>
		} else if (conv->width_present) {
   10eaa:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
   10eae:	2a00      	cmp	r2, #0
		int width = -1;
   10eb0:	bfac      	ite	ge
   10eb2:	f04f 39ff 	movge.w	r9, #4294967295
			width = conv->width_value;
   10eb6:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
   10eba:	e6ba      	b.n	10c32 <cbvprintf+0x162>
		} else if (conv->prec_present) {
   10ebc:	079b      	lsls	r3, r3, #30
   10ebe:	f57f aec7 	bpl.w	10c50 <cbvprintf+0x180>
			precision = conv->prec_value;
   10ec2:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
   10ec6:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   10ec8:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
   10ecc:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
   10ed0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
   10ed4:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   10ed8:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   10eda:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   10ede:	d136      	bne.n	10f4e <cbvprintf+0x47e>
			switch (length_mod) {
   10ee0:	1ed3      	subs	r3, r2, #3
   10ee2:	2b04      	cmp	r3, #4
   10ee4:	d820      	bhi.n	10f28 <cbvprintf+0x458>
   10ee6:	e8df f003 	tbb	[pc, r3]
   10eea:	0703      	.short	0x0703
   10eec:	1f07      	.short	0x1f07
   10eee:	1f          	.byte	0x1f
   10eef:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
   10ef0:	f854 0b04 	ldr.w	r0, [r4], #4
				value->sint = (short)value->sint;
   10ef4:	17c1      	asrs	r1, r0, #31
   10ef6:	e004      	b.n	10f02 <cbvprintf+0x432>
					(sint_value_type)va_arg(ap, intmax_t);
   10ef8:	3407      	adds	r4, #7
   10efa:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
   10efe:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->sint = (short)value->sint;
   10f02:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
   10f06:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   10f0a:	f013 0603 	ands.w	r6, r3, #3
   10f0e:	d054      	beq.n	10fba <cbvprintf+0x4ea>
			OUTS(sp, fp);
   10f10:	463b      	mov	r3, r7
   10f12:	4652      	mov	r2, sl
   10f14:	4659      	mov	r1, fp
   10f16:	9802      	ldr	r0, [sp, #8]
   10f18:	f005 fa87 	bl	1642a <outs>
   10f1c:	2800      	cmp	r0, #0
   10f1e:	f2c0 8143 	blt.w	111a8 <cbvprintf+0x6d8>
   10f22:	4405      	add	r5, r0
			continue;
   10f24:	46ba      	mov	sl, r7
   10f26:	e5db      	b.n	10ae0 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   10f28:	f854 0b04 	ldr.w	r0, [r4], #4
			if (length_mod == LENGTH_HH) {
   10f2c:	2a01      	cmp	r2, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
   10f2e:	ea4f 71e0 	mov.w	r1, r0, asr #31
   10f32:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
   10f36:	d105      	bne.n	10f44 <cbvprintf+0x474>
				value->uint = (unsigned char)value->uint;
   10f38:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
   10f3c:	930a      	str	r3, [sp, #40]	; 0x28
   10f3e:	2300      	movs	r3, #0
   10f40:	930b      	str	r3, [sp, #44]	; 0x2c
   10f42:	e7e0      	b.n	10f06 <cbvprintf+0x436>
			} else if (length_mod == LENGTH_H) {
   10f44:	2a02      	cmp	r2, #2
   10f46:	d1de      	bne.n	10f06 <cbvprintf+0x436>
				value->sint = (short)value->sint;
   10f48:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
   10f4c:	e7d2      	b.n	10ef4 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
   10f4e:	2b02      	cmp	r3, #2
   10f50:	d123      	bne.n	10f9a <cbvprintf+0x4ca>
			switch (length_mod) {
   10f52:	1ed3      	subs	r3, r2, #3
   10f54:	2b04      	cmp	r3, #4
   10f56:	d813      	bhi.n	10f80 <cbvprintf+0x4b0>
   10f58:	e8df f003 	tbb	[pc, r3]
   10f5c:	120a0a03 	.word	0x120a0a03
   10f60:	12          	.byte	0x12
   10f61:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
   10f62:	2100      	movs	r1, #0
					value->uint = (wchar_t)va_arg(ap,
   10f64:	6820      	ldr	r0, [r4, #0]
   10f66:	1d23      	adds	r3, r4, #4
   10f68:	900a      	str	r0, [sp, #40]	; 0x28
   10f6a:	910b      	str	r1, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
   10f6c:	461c      	mov	r4, r3
   10f6e:	e7ca      	b.n	10f06 <cbvprintf+0x436>
					(uint_value_type)va_arg(ap,
   10f70:	3407      	adds	r4, #7
   10f72:	f024 0307 	bic.w	r3, r4, #7
				value->uint =
   10f76:	e8f3 0102 	ldrd	r0, r1, [r3], #8
   10f7a:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
				break;
   10f7e:	e7f5      	b.n	10f6c <cbvprintf+0x49c>
					(uint_value_type)va_arg(ap, size_t);
   10f80:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   10f84:	2a01      	cmp	r2, #1
					(uint_value_type)va_arg(ap, size_t);
   10f86:	930a      	str	r3, [sp, #40]	; 0x28
   10f88:	f04f 0300 	mov.w	r3, #0
   10f8c:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
   10f8e:	d0d3      	beq.n	10f38 <cbvprintf+0x468>
			} else if (length_mod == LENGTH_H) {
   10f90:	2a02      	cmp	r2, #2
   10f92:	d1b8      	bne.n	10f06 <cbvprintf+0x436>
				value->uint = (unsigned short)value->uint;
   10f94:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   10f98:	e7d0      	b.n	10f3c <cbvprintf+0x46c>
		} else if (specifier_cat == SPECIFIER_FP) {
   10f9a:	2b04      	cmp	r3, #4
   10f9c:	d107      	bne.n	10fae <cbvprintf+0x4de>
			if (length_mod == LENGTH_UPPER_L) {
   10f9e:	3407      	adds	r4, #7
   10fa0:	f024 0407 	bic.w	r4, r4, #7
   10fa4:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->ldbl = va_arg(ap, long double);
   10fa8:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   10fac:	e7ab      	b.n	10f06 <cbvprintf+0x436>
		} else if (specifier_cat == SPECIFIER_PTR) {
   10fae:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
   10fb0:	bf04      	itt	eq
   10fb2:	f854 3b04 	ldreq.w	r3, [r4], #4
   10fb6:	930a      	streq	r3, [sp, #40]	; 0x28
   10fb8:	e7a5      	b.n	10f06 <cbvprintf+0x436>
		switch (conv->specifier) {
   10fba:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   10fbe:	2878      	cmp	r0, #120	; 0x78
   10fc0:	d8b0      	bhi.n	10f24 <cbvprintf+0x454>
   10fc2:	2862      	cmp	r0, #98	; 0x62
   10fc4:	d822      	bhi.n	1100c <cbvprintf+0x53c>
   10fc6:	2825      	cmp	r0, #37	; 0x25
   10fc8:	f43f ad93 	beq.w	10af2 <cbvprintf+0x22>
   10fcc:	2858      	cmp	r0, #88	; 0x58
   10fce:	d1a9      	bne.n	10f24 <cbvprintf+0x454>
			bps = encode_uint(value->uint, conv, buf, bpe);
   10fd0:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   10fd4:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   10fd8:	9300      	str	r3, [sp, #0]
   10fda:	aa0c      	add	r2, sp, #48	; 0x30
   10fdc:	ab04      	add	r3, sp, #16
   10fde:	f005 f9d9 	bl	16394 <encode_uint>
   10fe2:	4682      	mov	sl, r0
			if (precision >= 0) {
   10fe4:	f1b8 0f00 	cmp.w	r8, #0
   10fe8:	f10d 0026 	add.w	r0, sp, #38	; 0x26
   10fec:	db0c      	blt.n	11008 <cbvprintf+0x538>
				conv->flag_zero = false;
   10fee:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
   10ff2:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
   10ff6:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   10ffa:	4598      	cmp	r8, r3
				conv->flag_zero = false;
   10ffc:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
   11000:	d902      	bls.n	11008 <cbvprintf+0x538>
					conv->pad0_value = precision - (int)len;
   11002:	eba8 0303 	sub.w	r3, r8, r3
   11006:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
   11008:	4680      	mov	r8, r0
   1100a:	e03d      	b.n	11088 <cbvprintf+0x5b8>
   1100c:	3863      	subs	r0, #99	; 0x63
   1100e:	2815      	cmp	r0, #21
   11010:	d888      	bhi.n	10f24 <cbvprintf+0x454>
   11012:	a101      	add	r1, pc, #4	; (adr r1, 11018 <cbvprintf+0x548>)
   11014:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
   11018:	00011099 	.word	0x00011099
   1101c:	000110fd 	.word	0x000110fd
   11020:	00010f25 	.word	0x00010f25
   11024:	00010f25 	.word	0x00010f25
   11028:	00010f25 	.word	0x00010f25
   1102c:	00010f25 	.word	0x00010f25
   11030:	000110fd 	.word	0x000110fd
   11034:	00010f25 	.word	0x00010f25
   11038:	00010f25 	.word	0x00010f25
   1103c:	00010f25 	.word	0x00010f25
   11040:	00010f25 	.word	0x00010f25
   11044:	0001115b 	.word	0x0001115b
   11048:	00011129 	.word	0x00011129
   1104c:	0001112d 	.word	0x0001112d
   11050:	00010f25 	.word	0x00010f25
   11054:	00010f25 	.word	0x00010f25
   11058:	00011071 	.word	0x00011071
   1105c:	00010f25 	.word	0x00010f25
   11060:	00011129 	.word	0x00011129
   11064:	00010f25 	.word	0x00010f25
   11068:	00010f25 	.word	0x00010f25
   1106c:	00011129 	.word	0x00011129
			if (precision >= 0) {
   11070:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
   11074:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
   11078:	db0a      	blt.n	11090 <cbvprintf+0x5c0>
				len = strnlen(bps, precision);
   1107a:	4641      	mov	r1, r8
   1107c:	4650      	mov	r0, sl
   1107e:	f005 fa5e 	bl	1653e <strnlen>
		char sign = 0;
   11082:	2600      	movs	r6, #0
			bpe = bps + len;
   11084:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
   11088:	f1ba 0f00 	cmp.w	sl, #0
   1108c:	d10c      	bne.n	110a8 <cbvprintf+0x5d8>
   1108e:	e749      	b.n	10f24 <cbvprintf+0x454>
				len = strlen(bps);
   11090:	4650      	mov	r0, sl
   11092:	f005 fa4d 	bl	16530 <strlen>
   11096:	e7f4      	b.n	11082 <cbvprintf+0x5b2>
			break;
   11098:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1109a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bpe = buf + 1;
   1109c:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   110a0:	f88d 3010 	strb.w	r3, [sp, #16]
			bps = buf;
   110a4:	f10d 0a10 	add.w	sl, sp, #16
		size_t nj_len = (bpe - bps);
   110a8:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
   110ac:	b106      	cbz	r6, 110b0 <cbvprintf+0x5e0>
			nj_len += 1U;
   110ae:	3301      	adds	r3, #1
		if (conv->altform_0c) {
   110b0:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   110b4:	06d0      	lsls	r0, r2, #27
   110b6:	d56b      	bpl.n	11190 <cbvprintf+0x6c0>
			nj_len += 2U;
   110b8:	3302      	adds	r3, #2
		if (conv->pad_fp) {
   110ba:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
   110bc:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
   110be:	bf48      	it	mi
   110c0:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
   110c2:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
   110c4:	bf48      	it	mi
   110c6:	189b      	addmi	r3, r3, r2
		if (width > 0) {
   110c8:	f1b9 0f00 	cmp.w	r9, #0
   110cc:	dd79      	ble.n	111c2 <cbvprintf+0x6f2>
			if (!conv->flag_dash) {
   110ce:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
   110d2:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
   110d6:	f3c2 0380 	ubfx	r3, r2, #2, #1
   110da:	9303      	str	r3, [sp, #12]
   110dc:	0753      	lsls	r3, r2, #29
   110de:	d470      	bmi.n	111c2 <cbvprintf+0x6f2>
				if (conv->flag_zero) {
   110e0:	0650      	lsls	r0, r2, #25
   110e2:	d564      	bpl.n	111ae <cbvprintf+0x6de>
					if (sign != 0) {
   110e4:	b146      	cbz	r6, 110f8 <cbvprintf+0x628>
						OUTC(sign);
   110e6:	4659      	mov	r1, fp
   110e8:	4630      	mov	r0, r6
   110ea:	9b02      	ldr	r3, [sp, #8]
   110ec:	4798      	blx	r3
   110ee:	2800      	cmp	r0, #0
   110f0:	db5a      	blt.n	111a8 <cbvprintf+0x6d8>
						sign = 0;
   110f2:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
   110f4:	3501      	adds	r5, #1
						sign = 0;
   110f6:	461e      	mov	r6, r3
					pad = '0';
   110f8:	2330      	movs	r3, #48	; 0x30
   110fa:	e059      	b.n	111b0 <cbvprintf+0x6e0>
			if (conv->flag_plus) {
   110fc:	071e      	lsls	r6, r3, #28
   110fe:	d411      	bmi.n	11124 <cbvprintf+0x654>
				sign = ' ';
   11100:	f013 0610 	ands.w	r6, r3, #16
   11104:	bf18      	it	ne
   11106:	2620      	movne	r6, #32
			sint = value->sint;
   11108:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
			if (sint < 0) {
   1110c:	2a00      	cmp	r2, #0
   1110e:	f173 0100 	sbcs.w	r1, r3, #0
   11112:	f6bf af5d 	bge.w	10fd0 <cbvprintf+0x500>
				value->uint = (uint_value_type)-sint;
   11116:	4252      	negs	r2, r2
   11118:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   1111c:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   1111e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   11122:	e755      	b.n	10fd0 <cbvprintf+0x500>
				sign = '+';
   11124:	262b      	movs	r6, #43	; 0x2b
   11126:	e7ef      	b.n	11108 <cbvprintf+0x638>
		switch (conv->specifier) {
   11128:	2600      	movs	r6, #0
   1112a:	e751      	b.n	10fd0 <cbvprintf+0x500>
			if (value->ptr != NULL) {
   1112c:	980a      	ldr	r0, [sp, #40]	; 0x28
   1112e:	b348      	cbz	r0, 11184 <cbvprintf+0x6b4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   11130:	f10d 0326 	add.w	r3, sp, #38	; 0x26
   11134:	9300      	str	r3, [sp, #0]
   11136:	2100      	movs	r1, #0
   11138:	ab04      	add	r3, sp, #16
   1113a:	aa0c      	add	r2, sp, #48	; 0x30
   1113c:	f005 f92a 	bl	16394 <encode_uint>
				conv->altform_0c = true;
   11140:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
   11144:	4682      	mov	sl, r0
				conv->altform_0c = true;
   11146:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   1114a:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   1114e:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
   11152:	2600      	movs	r6, #0
				conv->altform_0c = true;
   11154:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
   11158:	e744      	b.n	10fe4 <cbvprintf+0x514>
				store_count(conv, value->ptr, count);
   1115a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
   1115c:	2a07      	cmp	r2, #7
   1115e:	f63f aee1 	bhi.w	10f24 <cbvprintf+0x454>
   11162:	e8df f002 	tbb	[pc, r2]
   11166:	040d      	.short	0x040d
   11168:	08080d06 	.word	0x08080d06
   1116c:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
   1116e:	701d      	strb	r5, [r3, #0]
		break;
   11170:	e6d8      	b.n	10f24 <cbvprintf+0x454>
		*(short *)dp = (short)count;
   11172:	801d      	strh	r5, [r3, #0]
		break;
   11174:	e6d6      	b.n	10f24 <cbvprintf+0x454>
		*(intmax_t *)dp = (intmax_t)count;
   11176:	4628      	mov	r0, r5
   11178:	17e9      	asrs	r1, r5, #31
   1117a:	e9c3 0100 	strd	r0, r1, [r3]
		break;
   1117e:	e6d1      	b.n	10f24 <cbvprintf+0x454>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   11180:	601d      	str	r5, [r3, #0]
		break;
   11182:	e6cf      	b.n	10f24 <cbvprintf+0x454>
			bpe = bps + 5;
   11184:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 1124c <cbvprintf+0x77c>
   11188:	4606      	mov	r6, r0
			bps = "(nil)";
   1118a:	f1a8 0a05 	sub.w	sl, r8, #5
   1118e:	e78b      	b.n	110a8 <cbvprintf+0x5d8>
		} else if (conv->altform_0) {
   11190:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
   11192:	bf48      	it	mi
   11194:	3301      	addmi	r3, #1
   11196:	e790      	b.n	110ba <cbvprintf+0x5ea>
					OUTC(pad);
   11198:	4618      	mov	r0, r3
   1119a:	9303      	str	r3, [sp, #12]
   1119c:	4659      	mov	r1, fp
   1119e:	9b02      	ldr	r3, [sp, #8]
   111a0:	4798      	blx	r3
   111a2:	2800      	cmp	r0, #0
   111a4:	9b03      	ldr	r3, [sp, #12]
   111a6:	da04      	bge.n	111b2 <cbvprintf+0x6e2>
#undef OUTS
#undef OUTC
}
   111a8:	b011      	add	sp, #68	; 0x44
   111aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   111ae:	2320      	movs	r3, #32
   111b0:	444d      	add	r5, r9
   111b2:	464a      	mov	r2, r9
				while (width-- > 0) {
   111b4:	2a00      	cmp	r2, #0
   111b6:	eba5 0109 	sub.w	r1, r5, r9
   111ba:	f109 39ff 	add.w	r9, r9, #4294967295
   111be:	dceb      	bgt.n	11198 <cbvprintf+0x6c8>
   111c0:	460d      	mov	r5, r1
		if (sign != 0) {
   111c2:	b136      	cbz	r6, 111d2 <cbvprintf+0x702>
			OUTC(sign);
   111c4:	4659      	mov	r1, fp
   111c6:	4630      	mov	r0, r6
   111c8:	9b02      	ldr	r3, [sp, #8]
   111ca:	4798      	blx	r3
   111cc:	2800      	cmp	r0, #0
   111ce:	dbeb      	blt.n	111a8 <cbvprintf+0x6d8>
   111d0:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   111d2:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   111d6:	06d9      	lsls	r1, r3, #27
   111d8:	d401      	bmi.n	111de <cbvprintf+0x70e>
   111da:	071a      	lsls	r2, r3, #28
   111dc:	d506      	bpl.n	111ec <cbvprintf+0x71c>
				OUTC('0');
   111de:	4659      	mov	r1, fp
   111e0:	2030      	movs	r0, #48	; 0x30
   111e2:	9b02      	ldr	r3, [sp, #8]
   111e4:	4798      	blx	r3
   111e6:	2800      	cmp	r0, #0
   111e8:	dbde      	blt.n	111a8 <cbvprintf+0x6d8>
   111ea:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   111ec:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   111f0:	06db      	lsls	r3, r3, #27
   111f2:	d507      	bpl.n	11204 <cbvprintf+0x734>
				OUTC(conv->specifier);
   111f4:	4659      	mov	r1, fp
   111f6:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
   111fa:	9b02      	ldr	r3, [sp, #8]
   111fc:	4798      	blx	r3
   111fe:	2800      	cmp	r0, #0
   11200:	dbd2      	blt.n	111a8 <cbvprintf+0x6d8>
   11202:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   11204:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   11206:	442e      	add	r6, r5
   11208:	1b73      	subs	r3, r6, r5
   1120a:	2b00      	cmp	r3, #0
   1120c:	dc16      	bgt.n	1123c <cbvprintf+0x76c>
			OUTS(bps, bpe);
   1120e:	4643      	mov	r3, r8
   11210:	4652      	mov	r2, sl
   11212:	4659      	mov	r1, fp
   11214:	9802      	ldr	r0, [sp, #8]
   11216:	f005 f908 	bl	1642a <outs>
   1121a:	2800      	cmp	r0, #0
   1121c:	dbc4      	blt.n	111a8 <cbvprintf+0x6d8>
   1121e:	4405      	add	r5, r0
		while (width > 0) {
   11220:	44a9      	add	r9, r5
   11222:	eba9 0305 	sub.w	r3, r9, r5
   11226:	2b00      	cmp	r3, #0
   11228:	f77f ae7c 	ble.w	10f24 <cbvprintf+0x454>
			OUTC(' ');
   1122c:	4659      	mov	r1, fp
   1122e:	2020      	movs	r0, #32
   11230:	9b02      	ldr	r3, [sp, #8]
   11232:	4798      	blx	r3
   11234:	2800      	cmp	r0, #0
   11236:	dbb7      	blt.n	111a8 <cbvprintf+0x6d8>
   11238:	3501      	adds	r5, #1
			--width;
   1123a:	e7f2      	b.n	11222 <cbvprintf+0x752>
				OUTC('0');
   1123c:	4659      	mov	r1, fp
   1123e:	2030      	movs	r0, #48	; 0x30
   11240:	9b02      	ldr	r3, [sp, #8]
   11242:	4798      	blx	r3
   11244:	2800      	cmp	r0, #0
   11246:	dbaf      	blt.n	111a8 <cbvprintf+0x6d8>
   11248:	3501      	adds	r5, #1
   1124a:	e7dd      	b.n	11208 <cbvprintf+0x738>
   1124c:	000174f7 	.word	0x000174f7

00011250 <nordicsemi_nrf91_init>:
   11250:	f04f 0220 	mov.w	r2, #32
   11254:	f3ef 8311 	mrs	r3, BASEPRI
   11258:	f382 8812 	msr	BASEPRI_MAX, r2
   1125c:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   11260:	2101      	movs	r1, #1
   11262:	4a04      	ldr	r2, [pc, #16]	; (11274 <nordicsemi_nrf91_init+0x24>)
   11264:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   11268:	f383 8811 	msr	BASEPRI, r3
   1126c:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   11270:	2000      	movs	r0, #0
   11272:	4770      	bx	lr
   11274:	40039000 	.word	0x40039000

00011278 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   11278:	b120      	cbz	r0, 11284 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   1127a:	4b03      	ldr	r3, [pc, #12]	; (11288 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   1127c:	0180      	lsls	r0, r0, #6
   1127e:	f043 0301 	orr.w	r3, r3, #1
   11282:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   11284:	4770      	bx	lr
   11286:	bf00      	nop
   11288:	00017290 	.word	0x00017290

0001128c <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   1128c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11290:	4605      	mov	r5, r0
	__asm__ volatile(
   11292:	f04f 0320 	mov.w	r3, #32
   11296:	f3ef 8611 	mrs	r6, BASEPRI
   1129a:	f383 8812 	msr	BASEPRI_MAX, r3
   1129e:	f3bf 8f6f 	isb	sy
	struct pm_notifier *notifier;
	k_spinlock_key_t pm_notifier_key;
	void (*callback)(enum pm_state state);

	pm_notifier_key = k_spin_lock(&pm_notifier_lock);
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   112a2:	4b10      	ldr	r3, [pc, #64]	; (112e4 <pm_state_notify+0x58>)
   112a4:	681c      	ldr	r4, [r3, #0]
   112a6:	2c00      	cmp	r4, #0
   112a8:	bf38      	it	cc
   112aa:	2400      	movcc	r4, #0
   112ac:	b19c      	cbz	r4, 112d6 <pm_state_notify+0x4a>
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_power_states[_current_cpu->id].state);
   112ae:	f04f 090c 	mov.w	r9, #12
   112b2:	4f0d      	ldr	r7, [pc, #52]	; (112e8 <pm_state_notify+0x5c>)
   112b4:	f8df 8034 	ldr.w	r8, [pc, #52]	; 112ec <pm_state_notify+0x60>
			callback = notifier->state_exit;
   112b8:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   112bc:	2d00      	cmp	r5, #0
   112be:	bf08      	it	eq
   112c0:	4613      	moveq	r3, r2
		if (callback) {
   112c2:	b12b      	cbz	r3, 112d0 <pm_state_notify+0x44>
			callback(z_power_states[_current_cpu->id].state);
   112c4:	f898 2014 	ldrb.w	r2, [r8, #20]
   112c8:	fb09 f202 	mul.w	r2, r9, r2
   112cc:	5cb8      	ldrb	r0, [r7, r2]
   112ce:	4798      	blx	r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   112d0:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   112d2:	2c00      	cmp	r4, #0
   112d4:	d1f0      	bne.n	112b8 <pm_state_notify+0x2c>
	__asm__ volatile(
   112d6:	f386 8811 	msr	BASEPRI, r6
   112da:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   112de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   112e2:	bf00      	nop
   112e4:	2000c81c 	.word	0x2000c81c
   112e8:	2000c828 	.word	0x2000c828
   112ec:	2000cc78 	.word	0x2000cc78

000112f0 <atomic_test_and_set_bit.constprop.0>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   112f0:	2201      	movs	r2, #1
   112f2:	f000 031f 	and.w	r3, r0, #31
   112f6:	409a      	lsls	r2, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   112f8:	4b08      	ldr	r3, [pc, #32]	; (1131c <atomic_test_and_set_bit.constprop.0+0x2c>)
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   112fa:	0940      	lsrs	r0, r0, #5
   112fc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   11300:	e8d0 3fef 	ldaex	r3, [r0]
   11304:	ea43 0102 	orr.w	r1, r3, r2
   11308:	e8c0 1fec 	stlex	ip, r1, [r0]
   1130c:	f1bc 0f00 	cmp.w	ip, #0
   11310:	d1f6      	bne.n	11300 <atomic_test_and_set_bit.constprop.0+0x10>

	return (old & mask) != 0;
   11312:	421a      	tst	r2, r3
}
   11314:	bf14      	ite	ne
   11316:	2001      	movne	r0, #1
   11318:	2000      	moveq	r0, #0
   1131a:	4770      	bx	lr
   1131c:	2000c834 	.word	0x2000c834

00011320 <pm_system_resume>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   11320:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   11322:	b530      	push	{r4, r5, lr}
	uint8_t id = _current_cpu->id;
   11324:	4b1a      	ldr	r3, [pc, #104]	; (11390 <pm_system_resume+0x70>)
{
   11326:	b085      	sub	sp, #20
	uint8_t id = _current_cpu->id;
   11328:	7d1d      	ldrb	r5, [r3, #20]
   1132a:	f005 031f 	and.w	r3, r5, #31
   1132e:	409a      	lsls	r2, r3
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   11330:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   11332:	4b18      	ldr	r3, [pc, #96]	; (11394 <pm_system_resume+0x74>)
   11334:	0969      	lsrs	r1, r5, #5
   11336:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1133a:	e8d3 1fef 	ldaex	r1, [r3]
   1133e:	ea01 0400 	and.w	r4, r1, r0
   11342:	e8c3 4fec 	stlex	ip, r4, [r3]
   11346:	f1bc 0f00 	cmp.w	ip, #0
   1134a:	d1f6      	bne.n	1133a <pm_system_resume+0x1a>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   1134c:	4211      	tst	r1, r2
   1134e:	d017      	beq.n	11380 <pm_system_resume+0x60>
		exit_pos_ops(z_power_states[id]);
   11350:	220c      	movs	r2, #12
   11352:	4c11      	ldr	r4, [pc, #68]	; (11398 <pm_system_resume+0x78>)
   11354:	ab01      	add	r3, sp, #4
   11356:	fb02 4205 	mla	r2, r2, r5, r4
   1135a:	ca07      	ldmia	r2, {r0, r1, r2}
   1135c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
   11360:	4a0e      	ldr	r2, [pc, #56]	; (1139c <pm_system_resume+0x7c>)
   11362:	b17a      	cbz	r2, 11384 <pm_system_resume+0x64>
		pm_power_state_exit_post_ops(info);
   11364:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   11368:	f005 f889 	bl	1647e <pm_power_state_exit_post_ops>
		pm_state_notify(false);
   1136c:	2000      	movs	r0, #0
   1136e:	f7ff ff8d 	bl	1128c <pm_state_notify>
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   11372:	230c      	movs	r3, #12
   11374:	2200      	movs	r2, #0
   11376:	436b      	muls	r3, r5
   11378:	18e1      	adds	r1, r4, r3
   1137a:	50e2      	str	r2, [r4, r3]
   1137c:	e9c1 2201 	strd	r2, r2, [r1, #4]
			0, 0};
	}
}
   11380:	b005      	add	sp, #20
   11382:	bd30      	pop	{r4, r5, pc}
   11384:	f382 8811 	msr	BASEPRI, r2
   11388:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   1138c:	e7ee      	b.n	1136c <pm_system_resume+0x4c>
   1138e:	bf00      	nop
   11390:	2000cc78 	.word	0x2000cc78
   11394:	2000c824 	.word	0x2000c824
   11398:	2000c828 	.word	0x2000c828
   1139c:	0001647f 	.word	0x0001647f

000113a0 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
   113a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = true;
	uint8_t id = _current_cpu->id;
   113a4:	4b33      	ldr	r3, [pc, #204]	; (11474 <pm_system_suspend+0xd4>)
{
   113a6:	4607      	mov	r7, r0
	uint8_t id = _current_cpu->id;
   113a8:	7d1c      	ldrb	r4, [r3, #20]
{
   113aa:	b088      	sub	sp, #32

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
   113ac:	4620      	mov	r0, r4
   113ae:	f7ff ff9f 	bl	112f0 <atomic_test_and_set_bit.constprop.0>
   113b2:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 1148c <pm_system_suspend+0xec>
   113b6:	b960      	cbnz	r0, 113d2 <pm_system_suspend+0x32>
		z_power_states[id] = pm_policy_next_state(id, ticks);
   113b8:	250c      	movs	r5, #12
   113ba:	466e      	mov	r6, sp
   113bc:	fb05 8504 	mla	r5, r5, r4, r8
   113c0:	463a      	mov	r2, r7
   113c2:	4621      	mov	r1, r4
   113c4:	4630      	mov	r0, r6
   113c6:	f005 f865 	bl	16494 <pm_policy_next_state>
   113ca:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   113ce:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
   113d2:	230c      	movs	r3, #12
   113d4:	4363      	muls	r3, r4
   113d6:	f818 0003 	ldrb.w	r0, [r8, r3]
   113da:	eb08 0203 	add.w	r2, r8, r3
   113de:	0965      	lsrs	r5, r4, #5
   113e0:	f004 061f 	and.w	r6, r4, #31
   113e4:	b3a8      	cbz	r0, 11452 <pm_system_suspend+0xb2>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
   113e6:	1c7b      	adds	r3, r7, #1
   113e8:	d00f      	beq.n	1140a <pm_system_suspend+0x6a>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
   113ea:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
   113ee:	2100      	movs	r1, #0
   113f0:	f8d2 e008 	ldr.w	lr, [r2, #8]
   113f4:	4820      	ldr	r0, [pc, #128]	; (11478 <pm_system_suspend+0xd8>)
   113f6:	2300      	movs	r3, #0
   113f8:	fbec 010e 	umlal	r0, r1, ip, lr
   113fc:	4a1f      	ldr	r2, [pc, #124]	; (1147c <pm_system_suspend+0xdc>)
   113fe:	f7fe ff1d 	bl	1023c <__aeabi_uldivmod>
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		z_set_timeout_expiry(ticks -
   11402:	2101      	movs	r1, #1
   11404:	1a38      	subs	r0, r7, r0
   11406:	f005 fd4a 	bl	16e9e <z_set_timeout_expiry>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   1140a:	f003 ffb9 	bl	15380 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   1140e:	2001      	movs	r0, #1
   11410:	f7ff ff3c 	bl	1128c <pm_state_notify>
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   11414:	2201      	movs	r2, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   11416:	4b1a      	ldr	r3, [pc, #104]	; (11480 <pm_system_suspend+0xe0>)
   11418:	40b2      	lsls	r2, r6
   1141a:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   1141e:	e8d3 1fef 	ldaex	r1, [r3]
   11422:	4311      	orrs	r1, r2
   11424:	e8c3 1fe0 	stlex	r0, r1, [r3]
   11428:	2800      	cmp	r0, #0
   1142a:	d1f8      	bne.n	1141e <pm_system_suspend+0x7e>
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
   1142c:	230c      	movs	r3, #12
   1142e:	fb03 8404 	mla	r4, r3, r4, r8
   11432:	ab05      	add	r3, sp, #20
   11434:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   11438:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
   1143c:	4a11      	ldr	r2, [pc, #68]	; (11484 <pm_system_suspend+0xe4>)
   1143e:	b11a      	cbz	r2, 11448 <pm_system_suspend+0xa8>
		pm_power_state_set(info);
   11440:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
   11444:	f005 f808 	bl	16458 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
   11448:	f7ff ff6a 	bl	11320 <pm_system_resume>
	k_sched_unlock();
   1144c:	f004 f972 	bl	15734 <k_sched_unlock>
	bool ret = true;
   11450:	2001      	movs	r0, #1
	atomic_val_t mask = ATOMIC_MASK(bit);
   11452:	2301      	movs	r3, #1
   11454:	40b3      	lsls	r3, r6
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   11456:	43db      	mvns	r3, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   11458:	4a0b      	ldr	r2, [pc, #44]	; (11488 <pm_system_suspend+0xe8>)
   1145a:	eb02 0585 	add.w	r5, r2, r5, lsl #2
   1145e:	e8d5 2fef 	ldaex	r2, [r5]
   11462:	401a      	ands	r2, r3
   11464:	e8c5 2fe1 	stlex	r1, r2, [r5]
   11468:	2900      	cmp	r1, #0
   1146a:	d1f8      	bne.n	1145e <pm_system_suspend+0xbe>
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
   1146c:	b008      	add	sp, #32
   1146e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11472:	bf00      	nop
   11474:	2000cc78 	.word	0x2000cc78
   11478:	000f423f 	.word	0x000f423f
   1147c:	000f4240 	.word	0x000f4240
   11480:	2000c824 	.word	0x2000c824
   11484:	00016459 	.word	0x00016459
   11488:	2000c834 	.word	0x2000c834
   1148c:	2000c828 	.word	0x2000c828

00011490 <before_nse>:
#include <arch/arm/aarch32/cortex_m/fpu.h>

static struct fpu_ctx_full context_buffer;

void before_nse(void)
{
   11490:	b508      	push	{r3, lr}
	k_sched_lock();
   11492:	f003 ff75 	bl	15380 <k_sched_lock>
	z_arm_save_fp_context(&context_buffer);
}
   11496:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_save_fp_context(&context_buffer);
   1149a:	4801      	ldr	r0, [pc, #4]	; (114a0 <before_nse+0x10>)
   1149c:	f005 b820 	b.w	164e0 <z_arm_save_fp_context>
   114a0:	2000c838 	.word	0x2000c838

000114a4 <after_nse>:

void after_nse(void)
{
   114a4:	b508      	push	{r3, lr}
	z_arm_restore_fp_context(&context_buffer);
   114a6:	4803      	ldr	r0, [pc, #12]	; (114b4 <after_nse+0x10>)
   114a8:	f005 f81b 	bl	164e2 <z_arm_restore_fp_context>
	k_sched_unlock();
}
   114ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	k_sched_unlock();
   114b0:	f004 b940 	b.w	15734 <k_sched_unlock>
   114b4:	2000c838 	.word	0x2000c838

000114b8 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   114b8:	4901      	ldr	r1, [pc, #4]	; (114c0 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   114ba:	2210      	movs	r2, #16
	str	r2, [r1]
   114bc:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   114be:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   114c0:	e000ed10 	.word	0xe000ed10

000114c4 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   114c4:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   114c6:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   114c8:	f380 8811 	msr	BASEPRI, r0
	isb
   114cc:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   114d0:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   114d4:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   114d6:	b662      	cpsie	i
	isb
   114d8:	f3bf 8f6f 	isb	sy

	bx	lr
   114dc:	4770      	bx	lr
   114de:	bf00      	nop

000114e0 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   114e0:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   114e2:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   114e4:	f381 8811 	msr	BASEPRI, r1

	wfe
   114e8:	bf20      	wfe

	msr	BASEPRI, r0
   114ea:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   114ee:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   114f0:	4770      	bx	lr
   114f2:	bf00      	nop

000114f4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   114f4:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   114f6:	2b00      	cmp	r3, #0
   114f8:	db08      	blt.n	1150c <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   114fa:	2201      	movs	r2, #1
   114fc:	f000 001f 	and.w	r0, r0, #31
   11500:	fa02 f000 	lsl.w	r0, r2, r0
   11504:	4a02      	ldr	r2, [pc, #8]	; (11510 <arch_irq_enable+0x1c>)
   11506:	095b      	lsrs	r3, r3, #5
   11508:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   1150c:	4770      	bx	lr
   1150e:	bf00      	nop
   11510:	e000e100 	.word	0xe000e100

00011514 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   11514:	4b05      	ldr	r3, [pc, #20]	; (1152c <arch_irq_is_enabled+0x18>)
   11516:	0942      	lsrs	r2, r0, #5
   11518:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   1151c:	2301      	movs	r3, #1
   1151e:	f000 001f 	and.w	r0, r0, #31
   11522:	fa03 f000 	lsl.w	r0, r3, r0
}
   11526:	4010      	ands	r0, r2
   11528:	4770      	bx	lr
   1152a:	bf00      	nop
   1152c:	e000e100 	.word	0xe000e100

00011530 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   11530:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   11532:	2b00      	cmp	r3, #0
		prio += _IRQ_PRIO_OFFSET;
   11534:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11538:	bfac      	ite	ge
   1153a:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1153e:	4b06      	ldrlt	r3, [pc, #24]	; (11558 <z_arm_irq_priority_set+0x28>)
   11540:	ea4f 1141 	mov.w	r1, r1, lsl #5
   11544:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11546:	bfab      	itete	ge
   11548:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1154c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11550:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11554:	5419      	strblt	r1, [r3, r0]
}
   11556:	4770      	bx	lr
   11558:	e000ed14 	.word	0xe000ed14

0001155c <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_PM
void _arch_isr_direct_pm(void)
{
   1155c:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   1155e:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   11560:	4b04      	ldr	r3, [pc, #16]	; (11574 <_arch_isr_direct_pm+0x18>)
   11562:	699a      	ldr	r2, [r3, #24]
   11564:	b11a      	cbz	r2, 1156e <_arch_isr_direct_pm+0x12>
		_kernel.idle = 0;
   11566:	2200      	movs	r2, #0
   11568:	619a      	str	r2, [r3, #24]
		z_pm_save_idle_exit();
   1156a:	f005 fb66 	bl	16c3a <z_pm_save_idle_exit>
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R) \
	|| defined(CONFIG_ARMV7_A)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   1156e:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   11570:	bd08      	pop	{r3, pc}
   11572:	bf00      	nop
   11574:	2000cc78 	.word	0x2000cc78

00011578 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   11578:	bf30      	wfi
    b z_SysNmiOnReset
   1157a:	f7ff bffd 	b.w	11578 <z_SysNmiOnReset>
   1157e:	bf00      	nop

00011580 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   11580:	4a0f      	ldr	r2, [pc, #60]	; (115c0 <z_arm_prep_c+0x40>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   11582:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   11584:	4b0f      	ldr	r3, [pc, #60]	; (115c4 <z_arm_prep_c+0x44>)
   11586:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1158a:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   1158c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   11590:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   11594:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   11598:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   1159c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 */
__STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, control" : "=r" (result) );
   115a0:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
   115a4:	f023 0304 	bic.w	r3, r3, #4
  \details Writes the given value to the Control Register.
  \param [in]    control  Control Register value to set
 */
__STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
{
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
   115a8:	f383 8814 	msr	CONTROL, r3
  __ASM volatile ("isb 0xF":::"memory");
   115ac:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   115b0:	f003 fc4c 	bl	14e4c <z_bss_zero>
	z_data_copy();
   115b4:	f004 f9e6 	bl	15984 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   115b8:	f000 f9ac 	bl	11914 <z_arm_interrupt_init>
	z_cstart();
   115bc:	f003 fc50 	bl	14e60 <z_cstart>
   115c0:	00010000 	.word	0x00010000
   115c4:	e000ed00 	.word	0xe000ed00

000115c8 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   115c8:	4a09      	ldr	r2, [pc, #36]	; (115f0 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   115ca:	490a      	ldr	r1, [pc, #40]	; (115f4 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   115cc:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   115ce:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   115d0:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   115d2:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   115d4:	4908      	ldr	r1, [pc, #32]	; (115f8 <arch_swap+0x30>)
   115d6:	684b      	ldr	r3, [r1, #4]
   115d8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   115dc:	604b      	str	r3, [r1, #4]
	__asm__ volatile(
   115de:	2300      	movs	r3, #0
   115e0:	f383 8811 	msr	BASEPRI, r3
   115e4:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   115e8:	6893      	ldr	r3, [r2, #8]
}
   115ea:	6f98      	ldr	r0, [r3, #120]	; 0x78
   115ec:	4770      	bx	lr
   115ee:	bf00      	nop
   115f0:	2000cc78 	.word	0x2000cc78
   115f4:	000173e8 	.word	0x000173e8
   115f8:	e000ed00 	.word	0xe000ed00

000115fc <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   115fc:	4913      	ldr	r1, [pc, #76]	; (1164c <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
   115fe:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   11600:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   11604:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   11606:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   1160a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1160e:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   11610:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   11614:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   11618:	4f0d      	ldr	r7, [pc, #52]	; (11650 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   1161a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   1161e:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
   11620:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   11622:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   11624:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   11626:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   11628:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   1162a:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   1162e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   11632:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   11636:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   1163a:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   1163e:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   11640:	f004 ff4a 	bl	164d8 <configure_builtin_stack_guard>
    pop {r2, lr}
   11644:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   11648:	4770      	bx	lr
   1164a:	0000      	.short	0x0000
    ldr r1, =_kernel
   1164c:	2000cc78 	.word	0x2000cc78
    ldr v4, =_SCS_ICSR
   11650:	e000ed04 	.word	0xe000ed04

00011654 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   11654:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   11658:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   1165a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   1165e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   11662:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   11664:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   11668:	2902      	cmp	r1, #2
    beq _oops
   1166a:	d0ff      	beq.n	1166c <_oops>

0001166c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   1166c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   1166e:	f004 ff24 	bl	164ba <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   11672:	bd01      	pop	{r0, pc}

00011674 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   11674:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   11678:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   1167a:	490b      	ldr	r1, [pc, #44]	; (116a8 <arch_new_thread+0x34>)
	iframe->a2 = (uint32_t)p1;
   1167c:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   11680:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   11682:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   11686:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   1168a:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   1168c:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   11690:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   11694:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   11698:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   1169c:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   1169e:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   116a0:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
   116a2:	6743      	str	r3, [r0, #116]	; 0x74
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   116a4:	4770      	bx	lr
   116a6:	bf00      	nop
   116a8:	00015ff7 	.word	0x00015ff7

000116ac <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   116ac:	4b08      	ldr	r3, [pc, #32]	; (116d0 <arch_switch_to_main_thread+0x24>)
   116ae:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   116b0:	6e43      	ldr	r3, [r0, #100]	; 0x64
   116b2:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   116b6:	4610      	mov	r0, r2
   116b8:	f381 8809 	msr	PSP, r1
   116bc:	2100      	movs	r1, #0
   116be:	b663      	cpsie	if
   116c0:	f381 8811 	msr	BASEPRI, r1
   116c4:	f3bf 8f6f 	isb	sy
   116c8:	2200      	movs	r2, #0
   116ca:	2300      	movs	r3, #0
   116cc:	f004 fc93 	bl	15ff6 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   116d0:	2000cc78 	.word	0x2000cc78

000116d4 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   116d4:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   116d6:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   116d8:	4a0b      	ldr	r2, [pc, #44]	; (11708 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   116da:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
   116dc:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   116de:	bf1e      	ittt	ne
	movne	r1, #0
   116e0:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   116e2:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
   116e4:	f005 faa9 	blne	16c3a <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   116e8:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   116ea:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   116ee:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   116f2:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   116f6:	4905      	ldr	r1, [pc, #20]	; (1170c <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   116f8:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   116fa:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   116fc:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   116fe:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   11702:	4903      	ldr	r1, [pc, #12]	; (11710 <_isr_wrapper+0x3c>)
	bx r1
   11704:	4708      	bx	r1
   11706:	0000      	.short	0x0000
	ldr r2, =_kernel
   11708:	2000cc78 	.word	0x2000cc78
	ldr r1, =_sw_isr_table
   1170c:	00017048 	.word	0x00017048
	ldr r1, =z_arm_int_exit
   11710:	00011715 	.word	0x00011715

00011714 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   11714:	4b04      	ldr	r3, [pc, #16]	; (11728 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   11716:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   11718:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
   1171a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   1171c:	d003      	beq.n	11726 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   1171e:	4903      	ldr	r1, [pc, #12]	; (1172c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   11720:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   11724:	600a      	str	r2, [r1, #0]

00011726 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   11726:	4770      	bx	lr
	ldr r3, =_kernel
   11728:	2000cc78 	.word	0x2000cc78
	ldr r1, =_SCS_ICSR
   1172c:	e000ed04 	.word	0xe000ed04

00011730 <mem_manage_fault.isra.0>:
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   11730:	4b0e      	ldr	r3, [pc, #56]	; (1176c <mem_manage_fault.isra.0+0x3c>)
   11732:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   11734:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   11736:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11738:	0792      	lsls	r2, r2, #30
   1173a:	d508      	bpl.n	1174e <mem_manage_fault.isra.0+0x1e>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
   1173c:	6b5a      	ldr	r2, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   1173e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11740:	0612      	lsls	r2, r2, #24
   11742:	d504      	bpl.n	1174e <mem_manage_fault.isra.0+0x1e>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault != 0) {
   11744:	b118      	cbz	r0, 1174e <mem_manage_fault.isra.0+0x1e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   11746:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11748:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   1174c:	629a      	str	r2, [r3, #40]	; 0x28

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
   1174e:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   11750:	4b06      	ldr	r3, [pc, #24]	; (1176c <mem_manage_fault.isra.0+0x3c>)
   11752:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   11754:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   11756:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11758:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   1175a:	bf58      	it	pl
   1175c:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   1175e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11760:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   11764:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   11766:	7008      	strb	r0, [r1, #0]

	return reason;
}
   11768:	4770      	bx	lr
   1176a:	bf00      	nop
   1176c:	e000ed00 	.word	0xe000ed00

00011770 <bus_fault.isra.0>:
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   11770:	4b0d      	ldr	r3, [pc, #52]	; (117a8 <bus_fault.isra.0+0x38>)
   11772:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   11774:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   11776:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11778:	0592      	lsls	r2, r2, #22
   1177a:	d508      	bpl.n	1178e <bus_fault.isra.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
   1177c:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   1177e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11780:	0412      	lsls	r2, r2, #16
   11782:	d504      	bpl.n	1178e <bus_fault.isra.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault != 0) {
   11784:	b118      	cbz	r0, 1178e <bus_fault.isra.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   11786:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11788:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   1178c:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf, true);
   1178e:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   11790:	4b05      	ldr	r3, [pc, #20]	; (117a8 <bus_fault.isra.0+0x38>)
   11792:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   11794:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   11796:	05d2      	lsls	r2, r2, #23
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   11798:	bf58      	it	pl
   1179a:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   1179c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1179e:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
   117a2:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   117a4:	7008      	strb	r0, [r1, #0]

	return reason;
}
   117a6:	4770      	bx	lr
   117a8:	e000ed00 	.word	0xe000ed00

000117ac <usage_fault.isra.0>:
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   117ac:	4b09      	ldr	r3, [pc, #36]	; (117d4 <usage_fault.isra.0+0x28>)
   117ae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   117b0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   117b2:	6a98      	ldr	r0, [r3, #40]	; 0x28
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   117b4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   117b6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   117b8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   117ba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   117bc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   117be:	f410 1080 	ands.w	r0, r0, #1048576	; 0x100000
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   117c2:	ea6f 4202 	mvn.w	r2, r2, lsl #16
   117c6:	ea6f 4212 	mvn.w	r2, r2, lsr #16

	return reason;
}
   117ca:	bf18      	it	ne
   117cc:	2002      	movne	r0, #2
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   117ce:	629a      	str	r2, [r3, #40]	; 0x28
}
   117d0:	4770      	bx	lr
   117d2:	bf00      	nop
   117d4:	e000ed00 	.word	0xe000ed00

000117d8 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   117d8:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   117da:	4b40      	ldr	r3, [pc, #256]	; (118dc <z_arm_fault+0x104>)
{
   117dc:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   117de:	685b      	ldr	r3, [r3, #4]
   117e0:	2600      	movs	r6, #0
{
   117e2:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   117e4:	f3c3 0308 	ubfx	r3, r3, #0, #9
   117e8:	f386 8811 	msr	BASEPRI, r6
   117ec:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   117f0:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
   117f4:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
   117f8:	d116      	bne.n	11828 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   117fa:	07d4      	lsls	r4, r2, #31
   117fc:	d414      	bmi.n	11828 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   117fe:	0650      	lsls	r0, r2, #25
   11800:	d403      	bmi.n	1180a <z_arm_fault+0x32>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   11802:	0712      	lsls	r2, r2, #28
   11804:	d404      	bmi.n	11810 <z_arm_fault+0x38>
			*nested_exc = true;
   11806:	2601      	movs	r6, #1
   11808:	e004      	b.n	11814 <z_arm_fault+0x3c>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   1180a:	f012 0604 	ands.w	r6, r2, #4
   1180e:	d001      	beq.n	11814 <z_arm_fault+0x3c>
			ptr_esf = (z_arch_esf_t *)psp;
   11810:	460d      	mov	r5, r1
	*nested_exc = false;
   11812:	2600      	movs	r6, #0
	*recoverable = false;
   11814:	2200      	movs	r2, #0
   11816:	3b03      	subs	r3, #3
   11818:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
   1181c:	2b03      	cmp	r3, #3
   1181e:	d856      	bhi.n	118ce <z_arm_fault+0xf6>
   11820:	e8df f003 	tbb	[pc, r3]
   11824:	4a514d04 	.word	0x4a514d04
		return NULL;
   11828:	4635      	mov	r5, r6
   1182a:	e7f3      	b.n	11814 <z_arm_fault+0x3c>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   1182c:	4b2b      	ldr	r3, [pc, #172]	; (118dc <z_arm_fault+0x104>)
   1182e:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   11830:	f014 0402 	ands.w	r4, r4, #2
   11834:	d14b      	bne.n	118ce <z_arm_fault+0xf6>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   11836:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   11838:	2a00      	cmp	r2, #0
   1183a:	db17      	blt.n	1186c <z_arm_fault+0x94>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   1183c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1183e:	005b      	lsls	r3, r3, #1
   11840:	d514      	bpl.n	1186c <z_arm_fault+0x94>
	uint16_t fault_insn = *(ret_addr - 1);
   11842:	69ab      	ldr	r3, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   11844:	f833 2c02 	ldrh.w	r2, [r3, #-2]
   11848:	f64d 7302 	movw	r3, #57090	; 0xdf02
   1184c:	429a      	cmp	r2, r3
   1184e:	d00c      	beq.n	1186a <z_arm_fault+0x92>
		} else if (SCB_MMFSR != 0) {
   11850:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   11854:	f603 6326 	addw	r3, r3, #3622	; 0xe26
   11858:	781b      	ldrb	r3, [r3, #0]
   1185a:	b1fb      	cbz	r3, 1189c <z_arm_fault+0xc4>
			reason = mem_manage_fault(esf, 1, recoverable);
   1185c:	2001      	movs	r0, #1
   1185e:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   11862:	f7ff ff65 	bl	11730 <mem_manage_fault.isra.0>
   11866:	4604      	mov	r4, r0
		break;
   11868:	e000      	b.n	1186c <z_arm_fault+0x94>
			reason = esf->basic.r0;
   1186a:	682c      	ldr	r4, [r5, #0]
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   1186c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11870:	b993      	cbnz	r3, 11898 <z_arm_fault+0xc0>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   11872:	2220      	movs	r2, #32
   11874:	4629      	mov	r1, r5
   11876:	a802      	add	r0, sp, #8
   11878:	f004 fe86 	bl	16588 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   1187c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1187e:	b346      	cbz	r6, 118d2 <z_arm_fault+0xfa>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   11880:	f3c3 0208 	ubfx	r2, r3, #0, #9
   11884:	b922      	cbnz	r2, 11890 <z_arm_fault+0xb8>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   11886:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   1188a:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1188e:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   11890:	4620      	mov	r0, r4
   11892:	a902      	add	r1, sp, #8
   11894:	f004 fe0f 	bl	164b6 <z_arm_fatal_error>
}
   11898:	b00a      	add	sp, #40	; 0x28
   1189a:	bd70      	pop	{r4, r5, r6, pc}
		} else if (SCB_BFSR != 0) {
   1189c:	4b10      	ldr	r3, [pc, #64]	; (118e0 <z_arm_fault+0x108>)
   1189e:	781b      	ldrb	r3, [r3, #0]
   118a0:	b12b      	cbz	r3, 118ae <z_arm_fault+0xd6>
			reason = bus_fault(esf, 1, recoverable);
   118a2:	2001      	movs	r0, #1
   118a4:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   118a8:	f7ff ff62 	bl	11770 <bus_fault.isra.0>
   118ac:	e7db      	b.n	11866 <z_arm_fault+0x8e>
		} else if (SCB_UFSR != 0) {
   118ae:	4b0d      	ldr	r3, [pc, #52]	; (118e4 <z_arm_fault+0x10c>)
   118b0:	881b      	ldrh	r3, [r3, #0]
   118b2:	b29b      	uxth	r3, r3
   118b4:	2b00      	cmp	r3, #0
   118b6:	d0d9      	beq.n	1186c <z_arm_fault+0x94>
		reason = usage_fault(esf);
   118b8:	f7ff ff78 	bl	117ac <usage_fault.isra.0>
   118bc:	e7d3      	b.n	11866 <z_arm_fault+0x8e>
		reason = mem_manage_fault(esf, 0, recoverable);
   118be:	2000      	movs	r0, #0
   118c0:	f10d 0107 	add.w	r1, sp, #7
   118c4:	e7cd      	b.n	11862 <z_arm_fault+0x8a>
		reason = bus_fault(esf, 0, recoverable);
   118c6:	2000      	movs	r0, #0
   118c8:	f10d 0107 	add.w	r1, sp, #7
   118cc:	e7ec      	b.n	118a8 <z_arm_fault+0xd0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
   118ce:	2400      	movs	r4, #0
   118d0:	e7cc      	b.n	1186c <z_arm_fault+0x94>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   118d2:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   118d6:	f023 0301 	bic.w	r3, r3, #1
   118da:	e7d8      	b.n	1188e <z_arm_fault+0xb6>
   118dc:	e000ed00 	.word	0xe000ed00
   118e0:	e000ed29 	.word	0xe000ed29
   118e4:	e000ed2a 	.word	0xe000ed2a

000118e8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   118e8:	4b04      	ldr	r3, [pc, #16]	; (118fc <z_arm_fault_init+0x14>)
   118ea:	695a      	ldr	r2, [r3, #20]
   118ec:	f042 0210 	orr.w	r2, r2, #16
   118f0:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   118f2:	695a      	ldr	r2, [r3, #20]
   118f4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   118f8:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   118fa:	4770      	bx	lr
   118fc:	e000ed00 	.word	0xe000ed00

00011900 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   11900:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   11904:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   11908:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   1190a:	4672      	mov	r2, lr
	bl z_arm_fault
   1190c:	f7ff ff64 	bl	117d8 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   11910:	bd01      	pop	{r0, pc}
   11912:	bf00      	nop

00011914 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   11914:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   11916:	2120      	movs	r1, #32
   11918:	4803      	ldr	r0, [pc, #12]	; (11928 <z_arm_interrupt_init+0x14>)
   1191a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   1191c:	3301      	adds	r3, #1
   1191e:	2b41      	cmp	r3, #65	; 0x41
   11920:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   11924:	d1f9      	bne.n	1191a <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   11926:	4770      	bx	lr
   11928:	e000e100 	.word	0xe000e100

0001192c <__start>:
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   1192c:	f005 fb2e 	bl	16f8c <z_arm_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   11930:	2020      	movs	r0, #32
    msr BASEPRI, r0
   11932:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   11936:	4808      	ldr	r0, [pc, #32]	; (11958 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   11938:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   1193c:	1840      	adds	r0, r0, r1
    msr PSP, r0
   1193e:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   11942:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   11946:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   11948:	4308      	orrs	r0, r1
    msr CONTROL, r0
   1194a:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   1194e:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   11952:	f7ff fe15 	bl	11580 <z_arm_prep_c>
   11956:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
   11958:	2000d738 	.word	0x2000d738

0001195c <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   1195c:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   11960:	4905      	ldr	r1, [pc, #20]	; (11978 <sys_arch_reboot+0x1c>)
   11962:	4b06      	ldr	r3, [pc, #24]	; (1197c <sys_arch_reboot+0x20>)
   11964:	68ca      	ldr	r2, [r1, #12]
   11966:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1196a:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   1196c:	60cb      	str	r3, [r1, #12]
   1196e:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   11972:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   11974:	e7fd      	b.n	11972 <sys_arch_reboot+0x16>
   11976:	bf00      	nop
   11978:	e000ed00 	.word	0xe000ed00
   1197c:	05fa0004 	.word	0x05fa0004

00011980 <z_impl_k_thread_abort>:
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   11980:	4b06      	ldr	r3, [pc, #24]	; (1199c <z_impl_k_thread_abort+0x1c>)
   11982:	689b      	ldr	r3, [r3, #8]
   11984:	4283      	cmp	r3, r0
   11986:	d107      	bne.n	11998 <z_impl_k_thread_abort+0x18>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   11988:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   1198c:	b123      	cbz	r3, 11998 <z_impl_k_thread_abort+0x18>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1198e:	4a04      	ldr	r2, [pc, #16]	; (119a0 <z_impl_k_thread_abort+0x20>)
   11990:	6853      	ldr	r3, [r2, #4]
   11992:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   11996:	6053      	str	r3, [r2, #4]
		}
	}

	z_thread_abort(thread);
   11998:	f003 bfa2 	b.w	158e0 <z_thread_abort>
   1199c:	2000cc78 	.word	0x2000cc78
   119a0:	e000ed00 	.word	0xe000ed00

000119a4 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   119a4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   119a6:	4c09      	ldr	r4, [pc, #36]	; (119cc <z_arm_configure_static_mpu_regions+0x28>)
   119a8:	4a09      	ldr	r2, [pc, #36]	; (119d0 <z_arm_configure_static_mpu_regions+0x2c>)
   119aa:	4623      	mov	r3, r4
   119ac:	2101      	movs	r1, #1
   119ae:	4809      	ldr	r0, [pc, #36]	; (119d4 <z_arm_configure_static_mpu_regions+0x30>)
   119b0:	f000 f8dc 	bl	11b6c <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   119b4:	2300      	movs	r3, #0
   119b6:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   119b8:	4b07      	ldr	r3, [pc, #28]	; (119d8 <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   119ba:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   119bc:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   119be:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   119c0:	9301      	str	r3, [sp, #4]
   119c2:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   119c4:	f000 f8dc 	bl	11b80 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   119c8:	b004      	add	sp, #16
   119ca:	bd10      	pop	{r4, pc}
   119cc:	20040000 	.word	0x20040000
   119d0:	2000c500 	.word	0x2000c500
   119d4:	000172a8 	.word	0x000172a8
   119d8:	2000c5b0 	.word	0x2000c5b0

000119dc <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   119dc:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   119de:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   119e0:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   119e2:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   119e6:	f004 031f 	and.w	r3, r4, #31
   119ea:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   119ec:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   119ee:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   119f0:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   119f4:	4904      	ldr	r1, [pc, #16]	; (11a08 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   119f6:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   119fa:	f043 0301 	orr.w	r3, r3, #1
   119fe:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   11a00:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   11a02:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   11a04:	bd10      	pop	{r4, pc}
   11a06:	bf00      	nop
   11a08:	e000ed90 	.word	0xe000ed90

00011a0c <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   11a0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11a10:	4688      	mov	r8, r1
   11a12:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   11a14:	4606      	mov	r6, r0
   11a16:	f04f 0900 	mov.w	r9, #0
	MPU->RNR = index;
   11a1a:	4d4a      	ldr	r5, [pc, #296]	; (11b44 <mpu_configure_regions_and_partition.constprop.0+0x138>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   11a1c:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   11a1e:	45c1      	cmp	r9, r8
   11a20:	da05      	bge.n	11a2e <mpu_configure_regions_and_partition.constprop.0+0x22>
		if (regions[i].size == 0U) {
   11a22:	6877      	ldr	r7, [r6, #4]
   11a24:	b3bf      	cbz	r7, 11a96 <mpu_configure_regions_and_partition.constprop.0+0x8a>
		&&
   11a26:	2f1f      	cmp	r7, #31
   11a28:	d805      	bhi.n	11a36 <mpu_configure_regions_and_partition.constprop.0+0x2a>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   11a2a:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   11a2e:	4620      	mov	r0, r4
   11a30:	b005      	add	sp, #20
   11a32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		&&
   11a36:	06fb      	lsls	r3, r7, #27
   11a38:	d1f7      	bne.n	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
		((part->start &
   11a3a:	f8d6 a000 	ldr.w	sl, [r6]
		&&
   11a3e:	f01a 0f1f 	tst.w	sl, #31
   11a42:	d1f2      	bne.n	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   11a44:	4650      	mov	r0, sl
   11a46:	f004 fd4d 	bl	164e4 <arm_cmse_mpu_region_get>
   11a4a:	4683      	mov	fp, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   11a4c:	eb07 000a 	add.w	r0, r7, sl
   11a50:	3801      	subs	r0, #1
   11a52:	f004 fd47 	bl	164e4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   11a56:	4583      	cmp	fp, r0
   11a58:	d1e7      	bne.n	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
		if ((u_reg_index == -EINVAL) ||
   11a5a:	f11b 0f16 	cmn.w	fp, #22
   11a5e:	d0e4      	beq.n	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
			(u_reg_index > (reg_index - 1))) {
   11a60:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   11a62:	455b      	cmp	r3, fp
   11a64:	dbe1      	blt.n	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
	MPU->RNR = index;
   11a66:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   11a6a:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
   11a6c:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   11a70:	692f      	ldr	r7, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   11a72:	f021 011f 	bic.w	r1, r1, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   11a76:	e9d6 3200 	ldrd	r3, r2, [r6]
   11a7a:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
   11a7c:	4299      	cmp	r1, r3
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   11a7e:	f047 071f 	orr.w	r7, r7, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   11a82:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i].start == u_reg_base) &&
   11a86:	d11c      	bne.n	11ac2 <mpu_configure_regions_and_partition.constprop.0+0xb6>
   11a88:	4557      	cmp	r7, sl
   11a8a:	d108      	bne.n	11a9e <mpu_configure_regions_and_partition.constprop.0+0x92>
			mpu_configure_region(u_reg_index, &regions[i]);
   11a8c:	4631      	mov	r1, r6
   11a8e:	fa5f f08b 	uxtb.w	r0, fp
   11a92:	f004 fd30 	bl	164f6 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   11a96:	f109 0901 	add.w	r9, r9, #1
   11a9a:	360c      	adds	r6, #12
   11a9c:	e7bf      	b.n	11a1e <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
   11a9e:	4631      	mov	r1, r6
	MPU->RNR = index;
   11aa0:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   11aa4:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   11aa6:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   11aaa:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   11aae:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   11ab0:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
   11ab2:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
   11ab4:	f004 fd1f 	bl	164f6 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   11ab8:	f110 0f16 	cmn.w	r0, #22
   11abc:	d0b5      	beq.n	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
			reg_index++;
   11abe:	1c44      	adds	r4, r0, #1
   11ac0:	e7e9      	b.n	11a96 <mpu_configure_regions_and_partition.constprop.0+0x8a>
		} else if (reg_last == u_reg_last) {
   11ac2:	3b01      	subs	r3, #1
   11ac4:	4557      	cmp	r7, sl
   11ac6:	b2e0      	uxtb	r0, r4
   11ac8:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
   11acc:	f8c5 b008 	str.w	fp, [r5, #8]
		} else if (reg_last == u_reg_last) {
   11ad0:	d106      	bne.n	11ae0 <mpu_configure_regions_and_partition.constprop.0+0xd4>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   11ad2:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   11ad4:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   11ad6:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   11ada:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   11adc:	612b      	str	r3, [r5, #16]
			reg_index =
   11ade:	e7e9      	b.n	11ab4 <mpu_configure_regions_and_partition.constprop.0+0xa8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   11ae0:	6929      	ldr	r1, [r5, #16]
   11ae2:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   11ae6:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   11ae8:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
   11aea:	4631      	mov	r1, r6
   11aec:	f004 fd03 	bl	164f6 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   11af0:	f110 0f16 	cmn.w	r0, #22
   11af4:	d099      	beq.n	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
	MPU->RNR = index;
   11af6:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
   11afa:	68ea      	ldr	r2, [r5, #12]
   11afc:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   11b00:	3f01      	subs	r7, #1
	attr->rbar = MPU->RBAR &
   11b02:	f362 0304 	bfi	r3, r2, #0, #5
   11b06:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   11b0a:	692b      	ldr	r3, [r5, #16]
   11b0c:	f89d 2008 	ldrb.w	r2, [sp, #8]
   11b10:	085b      	lsrs	r3, r3, #1
   11b12:	f363 1247 	bfi	r2, r3, #5, #3
   11b16:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   11b1a:	e9d6 3200 	ldrd	r3, r2, [r6]
   11b1e:	4413      	add	r3, r2
   11b20:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   11b22:	f023 031f 	bic.w	r3, r3, #31
   11b26:	443b      	add	r3, r7
			reg_index++;
   11b28:	1c44      	adds	r4, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   11b2a:	eba3 0a0a 	sub.w	sl, r3, sl
   11b2e:	b2e0      	uxtb	r0, r4
   11b30:	f02a 031f 	bic.w	r3, sl, #31

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   11b34:	280f      	cmp	r0, #15
			fill_region.attr.r_limit =
   11b36:	9303      	str	r3, [sp, #12]
   11b38:	f63f af77 	bhi.w	11a2a <mpu_configure_regions_and_partition.constprop.0+0x1e>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
   11b3c:	4669      	mov	r1, sp
   11b3e:	f7ff ff4d 	bl	119dc <region_init>
   11b42:	e7bc      	b.n	11abe <mpu_configure_regions_and_partition.constprop.0+0xb2>
   11b44:	e000ed90 	.word	0xe000ed90

00011b48 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   11b48:	2205      	movs	r2, #5
   11b4a:	4b03      	ldr	r3, [pc, #12]	; (11b58 <arm_core_mpu_enable+0x10>)
   11b4c:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
   11b4e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   11b52:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   11b56:	4770      	bx	lr
   11b58:	e000ed90 	.word	0xe000ed90

00011b5c <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   11b5c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   11b60:	2200      	movs	r2, #0
   11b62:	4b01      	ldr	r3, [pc, #4]	; (11b68 <arm_core_mpu_disable+0xc>)
   11b64:	605a      	str	r2, [r3, #4]
}
   11b66:	4770      	bx	lr
   11b68:	e000ed90 	.word	0xe000ed90

00011b6c <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   11b6c:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   11b6e:	4c03      	ldr	r4, [pc, #12]	; (11b7c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   11b70:	7822      	ldrb	r2, [r4, #0]
   11b72:	f7ff ff4b 	bl	11a0c <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   11b76:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   11b78:	bd10      	pop	{r4, pc}
   11b7a:	bf00      	nop
   11b7c:	2000ccbe 	.word	0x2000ccbe

00011b80 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   11b80:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11b84:	4d26      	ldr	r5, [pc, #152]	; (11c20 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
   11b86:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   11b88:	4606      	mov	r6, r0
   11b8a:	f04f 0800 	mov.w	r8, #0
   11b8e:	46ab      	mov	fp, r5
	MPU->RNR = index;
   11b90:	4f24      	ldr	r7, [pc, #144]	; (11c24 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   11b92:	45d0      	cmp	r8, sl
   11b94:	da1b      	bge.n	11bce <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   11b96:	f8d6 9004 	ldr.w	r9, [r6, #4]
   11b9a:	f1b9 0f00 	cmp.w	r9, #0
   11b9e:	d039      	beq.n	11c14 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   11ba0:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   11ba2:	4608      	mov	r0, r1
   11ba4:	9101      	str	r1, [sp, #4]
   11ba6:	f004 fc9d 	bl	164e4 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   11baa:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   11bac:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   11bae:	eb09 0001 	add.w	r0, r9, r1
   11bb2:	3801      	subs	r0, #1
   11bb4:	f004 fc96 	bl	164e4 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   11bb8:	4284      	cmp	r4, r0
   11bba:	f04f 0214 	mov.w	r2, #20
   11bbe:	4b1a      	ldr	r3, [pc, #104]	; (11c28 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
   11bc0:	d008      	beq.n	11bd4 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   11bc2:	f06f 0315 	mvn.w	r3, #21
   11bc6:	fb02 f808 	mul.w	r8, r2, r8
   11bca:	f84b 3008 	str.w	r3, [fp, r8]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   11bce:	b003      	add	sp, #12
   11bd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   11bd4:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   11bd8:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   11bda:	d0f8      	beq.n	11bce <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   11bdc:	7819      	ldrb	r1, [r3, #0]
   11bde:	42a1      	cmp	r1, r4
   11be0:	ddf5      	ble.n	11bce <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
   11be2:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
   11be6:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
   11be8:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
   11bea:	68fc      	ldr	r4, [r7, #12]
   11bec:	f100 0108 	add.w	r1, r0, #8
   11bf0:	7b00      	ldrb	r0, [r0, #12]
   11bf2:	f364 0004 	bfi	r0, r4, #0, #5
   11bf6:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   11bf8:	6938      	ldr	r0, [r7, #16]
   11bfa:	790c      	ldrb	r4, [r1, #4]
   11bfc:	0840      	lsrs	r0, r0, #1
   11bfe:	f360 1447 	bfi	r4, r0, #5, #3
   11c02:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   11c04:	68f9      	ldr	r1, [r7, #12]
   11c06:	f021 011f 	bic.w	r1, r1, #31
   11c0a:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   11c0c:	6939      	ldr	r1, [r7, #16]
   11c0e:	f021 011f 	bic.w	r1, r1, #31
   11c12:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   11c14:	f108 0801 	add.w	r8, r8, #1
   11c18:	3514      	adds	r5, #20
   11c1a:	360c      	adds	r6, #12
   11c1c:	e7b9      	b.n	11b92 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   11c1e:	bf00      	nop
   11c20:	2000c8c0 	.word	0x2000c8c0
   11c24:	e000ed90 	.word	0xe000ed90
   11c28:	2000ccbe 	.word	0x2000ccbe

00011c2c <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   11c2c:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   11c2e:	4c0e      	ldr	r4, [pc, #56]	; (11c68 <z_arm_mpu_init+0x3c>)
   11c30:	6825      	ldr	r5, [r4, #0]
   11c32:	2d10      	cmp	r5, #16
   11c34:	d814      	bhi.n	11c60 <z_arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   11c36:	f7ff ff91 	bl	11b5c <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   11c3a:	2000      	movs	r0, #0
	MPU->MAIR0 =
   11c3c:	4b0b      	ldr	r3, [pc, #44]	; (11c6c <z_arm_mpu_init+0x40>)
   11c3e:	4a0c      	ldr	r2, [pc, #48]	; (11c70 <z_arm_mpu_init+0x44>)
   11c40:	631a      	str	r2, [r3, #48]	; 0x30
   11c42:	4285      	cmp	r5, r0
   11c44:	d105      	bne.n	11c52 <z_arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   11c46:	4b0b      	ldr	r3, [pc, #44]	; (11c74 <z_arm_mpu_init+0x48>)
   11c48:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
   11c4a:	f7ff ff7d 	bl	11b48 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   11c4e:	2000      	movs	r0, #0
}
   11c50:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   11c52:	6861      	ldr	r1, [r4, #4]
   11c54:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   11c58:	f7ff fec0 	bl	119dc <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   11c5c:	3001      	adds	r0, #1
   11c5e:	e7f0      	b.n	11c42 <z_arm_mpu_init+0x16>
		return -1;
   11c60:	f04f 30ff 	mov.w	r0, #4294967295
   11c64:	e7f4      	b.n	11c50 <z_arm_mpu_init+0x24>
   11c66:	bf00      	nop
   11c68:	000172b4 	.word	0x000172b4
   11c6c:	e000ed90 	.word	0xe000ed90
   11c70:	0044ffaa 	.word	0x0044ffaa
   11c74:	2000ccbe 	.word	0x2000ccbe

00011c78 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   11c78:	4b01      	ldr	r3, [pc, #4]	; (11c80 <__stdout_hook_install+0x8>)
   11c7a:	6018      	str	r0, [r3, #0]
}
   11c7c:	4770      	bx	lr
   11c7e:	bf00      	nop
   11c80:	2000c504 	.word	0x2000c504

00011c84 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
   11c84:	4a0e      	ldr	r2, [pc, #56]	; (11cc0 <onoff_stop+0x3c>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   11c86:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   11c88:	1a84      	subs	r4, r0, r2
{
   11c8a:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   11c8c:	200c      	movs	r0, #12
{
   11c8e:	460e      	mov	r6, r1
	err = set_off_state(&subdata->flags, ctx);
   11c90:	2140      	movs	r1, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
   11c92:	10a3      	asrs	r3, r4, #2
   11c94:	4c0b      	ldr	r4, [pc, #44]	; (11cc4 <onoff_stop+0x40>)
   11c96:	435c      	muls	r4, r3
   11c98:	b2e4      	uxtb	r4, r4
	err = set_off_state(&subdata->flags, ctx);
   11c9a:	fb00 2004 	mla	r0, r0, r4, r2
   11c9e:	4408      	add	r0, r1
   11ca0:	f004 fc92 	bl	165c8 <set_off_state>
	if (err < 0) {
   11ca4:	1e01      	subs	r1, r0, #0
   11ca6:	db05      	blt.n	11cb4 <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
   11ca8:	4b07      	ldr	r3, [pc, #28]	; (11cc8 <onoff_stop+0x44>)
   11caa:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   11cae:	6863      	ldr	r3, [r4, #4]
   11cb0:	4798      	blx	r3
	return 0;
   11cb2:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
   11cb4:	4628      	mov	r0, r5
   11cb6:	4633      	mov	r3, r6
}
   11cb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   11cbc:	4718      	bx	r3
   11cbe:	bf00      	nop
   11cc0:	2000c8e4 	.word	0x2000c8e4
   11cc4:	b6db6db7 	.word	0xb6db6db7
   11cc8:	000172f4 	.word	0x000172f4

00011ccc <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   11ccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
   11cd0:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
   11cd2:	4e10      	ldr	r6, [pc, #64]	; (11d14 <onoff_start+0x48>)
{
   11cd4:	4680      	mov	r8, r0
	size_t offset = (size_t)(mgr - data->mgr);
   11cd6:	1b84      	subs	r4, r0, r6
   11cd8:	10a3      	asrs	r3, r4, #2
   11cda:	4c0f      	ldr	r4, [pc, #60]	; (11d18 <onoff_start+0x4c>)
{
   11cdc:	460f      	mov	r7, r1
	size_t offset = (size_t)(mgr - data->mgr);
   11cde:	435c      	muls	r4, r3
   11ce0:	b2e4      	uxtb	r4, r4
	err = set_starting_state(&subdata->flags, ctx);
   11ce2:	4365      	muls	r5, r4
   11ce4:	f105 0040 	add.w	r0, r5, #64	; 0x40
   11ce8:	2140      	movs	r1, #64	; 0x40
   11cea:	4430      	add	r0, r6
   11cec:	f004 fc85 	bl	165fa <set_starting_state>
	if (err < 0) {
   11cf0:	1e01      	subs	r1, r0, #0
   11cf2:	db09      	blt.n	11d08 <onoff_start+0x3c>
	subdata->cb = cb;
   11cf4:	4a09      	ldr	r2, [pc, #36]	; (11d1c <onoff_start+0x50>)
   11cf6:	1973      	adds	r3, r6, r5
	subdata->user_data = user_data;
   11cf8:	e9c3 270e 	strd	r2, r7, [r3, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   11cfc:	4b08      	ldr	r3, [pc, #32]	; (11d20 <onoff_start+0x54>)
   11cfe:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
   11d02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
   11d06:	4718      	bx	r3
		notify(mgr, err);
   11d08:	4640      	mov	r0, r8
   11d0a:	463b      	mov	r3, r7
}
   11d0c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
   11d10:	4718      	bx	r3
   11d12:	bf00      	nop
   11d14:	2000c8e4 	.word	0x2000c8e4
   11d18:	b6db6db7 	.word	0xb6db6db7
   11d1c:	0001665d 	.word	0x0001665d
   11d20:	000172f4 	.word	0x000172f4

00011d24 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   11d24:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   11d26:	2200      	movs	r2, #0
   11d28:	2101      	movs	r1, #1
{
   11d2a:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   11d2c:	2005      	movs	r0, #5
   11d2e:	f7ff fbff 	bl	11530 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
   11d32:	2005      	movs	r0, #5
   11d34:	f7ff fbde 	bl	114f4 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
   11d38:	480f      	ldr	r0, [pc, #60]	; (11d78 <clk_init+0x54>)
   11d3a:	f001 f8f7 	bl	12f2c <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   11d3e:	4b0f      	ldr	r3, [pc, #60]	; (11d7c <clk_init+0x58>)
   11d40:	4298      	cmp	r0, r3
   11d42:	d115      	bne.n	11d70 <clk_init+0x4c>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   11d44:	f004 fde2 	bl	1690c <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);
   11d48:	6926      	ldr	r6, [r4, #16]

		err = onoff_manager_init(get_onoff_manager(dev, i),
   11d4a:	490d      	ldr	r1, [pc, #52]	; (11d80 <clk_init+0x5c>)
   11d4c:	4630      	mov	r0, r6
   11d4e:	f004 f8f6 	bl	15f3e <onoff_manager_init>
					 &transitions);
		if (err < 0) {
   11d52:	2800      	cmp	r0, #0
   11d54:	db0b      	blt.n	11d6e <clk_init+0x4a>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   11d56:	2501      	movs	r5, #1
   11d58:	6435      	str	r5, [r6, #64]	; 0x40
						get_sub_data(dev, i);
   11d5a:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   11d5c:	4908      	ldr	r1, [pc, #32]	; (11d80 <clk_init+0x5c>)
   11d5e:	f104 001c 	add.w	r0, r4, #28
   11d62:	f004 f8ec 	bl	15f3e <onoff_manager_init>
		if (err < 0) {
   11d66:	2800      	cmp	r0, #0
   11d68:	db01      	blt.n	11d6e <clk_init+0x4a>
	}

	return 0;
   11d6a:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   11d6c:	64e5      	str	r5, [r4, #76]	; 0x4c
}
   11d6e:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
   11d70:	f06f 0004 	mvn.w	r0, #4
   11d74:	e7fb      	b.n	11d6e <clk_init+0x4a>
   11d76:	bf00      	nop
   11d78:	00011db9 	.word	0x00011db9
   11d7c:	0bad0000 	.word	0x0bad0000
   11d80:	00017304 	.word	0x00017304

00011d84 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   11d84:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   11d86:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   11d88:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   11d8a:	434b      	muls	r3, r1
   11d8c:	4808      	ldr	r0, [pc, #32]	; (11db0 <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
   11d8e:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   11d90:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   11d92:	3340      	adds	r3, #64	; 0x40
	void *user_data = sub_data->user_data;
   11d94:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   11d98:	4418      	add	r0, r3
	sub_data->cb = NULL;
   11d9a:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
   11d9c:	f004 fc4b 	bl	16636 <set_on_state>
	if (callback) {
   11da0:	b12d      	cbz	r5, 11dae <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   11da2:	4632      	mov	r2, r6
   11da4:	462b      	mov	r3, r5
}
   11da6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   11daa:	4802      	ldr	r0, [pc, #8]	; (11db4 <clkstarted_handle.constprop.0+0x30>)
   11dac:	4718      	bx	r3
}
   11dae:	bd70      	pop	{r4, r5, r6, pc}
   11db0:	2000c8e4 	.word	0x2000c8e4
   11db4:	00016fe8 	.word	0x00016fe8

00011db8 <clock_event_handler>:
	switch (event) {
   11db8:	b110      	cbz	r0, 11dc0 <clock_event_handler+0x8>
   11dba:	2801      	cmp	r0, #1
   11dbc:	d004      	beq.n	11dc8 <clock_event_handler+0x10>
   11dbe:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   11dc0:	4b03      	ldr	r3, [pc, #12]	; (11dd0 <clock_event_handler+0x18>)
   11dc2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   11dc4:	075b      	lsls	r3, r3, #29
   11dc6:	d101      	bne.n	11dcc <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   11dc8:	f7ff bfdc 	b.w	11d84 <clkstarted_handle.constprop.0>
}
   11dcc:	4770      	bx	lr
   11dce:	bf00      	nop
   11dd0:	2000c8e4 	.word	0x2000c8e4

00011dd4 <generic_hfclk_start>:
{
   11dd4:	b508      	push	{r3, lr}
	__asm__ volatile(
   11dd6:	f04f 0320 	mov.w	r3, #32
   11dda:	f3ef 8111 	mrs	r1, BASEPRI
   11dde:	f383 8812 	msr	BASEPRI_MAX, r3
   11de2:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   11de6:	4a11      	ldr	r2, [pc, #68]	; (11e2c <generic_hfclk_start+0x58>)
   11de8:	6813      	ldr	r3, [r2, #0]
   11dea:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
   11dee:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
   11df2:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   11df4:	d00b      	beq.n	11e0e <generic_hfclk_start+0x3a>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   11df6:	4a0e      	ldr	r2, [pc, #56]	; (11e30 <generic_hfclk_start+0x5c>)
   11df8:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   11dfc:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   11e00:	f013 0301 	ands.w	r3, r3, #1
   11e04:	d003      	beq.n	11e0e <generic_hfclk_start+0x3a>
			set_on_state(get_hf_flags());
   11e06:	480b      	ldr	r0, [pc, #44]	; (11e34 <generic_hfclk_start+0x60>)
   11e08:	f004 fc15 	bl	16636 <set_on_state>
			already_started = true;
   11e0c:	2301      	movs	r3, #1
	__asm__ volatile(
   11e0e:	f381 8811 	msr	BASEPRI, r1
   11e12:	f3bf 8f6f 	isb	sy
	if (already_started) {
   11e16:	b123      	cbz	r3, 11e22 <generic_hfclk_start+0x4e>
}
   11e18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   11e1c:	2000      	movs	r0, #0
   11e1e:	f7ff bfb1 	b.w	11d84 <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   11e22:	2001      	movs	r0, #1
}
   11e24:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   11e28:	f001 b890 	b.w	12f4c <nrfx_clock_start>
   11e2c:	2000c934 	.word	0x2000c934
   11e30:	40005000 	.word	0x40005000
   11e34:	2000c924 	.word	0x2000c924

00011e38 <generic_hfclk_stop>:
   11e38:	4b07      	ldr	r3, [pc, #28]	; (11e58 <generic_hfclk_stop+0x20>)
   11e3a:	e8d3 2fef 	ldaex	r2, [r3]
   11e3e:	f022 0102 	bic.w	r1, r2, #2
   11e42:	e8c3 1fe0 	stlex	r0, r1, [r3]
   11e46:	2800      	cmp	r0, #0
   11e48:	d1f7      	bne.n	11e3a <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
   11e4a:	07d3      	lsls	r3, r2, #31
   11e4c:	d402      	bmi.n	11e54 <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   11e4e:	2001      	movs	r0, #1
   11e50:	f001 b8ae 	b.w	12fb0 <nrfx_clock_stop>
}
   11e54:	4770      	bx	lr
   11e56:	bf00      	nop
   11e58:	2000c934 	.word	0x2000c934

00011e5c <api_blocking_start>:
{
   11e5c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   11e5e:	2200      	movs	r2, #0
   11e60:	2301      	movs	r3, #1
   11e62:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   11e66:	466b      	mov	r3, sp
   11e68:	4a08      	ldr	r2, [pc, #32]	; (11e8c <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   11e6a:	f8cd d000 	str.w	sp, [sp]
   11e6e:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   11e72:	f004 fc19 	bl	166a8 <api_start>
	if (err < 0) {
   11e76:	2800      	cmp	r0, #0
   11e78:	db05      	blt.n	11e86 <api_blocking_start+0x2a>
		/* coverity[OVERRUN] */
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
   11e7a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   11e7e:	2300      	movs	r3, #0
   11e80:	4668      	mov	r0, sp
   11e82:	f003 f9f9 	bl	15278 <z_impl_k_sem_take>
}
   11e86:	b005      	add	sp, #20
   11e88:	f85d fb04 	ldr.w	pc, [sp], #4
   11e8c:	0001667b 	.word	0x0001667b

00011e90 <z_nrf_clock_control_lf_on>:
{
   11e90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   11e94:	2201      	movs	r2, #1
   11e96:	4607      	mov	r7, r0
   11e98:	4936      	ldr	r1, [pc, #216]	; (11f74 <z_nrf_clock_control_lf_on+0xe4>)
   11e9a:	e8d1 3fef 	ldaex	r3, [r1]
   11e9e:	e8c1 2fe0 	stlex	r0, r2, [r1]
   11ea2:	2800      	cmp	r0, #0
   11ea4:	d1f9      	bne.n	11e9a <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   11ea6:	b933      	cbnz	r3, 11eb6 <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   11ea8:	4933      	ldr	r1, [pc, #204]	; (11f78 <z_nrf_clock_control_lf_on+0xe8>)
		err = onoff_request(mgr, &cli);
   11eaa:	4834      	ldr	r0, [pc, #208]	; (11f7c <z_nrf_clock_control_lf_on+0xec>)
   11eac:	604b      	str	r3, [r1, #4]
   11eae:	60cb      	str	r3, [r1, #12]
   11eb0:	608a      	str	r2, [r1, #8]
   11eb2:	f004 f857 	bl	15f64 <onoff_request>
	switch (start_mode) {
   11eb6:	1e7b      	subs	r3, r7, #1
   11eb8:	2b01      	cmp	r3, #1
   11eba:	d82e      	bhi.n	11f1a <z_nrf_clock_control_lf_on+0x8a>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   11ebc:	2f01      	cmp	r7, #1
   11ebe:	d106      	bne.n	11ece <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   11ec0:	4b2f      	ldr	r3, [pc, #188]	; (11f80 <z_nrf_clock_control_lf_on+0xf0>)
   11ec2:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   11ec6:	f003 0303 	and.w	r3, r3, #3
   11eca:	2b02      	cmp	r3, #2
   11ecc:	d025      	beq.n	11f1a <z_nrf_clock_control_lf_on+0x8a>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   11ece:	f004 feae 	bl	16c2e <k_is_in_isr>
   11ed2:	4604      	mov	r4, r0
   11ed4:	b918      	cbnz	r0, 11ede <z_nrf_clock_control_lf_on+0x4e>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   11ed6:	4b2b      	ldr	r3, [pc, #172]	; (11f84 <z_nrf_clock_control_lf_on+0xf4>)
	int key = isr_mode ? irq_lock() : 0;
   11ed8:	781b      	ldrb	r3, [r3, #0]
   11eda:	2b00      	cmp	r3, #0
   11edc:	d144      	bne.n	11f68 <z_nrf_clock_control_lf_on+0xd8>
	__asm__ volatile(
   11ede:	f04f 0320 	mov.w	r3, #32
   11ee2:	f3ef 8611 	mrs	r6, BASEPRI
   11ee6:	f383 8812 	msr	BASEPRI_MAX, r3
   11eea:	f3bf 8f6f 	isb	sy
   11eee:	2401      	movs	r4, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   11ef0:	4d23      	ldr	r5, [pc, #140]	; (11f80 <z_nrf_clock_control_lf_on+0xf0>)
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   11ef2:	f8df 809c 	ldr.w	r8, [pc, #156]	; 11f90 <z_nrf_clock_control_lf_on+0x100>
   11ef6:	46a9      	mov	r9, r5
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   11ef8:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   11efc:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
   11f00:	03d2      	lsls	r2, r2, #15
   11f02:	d50c      	bpl.n	11f1e <z_nrf_clock_control_lf_on+0x8e>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   11f04:	f003 0303 	and.w	r3, r3, #3
   11f08:	2b02      	cmp	r3, #2
   11f0a:	d001      	beq.n	11f10 <z_nrf_clock_control_lf_on+0x80>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   11f0c:	2f01      	cmp	r7, #1
   11f0e:	d106      	bne.n	11f1e <z_nrf_clock_control_lf_on+0x8e>
	if (isr_mode) {
   11f10:	b334      	cbz	r4, 11f60 <z_nrf_clock_control_lf_on+0xd0>
	__asm__ volatile(
   11f12:	f386 8811 	msr	BASEPRI, r6
   11f16:	f3bf 8f6f 	isb	sy
}
   11f1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   11f1e:	b1d4      	cbz	r4, 11f56 <z_nrf_clock_control_lf_on+0xc6>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   11f20:	4630      	mov	r0, r6
   11f22:	f7ff fadd 	bl	114e0 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   11f26:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   11f2a:	b2db      	uxtb	r3, r3
   11f2c:	2b01      	cmp	r3, #1
   11f2e:	d1e3      	bne.n	11ef8 <z_nrf_clock_control_lf_on+0x68>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   11f30:	f8d8 2000 	ldr.w	r2, [r8]
		    && nrf_clock_event_check(NRF_CLOCK,
   11f34:	2a00      	cmp	r2, #0
   11f36:	d0df      	beq.n	11ef8 <z_nrf_clock_control_lf_on+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   11f38:	2200      	movs	r2, #0
   11f3a:	f8c8 2000 	str.w	r2, [r8]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   11f3e:	f8d8 2000 	ldr.w	r2, [r8]
    p_reg->LFCLKSRC = (uint32_t)(source);
   11f42:	2202      	movs	r2, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   11f44:	2120      	movs	r1, #32
   11f46:	f8c5 2518 	str.w	r2, [r5, #1304]	; 0x518
   11f4a:	4a0f      	ldr	r2, [pc, #60]	; (11f88 <z_nrf_clock_control_lf_on+0xf8>)
   11f4c:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   11f50:	4a0e      	ldr	r2, [pc, #56]	; (11f8c <z_nrf_clock_control_lf_on+0xfc>)
   11f52:	6013      	str	r3, [r2, #0]
}
   11f54:	e7d0      	b.n	11ef8 <z_nrf_clock_control_lf_on+0x68>
	return z_impl_k_sleep(timeout);
   11f56:	2100      	movs	r1, #0
   11f58:	2021      	movs	r0, #33	; 0x21
   11f5a:	f003 fca1 	bl	158a0 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   11f5e:	e7e2      	b.n	11f26 <z_nrf_clock_control_lf_on+0x96>
    p_reg->INTENSET = mask;
   11f60:	2302      	movs	r3, #2
   11f62:	f8c9 3304 	str.w	r3, [r9, #772]	; 0x304
}
   11f66:	e7d8      	b.n	11f1a <z_nrf_clock_control_lf_on+0x8a>
    p_reg->INTENCLR = mask;
   11f68:	2202      	movs	r2, #2
   11f6a:	4b05      	ldr	r3, [pc, #20]	; (11f80 <z_nrf_clock_control_lf_on+0xf0>)
	int key = isr_mode ? irq_lock() : 0;
   11f6c:	4606      	mov	r6, r0
   11f6e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   11f72:	e7bd      	b.n	11ef0 <z_nrf_clock_control_lf_on+0x60>
   11f74:	2000c938 	.word	0x2000c938
   11f78:	2000c8d4 	.word	0x2000c8d4
   11f7c:	2000c900 	.word	0x2000c900
   11f80:	40005000 	.word	0x40005000
   11f84:	2000cdf0 	.word	0x2000cdf0
   11f88:	e000e100 	.word	0xe000e100
   11f8c:	40005008 	.word	0x40005008
   11f90:	40005104 	.word	0x40005104

00011f94 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
   11f94:	b508      	push	{r3, lr}

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = DEVICE_DT_GET(DT_CHOSEN(zephyr_console));
   11f96:	4808      	ldr	r0, [pc, #32]	; (11fb8 <uart_console_init+0x24>)
   11f98:	4b08      	ldr	r3, [pc, #32]	; (11fbc <uart_console_init+0x28>)
   11f9a:	6018      	str	r0, [r3, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
   11f9c:	f004 fdac 	bl	16af8 <z_device_ready>
   11fa0:	b138      	cbz	r0, 11fb2 <uart_console_init+0x1e>
	__stdout_hook_install(console_out);
   11fa2:	4807      	ldr	r0, [pc, #28]	; (11fc0 <uart_console_init+0x2c>)
   11fa4:	f7ff fe68 	bl	11c78 <__stdout_hook_install>
	__printk_hook_install(console_out);
   11fa8:	4805      	ldr	r0, [pc, #20]	; (11fc0 <uart_console_init+0x2c>)
   11faa:	f7fe fc97 	bl	108dc <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   11fae:	2000      	movs	r0, #0
}
   11fb0:	bd08      	pop	{r3, pc}
		return -ENODEV;
   11fb2:	f06f 0012 	mvn.w	r0, #18
   11fb6:	e7fb      	b.n	11fb0 <uart_console_init+0x1c>
   11fb8:	00017030 	.word	0x00017030
   11fbc:	2000c93c 	.word	0x2000c93c
   11fc0:	00011fc5 	.word	0x00011fc5

00011fc4 <console_out>:
	if ('\n' == c) {
   11fc4:	280a      	cmp	r0, #10
{
   11fc6:	b538      	push	{r3, r4, r5, lr}
   11fc8:	4604      	mov	r4, r0
   11fca:	4d07      	ldr	r5, [pc, #28]	; (11fe8 <console_out+0x24>)
	if ('\n' == c) {
   11fcc:	d104      	bne.n	11fd8 <console_out+0x14>
   11fce:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   11fd0:	6883      	ldr	r3, [r0, #8]
   11fd2:	210d      	movs	r1, #13
   11fd4:	685b      	ldr	r3, [r3, #4]
   11fd6:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   11fd8:	6828      	ldr	r0, [r5, #0]
   11fda:	6883      	ldr	r3, [r0, #8]
   11fdc:	b2e1      	uxtb	r1, r4
   11fde:	685b      	ldr	r3, [r3, #4]
   11fe0:	4798      	blx	r3
}
   11fe2:	4620      	mov	r0, r4
   11fe4:	bd38      	pop	{r3, r4, r5, pc}
   11fe6:	bf00      	nop
   11fe8:	2000c93c 	.word	0x2000c93c

00011fec <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   11fec:	b530      	push	{r4, r5, lr}
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   11fee:	6840      	ldr	r0, [r0, #4]
   11ff0:	f001 051f 	and.w	r5, r1, #31
   11ff4:	7b04      	ldrb	r4, [r0, #12]
	nrfx_err_t err;

	if (mode == GPIO_INT_MODE_DISABLED) {
   11ff6:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   11ffa:	ea45 1544 	orr.w	r5, r5, r4, lsl #5
{
   11ffe:	b085      	sub	sp, #20
   12000:	f04f 0400 	mov.w	r4, #0
	if (mode == GPIO_INT_MODE_DISABLED) {
   12004:	d104      	bne.n	12010 <gpio_nrfx_pin_interrupt_configure+0x24>
		nrfx_gpiote_trigger_disable(abs_pin);
   12006:	4628      	mov	r0, r5
   12008:	f001 fa90 	bl	1352c <nrfx_gpiote_trigger_disable>
		return -EIO;
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
   1200c:	2000      	movs	r0, #0
   1200e:	e02c      	b.n	1206a <gpio_nrfx_pin_interrupt_configure+0x7e>
	if (mode == GPIO_INT_MODE_LEVEL) {
   12010:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
	nrfx_gpiote_trigger_config_t trigger_config = {
   12014:	e9cd 4402 	strd	r4, r4, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   12018:	d129      	bne.n	1206e <gpio_nrfx_pin_interrupt_configure+0x82>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   1201a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   1201e:	bf0c      	ite	eq
   12020:	2304      	moveq	r3, #4
   12022:	2305      	movne	r3, #5
	nrfx_gpiote_trigger_config_t trigger_config = {
   12024:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   12028:	6883      	ldr	r3, [r0, #8]
   1202a:	fa23 f101 	lsr.w	r1, r3, r1
   1202e:	07c9      	lsls	r1, r1, #31
   12030:	d429      	bmi.n	12086 <gpio_nrfx_pin_interrupt_configure+0x9a>
   12032:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
   12036:	d126      	bne.n	12086 <gpio_nrfx_pin_interrupt_configure+0x9a>

NRF_STATIC_INLINE nrf_gpio_pin_dir_t nrf_gpio_pin_dir_get(uint32_t pin_number)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);

    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   12038:	4a1b      	ldr	r2, [pc, #108]	; (120a8 <gpio_nrfx_pin_interrupt_configure+0xbc>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
   1203a:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   1203e:	3380      	adds	r3, #128	; 0x80
   12040:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   12044:	07db      	lsls	r3, r3, #31
   12046:	d41e      	bmi.n	12086 <gpio_nrfx_pin_interrupt_configure+0x9a>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   12048:	f10d 0407 	add.w	r4, sp, #7
   1204c:	4621      	mov	r1, r4
   1204e:	4628      	mov	r0, r5
   12050:	f001 f9dc 	bl	1340c <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   12054:	4b15      	ldr	r3, [pc, #84]	; (120ac <gpio_nrfx_pin_interrupt_configure+0xc0>)
   12056:	4298      	cmp	r0, r3
   12058:	d114      	bne.n	12084 <gpio_nrfx_pin_interrupt_configure+0x98>
			err = nrfx_gpiote_channel_alloc(&ch);
   1205a:	4620      	mov	r0, r4
   1205c:	f001 fa20 	bl	134a0 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   12060:	4b13      	ldr	r3, [pc, #76]	; (120b0 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   12062:	4298      	cmp	r0, r3
   12064:	d00e      	beq.n	12084 <gpio_nrfx_pin_interrupt_configure+0x98>
				return -ENOMEM;
   12066:	f06f 000b 	mvn.w	r0, #11
}
   1206a:	b005      	add	sp, #20
   1206c:	bd30      	pop	{r4, r5, pc}
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1206e:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   12072:	d005      	beq.n	12080 <gpio_nrfx_pin_interrupt_configure+0x94>
   12074:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
   12078:	bf0c      	ite	eq
   1207a:	2302      	moveq	r3, #2
   1207c:	2301      	movne	r3, #1
   1207e:	e7d1      	b.n	12024 <gpio_nrfx_pin_interrupt_configure+0x38>
   12080:	2303      	movs	r3, #3
   12082:	e7cf      	b.n	12024 <gpio_nrfx_pin_interrupt_configure+0x38>
		trigger_config.p_in_channel = &ch;
   12084:	9403      	str	r4, [sp, #12]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   12086:	2300      	movs	r3, #0
   12088:	4628      	mov	r0, r5
   1208a:	4619      	mov	r1, r3
   1208c:	aa02      	add	r2, sp, #8
   1208e:	f001 f87d 	bl	1318c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   12092:	4b07      	ldr	r3, [pc, #28]	; (120b0 <gpio_nrfx_pin_interrupt_configure+0xc4>)
   12094:	4298      	cmp	r0, r3
   12096:	d104      	bne.n	120a2 <gpio_nrfx_pin_interrupt_configure+0xb6>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   12098:	2101      	movs	r1, #1
   1209a:	4628      	mov	r0, r5
   1209c:	f001 fa06 	bl	134ac <nrfx_gpiote_trigger_enable>
   120a0:	e7b4      	b.n	1200c <gpio_nrfx_pin_interrupt_configure+0x20>
		return -EIO;
   120a2:	f06f 0004 	mvn.w	r0, #4
   120a6:	e7e0      	b.n	1206a <gpio_nrfx_pin_interrupt_configure+0x7e>
   120a8:	40842500 	.word	0x40842500
   120ac:	0bad0004 	.word	0x0bad0004
   120b0:	0bad0000 	.word	0x0bad0000

000120b4 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   120b4:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   120b6:	f001 f9e3 	bl	13480 <nrfx_gpiote_is_init>
   120ba:	4604      	mov	r4, r0
   120bc:	b968      	cbnz	r0, 120da <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   120be:	f001 f9b7 	bl	13430 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   120c2:	4b08      	ldr	r3, [pc, #32]	; (120e4 <gpio_nrfx_init+0x30>)
   120c4:	4298      	cmp	r0, r3
   120c6:	d10a      	bne.n	120de <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   120c8:	4621      	mov	r1, r4
   120ca:	4807      	ldr	r0, [pc, #28]	; (120e8 <gpio_nrfx_init+0x34>)
   120cc:	f001 f998 	bl	13400 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   120d0:	4622      	mov	r2, r4
   120d2:	2105      	movs	r1, #5
   120d4:	2031      	movs	r0, #49	; 0x31
   120d6:	f7ff fa2b 	bl	11530 <z_arm_irq_priority_set>
		return 0;
   120da:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   120dc:	bd10      	pop	{r4, pc}
		return -EIO;
   120de:	f06f 0004 	mvn.w	r0, #4
   120e2:	e7fb      	b.n	120dc <gpio_nrfx_init+0x28>
   120e4:	0bad0000 	.word	0x0bad0000
   120e8:	000120ed 	.word	0x000120ed

000120ec <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   120ec:	0943      	lsrs	r3, r0, #5
{
   120ee:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   120f0:	d117      	bne.n	12122 <nrfx_gpio_handler+0x36>
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   120f2:	4b0c      	ldr	r3, [pc, #48]	; (12124 <nrfx_gpio_handler+0x38>)
   120f4:	6859      	ldr	r1, [r3, #4]
   120f6:	b1a1      	cbz	r1, 12122 <nrfx_gpio_handler+0x36>
   120f8:	680c      	ldr	r4, [r1, #0]
	gpio_fire_callbacks(list, port, BIT(pin));
   120fa:	2501      	movs	r5, #1
   120fc:	2c00      	cmp	r4, #0
   120fe:	bf38      	it	cc
   12100:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   12102:	4e09      	ldr	r6, [pc, #36]	; (12128 <nrfx_gpio_handler+0x3c>)
   12104:	4085      	lsls	r5, r0
		if (cb->pin_mask & pins) {
   12106:	688a      	ldr	r2, [r1, #8]
   12108:	402a      	ands	r2, r5
   1210a:	d002      	beq.n	12112 <nrfx_gpio_handler+0x26>
			cb->handler(port, cb, cb->pin_mask & pins);
   1210c:	4630      	mov	r0, r6
   1210e:	684b      	ldr	r3, [r1, #4]
   12110:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   12112:	b134      	cbz	r4, 12122 <nrfx_gpio_handler+0x36>
	return node->next;
   12114:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   12116:	4621      	mov	r1, r4
   12118:	2b00      	cmp	r3, #0
   1211a:	bf38      	it	cc
   1211c:	2300      	movcc	r3, #0
   1211e:	461c      	mov	r4, r3
   12120:	e7f1      	b.n	12106 <nrfx_gpio_handler+0x1a>
}
   12122:	bd70      	pop	{r4, r5, r6, pc}
   12124:	2000c940 	.word	0x2000c940
   12128:	00017000 	.word	0x00017000

0001212c <gpio_nrfx_pin_configure>:
{
   1212c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   12130:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   12132:	f001 051f 	and.w	r5, r1, #31
   12136:	7b3b      	ldrb	r3, [r7, #12]
{
   12138:	460e      	mov	r6, r1
	if (flags == GPIO_DISCONNECTED) {
   1213a:	4614      	mov	r4, r2
{
   1213c:	b085      	sub	sp, #20
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1213e:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
   12142:	b9ca      	cbnz	r2, 12178 <gpio_nrfx_pin_configure+0x4c>
	err = nrfx_gpiote_channel_get(pin, &ch);
   12144:	a902      	add	r1, sp, #8
   12146:	4628      	mov	r0, r5
   12148:	f001 f960 	bl	1340c <nrfx_gpiote_channel_get>
   1214c:	4604      	mov	r4, r0
	err = nrfx_gpiote_pin_uninit(pin);
   1214e:	4628      	mov	r0, r5
   12150:	f001 fa0e 	bl	13570 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
   12154:	4b47      	ldr	r3, [pc, #284]	; (12274 <gpio_nrfx_pin_configure+0x148>)
   12156:	4298      	cmp	r0, r3
   12158:	d004      	beq.n	12164 <gpio_nrfx_pin_configure+0x38>
		return -EIO;
   1215a:	f06f 0004 	mvn.w	r0, #4
}
   1215e:	b005      	add	sp, #20
   12160:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (free_ch) {
   12164:	4284      	cmp	r4, r0
   12166:	d105      	bne.n	12174 <gpio_nrfx_pin_configure+0x48>
		err = nrfx_gpiote_channel_free(ch);
   12168:	f89d 0008 	ldrb.w	r0, [sp, #8]
   1216c:	f001 f992 	bl	13494 <nrfx_gpiote_channel_free>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
   12170:	42a0      	cmp	r0, r4
   12172:	d1f2      	bne.n	1215a <gpio_nrfx_pin_configure+0x2e>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   12174:	2000      	movs	r0, #0
   12176:	e7f2      	b.n	1215e <gpio_nrfx_pin_configure+0x32>
	nrfx_gpiote_trigger_config_t trigger_config = {
   12178:	f04f 0900 	mov.w	r9, #0
	err = nrfx_gpiote_channel_get(pin, &ch);
   1217c:	f10d 0103 	add.w	r1, sp, #3
   12180:	4630      	mov	r0, r6
	nrfx_gpiote_trigger_config_t trigger_config = {
   12182:	e9cd 9902 	strd	r9, r9, [sp, #8]
	err = nrfx_gpiote_channel_get(pin, &ch);
   12186:	f001 f941 	bl	1340c <nrfx_gpiote_channel_get>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1218a:	464b      	mov	r3, r9
	err = nrfx_gpiote_channel_get(pin, &ch);
   1218c:	4680      	mov	r8, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1218e:	4649      	mov	r1, r9
   12190:	4628      	mov	r0, r5
   12192:	aa02      	add	r2, sp, #8
   12194:	f000 fffa 	bl	1318c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   12198:	4b36      	ldr	r3, [pc, #216]	; (12274 <gpio_nrfx_pin_configure+0x148>)
   1219a:	4298      	cmp	r0, r3
   1219c:	d002      	beq.n	121a4 <gpio_nrfx_pin_configure+0x78>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1219e:	f06f 0015 	mvn.w	r0, #21
   121a2:	e7dc      	b.n	1215e <gpio_nrfx_pin_configure+0x32>
	if (free_ch) {
   121a4:	4580      	cmp	r8, r0
   121a6:	d103      	bne.n	121b0 <gpio_nrfx_pin_configure+0x84>
		err = nrfx_gpiote_channel_free(ch);
   121a8:	f89d 0003 	ldrb.w	r0, [sp, #3]
   121ac:	f001 f972 	bl	13494 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   121b0:	05a3      	lsls	r3, r4, #22
   121b2:	d54c      	bpl.n	1224e <gpio_nrfx_pin_configure+0x122>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   121b4:	4b30      	ldr	r3, [pc, #192]	; (12278 <gpio_nrfx_pin_configure+0x14c>)
   121b6:	4a31      	ldr	r2, [pc, #196]	; (1227c <gpio_nrfx_pin_configure+0x150>)
   121b8:	4023      	ands	r3, r4
   121ba:	4293      	cmp	r3, r2
   121bc:	d039      	beq.n	12232 <gpio_nrfx_pin_configure+0x106>
   121be:	d80c      	bhi.n	121da <gpio_nrfx_pin_configure+0xae>
   121c0:	2b06      	cmp	r3, #6
   121c2:	d014      	beq.n	121ee <gpio_nrfx_pin_configure+0xc2>
   121c4:	d804      	bhi.n	121d0 <gpio_nrfx_pin_configure+0xa4>
   121c6:	b193      	cbz	r3, 121ee <gpio_nrfx_pin_configure+0xc2>
   121c8:	2b02      	cmp	r3, #2
   121ca:	d1e8      	bne.n	1219e <gpio_nrfx_pin_configure+0x72>
   121cc:	2304      	movs	r3, #4
   121ce:	e00e      	b.n	121ee <gpio_nrfx_pin_configure+0xc2>
   121d0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   121d4:	d1e3      	bne.n	1219e <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_H0S1;
   121d6:	2301      	movs	r3, #1
   121d8:	e009      	b.n	121ee <gpio_nrfx_pin_configure+0xc2>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   121da:	4a29      	ldr	r2, [pc, #164]	; (12280 <gpio_nrfx_pin_configure+0x154>)
   121dc:	4293      	cmp	r3, r2
   121de:	d02a      	beq.n	12236 <gpio_nrfx_pin_configure+0x10a>
   121e0:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   121e4:	d029      	beq.n	1223a <gpio_nrfx_pin_configure+0x10e>
   121e6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   121ea:	d1d8      	bne.n	1219e <gpio_nrfx_pin_configure+0x72>
		*drive = NRF_GPIO_PIN_S0H1;
   121ec:	2302      	movs	r3, #2
		nrfx_gpiote_output_config_t output_config = {
   121ee:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   121f2:	f484 7380 	eor.w	r3, r4, #256	; 0x100
   121f6:	f3c3 2300 	ubfx	r3, r3, #8, #1
	if (flags & GPIO_PULL_UP) {
   121fa:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   121fc:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   12200:	bf4c      	ite	mi
   12202:	2303      	movmi	r3, #3
		return NRF_GPIO_PIN_PULLDOWN;
   12204:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   12208:	0521      	lsls	r1, r4, #20
		nrfx_gpiote_output_config_t output_config = {
   1220a:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1220e:	d516      	bpl.n	1223e <gpio_nrfx_pin_configure+0x112>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   12210:	2101      	movs	r1, #1
   12212:	687b      	ldr	r3, [r7, #4]
   12214:	fa01 f606 	lsl.w	r6, r1, r6
    p_reg->OUTSET = set_mask;
   12218:	609e      	str	r6, [r3, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   1221a:	2200      	movs	r2, #0
   1221c:	4628      	mov	r0, r5
   1221e:	a901      	add	r1, sp, #4
   12220:	f001 f85a 	bl	132d8 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   12224:	4b13      	ldr	r3, [pc, #76]	; (12274 <gpio_nrfx_pin_configure+0x148>)
   12226:	4298      	cmp	r0, r3
   12228:	bf14      	ite	ne
   1222a:	f06f 0015 	mvnne.w	r0, #21
   1222e:	2000      	moveq	r0, #0
   12230:	e795      	b.n	1215e <gpio_nrfx_pin_configure+0x32>
		*drive = NRF_GPIO_PIN_H0D1;
   12232:	2307      	movs	r3, #7
   12234:	e7db      	b.n	121ee <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_D0H1;
   12236:	2305      	movs	r3, #5
   12238:	e7d9      	b.n	121ee <gpio_nrfx_pin_configure+0xc2>
		*drive = NRF_GPIO_PIN_H0H1;
   1223a:	2303      	movs	r3, #3
   1223c:	e7d7      	b.n	121ee <gpio_nrfx_pin_configure+0xc2>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   1223e:	0562      	lsls	r2, r4, #21
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   12240:	bf41      	itttt	mi
   12242:	2101      	movmi	r1, #1
   12244:	687b      	ldrmi	r3, [r7, #4]
   12246:	fa01 f606 	lslmi.w	r6, r1, r6
    p_reg->OUTCLR = clr_mask;
   1224a:	60de      	strmi	r6, [r3, #12]
}
   1224c:	e7e5      	b.n	1221a <gpio_nrfx_pin_configure+0xee>
	if (flags & GPIO_PULL_UP) {
   1224e:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   12250:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   12254:	bf4c      	ite	mi
   12256:	2403      	movmi	r4, #3
   12258:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1225c:	461a      	mov	r2, r3
   1225e:	4628      	mov	r0, r5
   12260:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   12262:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   12266:	f000 ff91 	bl	1318c <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   1226a:	4b02      	ldr	r3, [pc, #8]	; (12274 <gpio_nrfx_pin_configure+0x148>)
   1226c:	4298      	cmp	r0, r3
   1226e:	d081      	beq.n	12174 <gpio_nrfx_pin_configure+0x48>
   12270:	e795      	b.n	1219e <gpio_nrfx_pin_configure+0x72>
   12272:	bf00      	nop
   12274:	0bad0000 	.word	0x0bad0000
   12278:	00f00006 	.word	0x00f00006
   1227c:	00100006 	.word	0x00100006
   12280:	00400002 	.word	0x00400002

00012284 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
   12284:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   12286:	794b      	ldrb	r3, [r1, #5]
   12288:	2b01      	cmp	r3, #1
   1228a:	d026      	beq.n	122da <uarte_nrfx_configure+0x56>
   1228c:	2b03      	cmp	r3, #3
   1228e:	d121      	bne.n	122d4 <uarte_nrfx_configure+0x50>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   12290:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   12292:	798b      	ldrb	r3, [r1, #6]
   12294:	2b03      	cmp	r3, #3
   12296:	d11d      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   12298:	79cc      	ldrb	r4, [r1, #7]
   1229a:	b10c      	cbz	r4, 122a0 <uarte_nrfx_configure+0x1c>
   1229c:	2c01      	cmp	r4, #1
   1229e:	d119      	bne.n	122d4 <uarte_nrfx_configure+0x50>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   122a0:	790a      	ldrb	r2, [r1, #4]
   122a2:	b112      	cbz	r2, 122aa <uarte_nrfx_configure+0x26>
   122a4:	2a02      	cmp	r2, #2
   122a6:	d115      	bne.n	122d4 <uarte_nrfx_configure+0x50>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   122a8:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   122aa:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   122ac:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   122ae:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
   122b2:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   122b4:	d065      	beq.n	12382 <uarte_nrfx_configure+0xfe>
   122b6:	d82d      	bhi.n	12314 <uarte_nrfx_configure+0x90>
   122b8:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   122bc:	d064      	beq.n	12388 <uarte_nrfx_configure+0x104>
   122be:	d816      	bhi.n	122ee <uarte_nrfx_configure+0x6a>
   122c0:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   122c4:	d062      	beq.n	1238c <uarte_nrfx_configure+0x108>
   122c6:	d80a      	bhi.n	122de <uarte_nrfx_configure+0x5a>
   122c8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   122cc:	d061      	beq.n	12392 <uarte_nrfx_configure+0x10e>
   122ce:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   122d2:	d061      	beq.n	12398 <uarte_nrfx_configure+0x114>
   122d4:	f06f 0085 	mvn.w	r0, #133	; 0x85
   122d8:	e052      	b.n	12380 <uarte_nrfx_configure+0xfc>
	switch (cfg->stop_bits) {
   122da:	2600      	movs	r6, #0
   122dc:	e7d9      	b.n	12292 <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   122de:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   122e2:	d05c      	beq.n	1239e <uarte_nrfx_configure+0x11a>
   122e4:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   122e8:	d1f4      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   122ea:	4b37      	ldr	r3, [pc, #220]	; (123c8 <uarte_nrfx_configure+0x144>)
   122ec:	e03c      	b.n	12368 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   122ee:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   122f2:	d057      	beq.n	123a4 <uarte_nrfx_configure+0x120>
   122f4:	d807      	bhi.n	12306 <uarte_nrfx_configure+0x82>
   122f6:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   122fa:	d055      	beq.n	123a8 <uarte_nrfx_configure+0x124>
   122fc:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   12300:	d1e8      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   12302:	4b32      	ldr	r3, [pc, #200]	; (123cc <uarte_nrfx_configure+0x148>)
   12304:	e030      	b.n	12368 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   12306:	f647 2712 	movw	r7, #31250	; 0x7a12
   1230a:	42bb      	cmp	r3, r7
   1230c:	d1e2      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   1230e:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   12312:	e029      	b.n	12368 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   12314:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   12318:	d048      	beq.n	123ac <uarte_nrfx_configure+0x128>
   1231a:	d813      	bhi.n	12344 <uarte_nrfx_configure+0xc0>
   1231c:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   12320:	d047      	beq.n	123b2 <uarte_nrfx_configure+0x12e>
   12322:	d809      	bhi.n	12338 <uarte_nrfx_configure+0xb4>
   12324:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   12328:	42bb      	cmp	r3, r7
   1232a:	d044      	beq.n	123b6 <uarte_nrfx_configure+0x132>
   1232c:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   12330:	d1d0      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   12332:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   12336:	e017      	b.n	12368 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   12338:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   1233c:	d1ca      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   1233e:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   12342:	e011      	b.n	12368 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   12344:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   12348:	d038      	beq.n	123bc <uarte_nrfx_configure+0x138>
   1234a:	d808      	bhi.n	1235e <uarte_nrfx_configure+0xda>
   1234c:	4f20      	ldr	r7, [pc, #128]	; (123d0 <uarte_nrfx_configure+0x14c>)
   1234e:	42bb      	cmp	r3, r7
   12350:	d037      	beq.n	123c2 <uarte_nrfx_configure+0x13e>
   12352:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   12356:	d1bd      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   12358:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   1235c:	e004      	b.n	12368 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   1235e:	4f1d      	ldr	r7, [pc, #116]	; (123d4 <uarte_nrfx_configure+0x150>)
   12360:	42bb      	cmp	r3, r7
   12362:	d1b7      	bne.n	122d4 <uarte_nrfx_configure+0x50>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   12364:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   12368:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   1236c:	6903      	ldr	r3, [r0, #16]
                    | (uint32_t)p_cfg->hwfc;
   1236e:	4334      	orrs	r4, r6
   12370:	4322      	orrs	r2, r4
   12372:	3304      	adds	r3, #4
   12374:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   12376:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   1237a:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   1237e:	2000      	movs	r0, #0
}
   12380:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   12382:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   12386:	e7ef      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   12388:	4b13      	ldr	r3, [pc, #76]	; (123d8 <uarte_nrfx_configure+0x154>)
   1238a:	e7ed      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   1238c:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   12390:	e7ea      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
   12392:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   12396:	e7e7      	b.n	12368 <uarte_nrfx_configure+0xe4>
	switch (baudrate) {
   12398:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   1239c:	e7e4      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   1239e:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   123a2:	e7e1      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   123a4:	4b0d      	ldr	r3, [pc, #52]	; (123dc <uarte_nrfx_configure+0x158>)
   123a6:	e7df      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   123a8:	4b0d      	ldr	r3, [pc, #52]	; (123e0 <uarte_nrfx_configure+0x15c>)
   123aa:	e7dd      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   123ac:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   123b0:	e7da      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   123b2:	4b0c      	ldr	r3, [pc, #48]	; (123e4 <uarte_nrfx_configure+0x160>)
   123b4:	e7d8      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   123b6:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   123ba:	e7d5      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   123bc:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   123c0:	e7d2      	b.n	12368 <uarte_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   123c2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   123c6:	e7cf      	b.n	12368 <uarte_nrfx_configure+0xe4>
   123c8:	0013b000 	.word	0x0013b000
   123cc:	004ea000 	.word	0x004ea000
   123d0:	0003d090 	.word	0x0003d090
   123d4:	000f4240 	.word	0x000f4240
   123d8:	00275000 	.word	0x00275000
   123dc:	0075c000 	.word	0x0075c000
   123e0:	003af000 	.word	0x003af000
   123e4:	013a9000 	.word	0x013a9000

000123e8 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
   123e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   123ea:	4605      	mov	r5, r0
   123ec:	460f      	mov	r7, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
   123ee:	6906      	ldr	r6, [r0, #16]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   123f0:	f004 fc1d 	bl	16c2e <k_is_in_isr>
   123f4:	b910      	cbnz	r0, 123fc <uarte_nrfx_poll_out+0x14>
	return !z_sys_post_kernel;
   123f6:	4b2c      	ldr	r3, [pc, #176]	; (124a8 <uarte_nrfx_poll_out+0xc0>)
	int key;

	if (isr_mode) {
   123f8:	781b      	ldrb	r3, [r3, #0]
   123fa:	b983      	cbnz	r3, 1241e <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   123fc:	f04f 0320 	mov.w	r3, #32
   12400:	f3ef 8411 	mrs	r4, BASEPRI
   12404:	f383 8812 	msr	BASEPRI_MAX, r3
   12408:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
   1240c:	4628      	mov	r0, r5
   1240e:	f004 f9fa 	bl	16806 <is_tx_ready>
   12412:	bb28      	cbnz	r0, 12460 <uarte_nrfx_poll_out+0x78>
	__asm__ volatile(
   12414:	f384 8811 	msr	BASEPRI, r4
   12418:	f3bf 8f6f 	isb	sy
}
   1241c:	e7ee      	b.n	123fc <uarte_nrfx_poll_out+0x14>
{
   1241e:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
   12420:	4628      	mov	r0, r5
   12422:	f004 f9f0 	bl	16806 <is_tx_ready>
   12426:	b970      	cbnz	r0, 12446 <uarte_nrfx_poll_out+0x5e>
   12428:	2001      	movs	r0, #1
   1242a:	f004 fa6d 	bl	16908 <nrfx_busy_wait>
   1242e:	3c01      	subs	r4, #1
   12430:	d1f6      	bne.n	12420 <uarte_nrfx_poll_out+0x38>
   12432:	2100      	movs	r1, #0
   12434:	2021      	movs	r0, #33	; 0x21
   12436:	f003 fa33 	bl	158a0 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   1243a:	e7f0      	b.n	1241e <uarte_nrfx_poll_out+0x36>
	__asm__ volatile(
   1243c:	f384 8811 	msr	BASEPRI, r4
   12440:	f3bf 8f6f 	isb	sy
}
   12444:	e7f5      	b.n	12432 <uarte_nrfx_poll_out+0x4a>
	__asm__ volatile(
   12446:	f04f 0320 	mov.w	r3, #32
   1244a:	f3ef 8411 	mrs	r4, BASEPRI
   1244e:	f383 8812 	msr	BASEPRI_MAX, r3
   12452:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
   12456:	4628      	mov	r0, r5
   12458:	f004 f9d5 	bl	16806 <is_tx_ready>
   1245c:	2800      	cmp	r0, #0
   1245e:	d0ed      	beq.n	1243c <uarte_nrfx_poll_out+0x54>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
   12460:	2201      	movs	r2, #1
		}
	} else {
		key = wait_tx_ready(dev);
	}

	data->char_out = c;
   12462:	f806 7f10 	strb.w	r7, [r6, #16]!
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   12466:	6869      	ldr	r1, [r5, #4]
	return config->uarte_regs;
   12468:	680b      	ldr	r3, [r1, #0]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1246a:	f8c3 6544 	str.w	r6, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1246e:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12472:	2200      	movs	r2, #0
   12474:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   12478:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   1247c:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
   12480:	f8d3 2158 	ldr.w	r2, [r3, #344]	; 0x158
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   12484:	684a      	ldr	r2, [r1, #4]
   12486:	06d2      	lsls	r2, r2, #27
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   12488:	bf41      	itttt	mi
   1248a:	2208      	movmi	r2, #8
   1248c:	f8c3 2500 	strmi.w	r2, [r3, #1280]	; 0x500
    p_reg->INTENSET = mask;
   12490:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   12494:	f8c3 2304 	strmi.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12498:	2201      	movs	r2, #1
   1249a:	609a      	str	r2, [r3, #8]
	__asm__ volatile(
   1249c:	f384 8811 	msr	BASEPRI, r4
   124a0:	f3bf 8f6f 	isb	sy
	tx_start(dev, &data->char_out, 1);

	irq_unlock(key);
}
   124a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   124a6:	bf00      	nop
   124a8:	2000cdf0 	.word	0x2000cdf0

000124ac <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
   124ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   124b0:	4606      	mov	r6, r0
   124b2:	2101      	movs	r1, #1
   124b4:	2200      	movs	r2, #0
   124b6:	2008      	movs	r0, #8
   124b8:	f7ff f83a 	bl	11530 <z_arm_irq_priority_set>
   124bc:	2008      	movs	r0, #8
   124be:	f7ff f819 	bl	114f4 <arch_irq_enable>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   124c2:	2300      	movs	r3, #0
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   124c4:	6877      	ldr	r7, [r6, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   124c6:	6935      	ldr	r5, [r6, #16]
	return config->uarte_regs;
   124c8:	683c      	ldr	r4, [r7, #0]
   124ca:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	data->dev = dev;
   124ce:	602e      	str	r6, [r5, #0]
	const struct uarte_nrfx_config *cfg = get_dev_config(dev);
   124d0:	6873      	ldr	r3, [r6, #4]
		if (cfg->tx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   124d2:	68d8      	ldr	r0, [r3, #12]
   124d4:	1c41      	adds	r1, r0, #1
   124d6:	d00b      	beq.n	124f0 <uarte_0_init+0x44>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   124d8:	2101      	movs	r1, #1
    p_reg->OUTSET = set_mask;
   124da:	f8df c138 	ldr.w	ip, [pc, #312]	; 12614 <uarte_0_init+0x168>
    *p_pin = pin_number & 0x1F;
   124de:	f000 021f 	and.w	r2, r0, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   124e2:	4091      	lsls	r1, r2
    p_reg->OUTSET = set_mask;
   124e4:	f8cc 1008 	str.w	r1, [ip, #8]
    reg->PIN_CNF[pin_number] = cnf;
   124e8:	2103      	movs	r1, #3
   124ea:	3280      	adds	r2, #128	; 0x80
   124ec:	f84c 1022 	str.w	r1, [ip, r2, lsl #2]
		if (cfg->rx_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   124f0:	6919      	ldr	r1, [r3, #16]
   124f2:	1c4a      	adds	r2, r1, #1
   124f4:	d00d      	beq.n	12512 <uarte_0_init+0x66>
			nrf_gpio_cfg_input(cfg->rx_pin,
   124f6:	7f1a      	ldrb	r2, [r3, #28]
   124f8:	f8df c118 	ldr.w	ip, [pc, #280]	; 12614 <uarte_0_init+0x168>
   124fc:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   124fe:	bf14      	ite	ne
   12500:	f04f 0e0c 	movne.w	lr, #12
   12504:	f04f 0e00 	moveq.w	lr, #0
    *p_pin = pin_number & 0x1F;
   12508:	f001 021f 	and.w	r2, r1, #31
    reg->PIN_CNF[pin_number] = cnf;
   1250c:	3280      	adds	r2, #128	; 0x80
   1250e:	f84c e022 	str.w	lr, [ip, r2, lsl #2]
		if (cfg->rts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   12512:	f8d3 c014 	ldr.w	ip, [r3, #20]
   12516:	f1bc 3fff 	cmp.w	ip, #4294967295
   1251a:	d00e      	beq.n	1253a <uarte_0_init+0x8e>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1251c:	f04f 0e01 	mov.w	lr, #1
    p_reg->OUTSET = set_mask;
   12520:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 12614 <uarte_0_init+0x168>
    *p_pin = pin_number & 0x1F;
   12524:	f00c 021f 	and.w	r2, ip, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   12528:	fa0e fe02 	lsl.w	lr, lr, r2
    p_reg->OUTSET = set_mask;
   1252c:	f8c8 e008 	str.w	lr, [r8, #8]
    reg->PIN_CNF[pin_number] = cnf;
   12530:	f04f 0e03 	mov.w	lr, #3
   12534:	3280      	adds	r2, #128	; 0x80
   12536:	f848 e022 	str.w	lr, [r8, r2, lsl #2]
		if (cfg->cts_pin != NRF_UARTE_PSEL_DISCONNECTED) {
   1253a:	f8d3 e018 	ldr.w	lr, [r3, #24]
   1253e:	f1be 3fff 	cmp.w	lr, #4294967295
   12542:	d00d      	beq.n	12560 <uarte_0_init+0xb4>
			nrf_gpio_cfg_input(cfg->cts_pin,
   12544:	7f5a      	ldrb	r2, [r3, #29]
   12546:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 12614 <uarte_0_init+0x168>
   1254a:	2a00      	cmp	r2, #0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   1254c:	bf14      	ite	ne
   1254e:	f04f 090c 	movne.w	r9, #12
   12552:	f04f 0900 	moveq.w	r9, #0
    *p_pin = pin_number & 0x1F;
   12556:	f00e 021f 	and.w	r2, lr, #31
    reg->PIN_CNF[pin_number] = cnf;
   1255a:	3280      	adds	r2, #128	; 0x80
   1255c:	f848 9022 	str.w	r9, [r8, r2, lsl #2]
	nrf_uarte_txrx_pins_set(cfg->uarte_regs, cfg->tx_pin, cfg->rx_pin);
   12560:	681b      	ldr	r3, [r3, #0]
    p_reg->PSEL.TXD = pseltxd;
   12562:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   12566:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   1256a:	6931      	ldr	r1, [r6, #16]
   1256c:	4630      	mov	r0, r6
    p_reg->PSEL.RTS = pselrts;
   1256e:	f8c3 c508 	str.w	ip, [r3, #1288]	; 0x508
   12572:	3104      	adds	r1, #4
    p_reg->PSEL.CTS = pselcts;
   12574:	f8c3 e510 	str.w	lr, [r3, #1296]	; 0x510
   12578:	f7ff fe84 	bl	12284 <uarte_nrfx_configure>
	if (err) {
   1257c:	4606      	mov	r6, r0
   1257e:	2800      	cmp	r0, #0
   12580:	d13d      	bne.n	125fe <uarte_0_init+0x152>
	    cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
   12582:	687b      	ldr	r3, [r7, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
   12584:	0799      	lsls	r1, r3, #30
   12586:	d513      	bpl.n	125b0 <uarte_0_init+0x104>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
   12588:	f105 0012 	add.w	r0, r5, #18
   1258c:	f000 fd84 	bl	13098 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
   12590:	4b1e      	ldr	r3, [pc, #120]	; (1260c <uarte_0_init+0x160>)
   12592:	4298      	cmp	r0, r3
   12594:	d136      	bne.n	12604 <uarte_0_init+0x158>
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   12596:	7cab      	ldrb	r3, [r5, #18]
   12598:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1259c:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
   125a0:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
   125a4:	2301      	movs	r3, #1
   125a6:	7caa      	ldrb	r2, [r5, #18]
   125a8:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
   125aa:	4a19      	ldr	r2, [pc, #100]	; (12610 <uarte_0_init+0x164>)
   125ac:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   125b0:	2308      	movs	r3, #8
   125b2:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
		if (!cfg->disable_rx) {
   125b6:	7a3b      	ldrb	r3, [r7, #8]
   125b8:	b95b      	cbnz	r3, 125d2 <uarte_0_init+0x126>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   125ba:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   125be:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   125c2:	f105 0311 	add.w	r3, r5, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   125c6:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   125ca:	2301      	movs	r3, #1
   125cc:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   125d0:	6023      	str	r3, [r4, #0]
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   125d2:	687b      	ldr	r3, [r7, #4]
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
   125d4:	3510      	adds	r5, #16
	if (!(cfg->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
   125d6:	079a      	lsls	r2, r3, #30
    p_reg->INTENSET = mask;
   125d8:	bf5c      	itt	pl
   125da:	f44f 7280 	movpl.w	r2, #256	; 0x100
   125de:	f8c4 2304 	strpl.w	r2, [r4, #772]	; 0x304
	if (cfg->flags & UARTE_CFG_FLAG_LOW_POWER) {
   125e2:	06db      	lsls	r3, r3, #27
   125e4:	bf44      	itt	mi
   125e6:	f44f 0380 	movmi.w	r3, #4194304	; 0x400000
   125ea:	f8c4 3304 	strmi.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
   125ee:	2300      	movs	r3, #0
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   125f0:	f8c4 5544 	str.w	r5, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   125f4:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   125f8:	2301      	movs	r3, #1
   125fa:	60a3      	str	r3, [r4, #8]
   125fc:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
   125fe:	4630      	mov	r0, r6
   12600:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EIO;
   12604:	f06f 0604 	mvn.w	r6, #4
UART_NRF_UARTE_DEVICE(0);
   12608:	e7f9      	b.n	125fe <uarte_0_init+0x152>
   1260a:	bf00      	nop
   1260c:	0bad0000 	.word	0x0bad0000
   12610:	40017000 	.word	0x40017000
   12614:	40842500 	.word	0x40842500

00012618 <sys_clock_timeout_handler>:
static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   12618:	4919      	ldr	r1, [pc, #100]	; (12680 <sys_clock_timeout_handler+0x68>)
{
   1261a:	b570      	push	{r4, r5, r6, lr}
   1261c:	4604      	mov	r4, r0
	return absolute_time & COUNTER_MAX;
   1261e:	f022 467f 	bic.w	r6, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   12622:	6808      	ldr	r0, [r1, #0]

	last_count += dticks * CYC_PER_TICK;
   12624:	e9c1 2300 	strd	r2, r3, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   12628:	f5a6 1300 	sub.w	r3, r6, #2097152	; 0x200000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
   1262c:	1a10      	subs	r0, r2, r0
	if (in_anchor_range(cc_value)) {
   1262e:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   12632:	f04f 0500 	mov.w	r5, #0
   12636:	d20a      	bcs.n	1264e <sys_clock_timeout_handler+0x36>
		return true;
   12638:	2501      	movs	r5, #1
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   1263a:	4b12      	ldr	r3, [pc, #72]	; (12684 <sys_clock_timeout_handler+0x6c>)
   1263c:	6819      	ldr	r1, [r3, #0]
   1263e:	060a      	lsls	r2, r1, #24
   12640:	0a0b      	lsrs	r3, r1, #8
   12642:	1992      	adds	r2, r2, r6
   12644:	4910      	ldr	r1, [pc, #64]	; (12688 <sys_clock_timeout_handler+0x70>)
   12646:	f143 0300 	adc.w	r3, r3, #0
   1264a:	e9c1 2300 	strd	r2, r3, [r1]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
   1264e:	f003 fa8b 	bl	15b68 <sys_clock_announce>
    p_reg->CC[ch] = cc_val;
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
   12652:	00a3      	lsls	r3, r4, #2
   12654:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   12658:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   1265c:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
			   (int32_t)dticks : (dticks > 0));

	if (cc_value == get_comparator(chan)) {
   12660:	42b2      	cmp	r2, r6
   12662:	d10b      	bne.n	1267c <sys_clock_timeout_handler+0x64>
		 * If anchor was updated we can enable same CC value to trigger
		 * interrupt after full cycle. Else set event in anchor update
		 * range. Since anchor was not updated we know that it's very
		 * far from mid point so setting is done without any protection.
		 */
		if (!anchor_updated) {
   12664:	b91d      	cbnz	r5, 1266e <sys_clock_timeout_handler+0x56>
    p_reg->CC[ch] = cc_val;
   12666:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   1266a:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   1266e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   12672:	4b06      	ldr	r3, [pc, #24]	; (1268c <sys_clock_timeout_handler+0x74>)
   12674:	fa00 f404 	lsl.w	r4, r0, r4
   12678:	f8c3 4344 	str.w	r4, [r3, #836]	; 0x344
			set_comparator(chan, COUNTER_HALF_SPAN);
		}
		event_enable(chan);
	}
}
   1267c:	bd70      	pop	{r4, r5, r6, pc}
   1267e:	bf00      	nop
   12680:	2000c6e0 	.word	0x2000c6e0
   12684:	2000c954 	.word	0x2000c954
   12688:	2000c6c8 	.word	0x2000c6c8
   1268c:	40015000 	.word	0x40015000

00012690 <compare_int_lock>:
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   12690:	2301      	movs	r3, #1
   12692:	4083      	lsls	r3, r0
{
   12694:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   12696:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   12698:	4a0c      	ldr	r2, [pc, #48]	; (126cc <compare_int_lock+0x3c>)
   1269a:	e8d2 1fef 	ldaex	r1, [r2]
   1269e:	ea01 0c04 	and.w	ip, r1, r4
   126a2:	e8c2 cfee 	stlex	lr, ip, [r2]
   126a6:	f1be 0f00 	cmp.w	lr, #0
   126aa:	d1f6      	bne.n	1269a <compare_int_lock+0xa>
	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   126ac:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   126b0:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
   126b4:	4a06      	ldr	r2, [pc, #24]	; (126d0 <compare_int_lock+0x40>)
   126b6:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
   126ba:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   126be:	f3bf 8f6f 	isb	sy
	return prev & BIT(chan);
   126c2:	420b      	tst	r3, r1
}
   126c4:	bf14      	ite	ne
   126c6:	2001      	movne	r0, #1
   126c8:	2000      	moveq	r0, #0
   126ca:	bd10      	pop	{r4, pc}
   126cc:	2000c950 	.word	0x2000c950
   126d0:	40015000 	.word	0x40015000

000126d4 <compare_int_unlock.part.0>:
		atomic_or(&int_mask, BIT(chan));
   126d4:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   126d6:	4a0e      	ldr	r2, [pc, #56]	; (12710 <compare_int_unlock.part.0+0x3c>)
   126d8:	4083      	lsls	r3, r0
   126da:	e8d2 1fef 	ldaex	r1, [r2]
   126de:	4319      	orrs	r1, r3
   126e0:	e8c2 1fec 	stlex	ip, r1, [r2]
   126e4:	f1bc 0f00 	cmp.w	ip, #0
   126e8:	d1f7      	bne.n	126da <compare_int_unlock.part.0+0x6>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   126ea:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   126ee:	4a09      	ldr	r2, [pc, #36]	; (12714 <compare_int_unlock.part.0+0x40>)
   126f0:	4083      	lsls	r3, r0
   126f2:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   126f6:	4b08      	ldr	r3, [pc, #32]	; (12718 <compare_int_unlock.part.0+0x44>)
   126f8:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   126fc:	fa23 f000 	lsr.w	r0, r3, r0
   12700:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12702:	bf42      	ittt	mi
   12704:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   12708:	4b04      	ldrmi	r3, [pc, #16]	; (1271c <compare_int_unlock.part.0+0x48>)
   1270a:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   1270e:	4770      	bx	lr
   12710:	2000c950 	.word	0x2000c950
   12714:	40015000 	.word	0x40015000
   12718:	2000c94c 	.word	0x2000c94c
   1271c:	e000e100 	.word	0xe000e100

00012720 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   12720:	4b0d      	ldr	r3, [pc, #52]	; (12758 <z_nrf_rtc_timer_read+0x38>)
   12722:	681b      	ldr	r3, [r3, #0]
   12724:	0a19      	lsrs	r1, r3, #8
   12726:	0618      	lsls	r0, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
   12728:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
   1272c:	4b0b      	ldr	r3, [pc, #44]	; (1275c <z_nrf_rtc_timer_read+0x3c>)
   1272e:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   12732:	18c0      	adds	r0, r0, r3
   12734:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   12738:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   1273c:	d20a      	bcs.n	12754 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   1273e:	4b08      	ldr	r3, [pc, #32]	; (12760 <z_nrf_rtc_timer_read+0x40>)
   12740:	e9d3 2300 	ldrd	r2, r3, [r3]
   12744:	4299      	cmp	r1, r3
   12746:	bf08      	it	eq
   12748:	4290      	cmpeq	r0, r2
   1274a:	d203      	bcs.n	12754 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   1274c:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   12750:	f141 0100 	adc.w	r1, r1, #0
}
   12754:	4770      	bx	lr
   12756:	bf00      	nop
   12758:	2000c954 	.word	0x2000c954
   1275c:	40015000 	.word	0x40015000
   12760:	2000c6c8 	.word	0x2000c6c8

00012764 <compare_set>:
{
   12764:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12768:	4616      	mov	r6, r2
   1276a:	461f      	mov	r7, r3
   1276c:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
   1276e:	f7ff ff8f 	bl	12690 <compare_int_lock>
   12772:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   12774:	f7ff ffd4 	bl	12720 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   12778:	42b9      	cmp	r1, r7
   1277a:	bf08      	it	eq
   1277c:	42b0      	cmpeq	r0, r6
   1277e:	d27b      	bcs.n	12878 <compare_set+0x114>
		if (target_time - curr_time > COUNTER_SPAN) {
   12780:	2300      	movs	r3, #0
   12782:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   12786:	ebb6 0800 	subs.w	r8, r6, r0
   1278a:	eb67 0901 	sbc.w	r9, r7, r1
   1278e:	454b      	cmp	r3, r9
   12790:	bf08      	it	eq
   12792:	4542      	cmpeq	r2, r8
   12794:	d37d      	bcc.n	12892 <compare_set+0x12e>
		if (target_time != cc_data[chan].target_time) {
   12796:	4b40      	ldr	r3, [pc, #256]	; (12898 <compare_set+0x134>)
   12798:	eb03 1305 	add.w	r3, r3, r5, lsl #4
   1279c:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   127a0:	429f      	cmp	r7, r3
   127a2:	bf08      	it	eq
   127a4:	4296      	cmpeq	r6, r2
   127a6:	d051      	beq.n	1284c <compare_set+0xe8>
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   127a8:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
	return absolute_time & COUNTER_MAX;
   127ac:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
	uint32_t cc_val = abs_val & COUNTER_MAX;
   127b0:	4614      	mov	r4, r2
   127b2:	ea4f 0985 	mov.w	r9, r5, lsl #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   127b6:	f105 0850 	add.w	r8, r5, #80	; 0x50
   127ba:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   127be:	ea4f 0888 	mov.w	r8, r8, lsl #2
   127c2:	f509 39a8 	add.w	r9, r9, #86016	; 0x15000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   127c6:	fa1f f888 	uxth.w	r8, r8
   127ca:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
    return p_reg->CC[ch];
   127ce:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   127d2:	4b32      	ldr	r3, [pc, #200]	; (1289c <compare_set+0x138>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   127d4:	f508 38a8 	add.w	r8, r8, #86016	; 0x15000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   127d8:	fa0b fb05 	lsl.w	fp, fp, r5
     return p_reg->COUNTER;
   127dc:	f8d3 a504 	ldr.w	sl, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   127e0:	eba0 000a 	sub.w	r0, r0, sl
   127e4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   127e8:	f02a 417f 	bic.w	r1, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
   127ec:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
   127ee:	f8c9 1540 	str.w	r1, [r9, #1344]	; 0x540
   127f2:	d105      	bne.n	12800 <compare_set+0x9c>
   127f4:	9201      	str	r2, [sp, #4]
	z_impl_k_busy_wait(usec_to_wait);
   127f6:	2013      	movs	r0, #19
   127f8:	f004 fb71 	bl	16ede <z_impl_k_busy_wait>
   127fc:	4b27      	ldr	r3, [pc, #156]	; (1289c <compare_set+0x138>)
   127fe:	9a01      	ldr	r2, [sp, #4]
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
   12800:	f10a 0c02 	add.w	ip, sl, #2
	return (a - b) & COUNTER_MAX;
   12804:	eba4 000c 	sub.w	r0, r4, ip
   12808:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1280c:	2100      	movs	r1, #0
			cc_val = now + 2;
   1280e:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   12812:	bf88      	it	hi
   12814:	4664      	movhi	r4, ip
   12816:	f8c8 1000 	str.w	r1, [r8]
   1281a:	f8d8 0000 	ldr.w	r0, [r8]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   1281e:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->EVTENSET = mask;
   12822:	f8c3 b344 	str.w	fp, [r3, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
   12826:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
   1282a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
   1282e:	4582      	cmp	sl, r0
   12830:	d006      	beq.n	12840 <compare_set+0xdc>
	return (a - b) & COUNTER_MAX;
   12832:	1a20      	subs	r0, r4, r0
   12834:	3802      	subs	r0, #2
   12836:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
   1283a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   1283e:	d819      	bhi.n	12874 <compare_set+0x110>
	return (a - b) & COUNTER_MAX;
   12840:	1aa4      	subs	r4, r4, r2
   12842:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
   12846:	1932      	adds	r2, r6, r4
   12848:	f147 0300 	adc.w	r3, r7, #0
	cc_data[chan].target_time = target_time;
   1284c:	4c12      	ldr	r4, [pc, #72]	; (12898 <compare_set+0x134>)
   1284e:	0129      	lsls	r1, r5, #4
   12850:	eb04 1005 	add.w	r0, r4, r5, lsl #4
   12854:	e9c0 2302 	strd	r2, r3, [r0, #8]
	cc_data[chan].callback = handler;
   12858:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	cc_data[chan].user_context = user_data;
   1285a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	cc_data[chan].callback = handler;
   1285c:	5062      	str	r2, [r4, r1]
	return ret;
   1285e:	2400      	movs	r4, #0
	cc_data[chan].user_context = user_data;
   12860:	6043      	str	r3, [r0, #4]
	if (key) {
   12862:	9b00      	ldr	r3, [sp, #0]
   12864:	b113      	cbz	r3, 1286c <compare_set+0x108>
   12866:	4628      	mov	r0, r5
   12868:	f7ff ff34 	bl	126d4 <compare_int_unlock.part.0>
}
   1286c:	4620      	mov	r0, r4
   1286e:	b003      	add	sp, #12
   12870:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12874:	4620      	mov	r0, r4
   12876:	e7b1      	b.n	127dc <compare_set+0x78>
		atomic_or(&force_isr_mask, BIT(chan));
   12878:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1287a:	4a09      	ldr	r2, [pc, #36]	; (128a0 <compare_set+0x13c>)
   1287c:	40ab      	lsls	r3, r5
   1287e:	e8d2 1fef 	ldaex	r1, [r2]
   12882:	4319      	orrs	r1, r3
   12884:	e8c2 1fe0 	stlex	r0, r1, [r2]
   12888:	2800      	cmp	r0, #0
   1288a:	d1f8      	bne.n	1287e <compare_set+0x11a>
   1288c:	4632      	mov	r2, r6
   1288e:	463b      	mov	r3, r7
   12890:	e7dc      	b.n	1284c <compare_set+0xe8>
			return -EINVAL;
   12892:	f06f 0415 	mvn.w	r4, #21
   12896:	e7e4      	b.n	12862 <compare_set+0xfe>
   12898:	2000c6d0 	.word	0x2000c6d0
   1289c:	40015000 	.word	0x40015000
   128a0:	2000c94c 	.word	0x2000c94c

000128a4 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
   128a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   128a6:	2400      	movs	r4, #0
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   128a8:	f04f 30ff 	mov.w	r0, #4294967295
   128ac:	f04f 31ff 	mov.w	r1, #4294967295
   128b0:	4d16      	ldr	r5, [pc, #88]	; (1290c <sys_clock_driver_init+0x68>)
   128b2:	4b17      	ldr	r3, [pc, #92]	; (12910 <sys_clock_driver_init+0x6c>)
   128b4:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
   128b8:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   128bc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   128c0:	2602      	movs	r6, #2
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   128c2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   128c6:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
   128ca:	4b12      	ldr	r3, [pc, #72]	; (12914 <sys_clock_driver_init+0x70>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   128cc:	2101      	movs	r1, #1
   128ce:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
   128d2:	2015      	movs	r0, #21
   128d4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   128d8:	4622      	mov	r2, r4
   128da:	f7fe fe29 	bl	11530 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   128de:	2015      	movs	r0, #21
   128e0:	f7fe fe08 	bl	114f4 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   128e4:	2301      	movs	r3, #1
   128e6:	4a0c      	ldr	r2, [pc, #48]	; (12918 <sys_clock_driver_init+0x74>)

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   128e8:	4620      	mov	r0, r4
   128ea:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
   128ec:	4a0b      	ldr	r2, [pc, #44]	; (1291c <sys_clock_driver_init+0x78>)
   128ee:	602b      	str	r3, [r5, #0]
   128f0:	6013      	str	r3, [r2, #0]
	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   128f2:	4b0b      	ldr	r3, [pc, #44]	; (12920 <sys_clock_driver_init+0x7c>)
   128f4:	4a0b      	ldr	r2, [pc, #44]	; (12924 <sys_clock_driver_init+0x80>)
   128f6:	9300      	str	r3, [sp, #0]
   128f8:	9401      	str	r4, [sp, #4]
   128fa:	2300      	movs	r3, #0
   128fc:	f7ff ff32 	bl	12764 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   12900:	4630      	mov	r0, r6
   12902:	f7ff fac5 	bl	11e90 <z_nrf_clock_control_lf_on>

	return 0;
}
   12906:	4620      	mov	r0, r4
   12908:	b002      	add	sp, #8
   1290a:	bd70      	pop	{r4, r5, r6, pc}
   1290c:	40015000 	.word	0x40015000
   12910:	2000c6d0 	.word	0x2000c6d0
   12914:	e000e100 	.word	0xe000e100
   12918:	40015008 	.word	0x40015008
   1291c:	2000c950 	.word	0x2000c950
   12920:	00012619 	.word	0x00012619
   12924:	007fffff 	.word	0x007fffff

00012928 <rtc_nrf_isr>:
    return p_reg->INTENSET & mask;
   12928:	4b33      	ldr	r3, [pc, #204]	; (129f8 <rtc_nrf_isr+0xd0>)
{
   1292a:	e92d 4373 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, lr}
   1292e:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   12932:	079a      	lsls	r2, r3, #30
   12934:	d509      	bpl.n	1294a <rtc_nrf_isr+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   12936:	4b31      	ldr	r3, [pc, #196]	; (129fc <rtc_nrf_isr+0xd4>)
   12938:	681a      	ldr	r2, [r3, #0]
   1293a:	b132      	cbz	r2, 1294a <rtc_nrf_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1293c:	2200      	movs	r2, #0
   1293e:	601a      	str	r2, [r3, #0]
		overflow_cnt++;
   12940:	4a2f      	ldr	r2, [pc, #188]	; (12a00 <rtc_nrf_isr+0xd8>)
   12942:	681b      	ldr	r3, [r3, #0]
   12944:	6813      	ldr	r3, [r2, #0]
   12946:	3301      	adds	r3, #1
   12948:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   1294a:	f04f 0320 	mov.w	r3, #32
   1294e:	f3ef 8211 	mrs	r2, BASEPRI
   12952:	f383 8812 	msr	BASEPRI_MAX, r3
   12956:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
   1295a:	4b27      	ldr	r3, [pc, #156]	; (129f8 <rtc_nrf_isr+0xd0>)
   1295c:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   12960:	03db      	lsls	r3, r3, #15
   12962:	d50e      	bpl.n	12982 <rtc_nrf_isr+0x5a>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   12964:	4b27      	ldr	r3, [pc, #156]	; (12a04 <rtc_nrf_isr+0xdc>)
   12966:	e8d3 1fef 	ldaex	r1, [r3]
   1296a:	f021 0001 	bic.w	r0, r1, #1
   1296e:	e8c3 0fe4 	stlex	r4, r0, [r3]
   12972:	2c00      	cmp	r4, #0
   12974:	d1f7      	bne.n	12966 <rtc_nrf_isr+0x3e>
   12976:	4b24      	ldr	r3, [pc, #144]	; (12a08 <rtc_nrf_isr+0xe0>)
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   12978:	2900      	cmp	r1, #0
   1297a:	d136      	bne.n	129ea <rtc_nrf_isr+0xc2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1297c:	6819      	ldr	r1, [r3, #0]
		if (result) {
   1297e:	2900      	cmp	r1, #0
   12980:	d133      	bne.n	129ea <rtc_nrf_isr+0xc2>
{
   12982:	2300      	movs	r3, #0
	__asm__ volatile(
   12984:	f382 8811 	msr	BASEPRI, r2
   12988:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
   1298c:	b353      	cbz	r3, 129e4 <rtc_nrf_isr+0xbc>
		curr_time = z_nrf_rtc_timer_read();
   1298e:	f7ff fec7 	bl	12720 <z_nrf_rtc_timer_read>
   12992:	4604      	mov	r4, r0
	__asm__ volatile(
   12994:	f04f 0320 	mov.w	r3, #32
   12998:	f3ef 8011 	mrs	r0, BASEPRI
   1299c:	f383 8812 	msr	BASEPRI_MAX, r3
   129a0:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   129a4:	4b19      	ldr	r3, [pc, #100]	; (12a0c <rtc_nrf_isr+0xe4>)
   129a6:	2200      	movs	r2, #0
   129a8:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
   129ac:	4549      	cmp	r1, r9
   129ae:	bf08      	it	eq
   129b0:	4544      	cmpeq	r4, r8
   129b2:	d31f      	bcc.n	129f4 <rtc_nrf_isr+0xcc>
			user_context = cc_data[chan].user_context;
   129b4:	e9d3 1600 	ldrd	r1, r6, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   129b8:	f04f 34ff 	mov.w	r4, #4294967295
   129bc:	f04f 35ff 	mov.w	r5, #4294967295
			cc_data[chan].callback = NULL;
   129c0:	601a      	str	r2, [r3, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   129c2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   129c6:	e9c3 4502 	strd	r4, r5, [r3, #8]
   129ca:	4b0b      	ldr	r3, [pc, #44]	; (129f8 <rtc_nrf_isr+0xd0>)
   129cc:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	__asm__ volatile(
   129d0:	f380 8811 	msr	BASEPRI, r0
   129d4:	f3bf 8f6f 	isb	sy
		if (handler) {
   129d8:	b121      	cbz	r1, 129e4 <rtc_nrf_isr+0xbc>
			handler(chan, expire_time, user_context);
   129da:	4642      	mov	r2, r8
   129dc:	464b      	mov	r3, r9
   129de:	2000      	movs	r0, #0
   129e0:	9600      	str	r6, [sp, #0]
   129e2:	4788      	blx	r1
}
   129e4:	b002      	add	sp, #8
   129e6:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   129ea:	2100      	movs	r1, #0
   129ec:	6019      	str	r1, [r3, #0]
   129ee:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
   129f0:	2301      	movs	r3, #1
}
   129f2:	e7c7      	b.n	12984 <rtc_nrf_isr+0x5c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
   129f4:	4611      	mov	r1, r2
   129f6:	e7eb      	b.n	129d0 <rtc_nrf_isr+0xa8>
   129f8:	40015000 	.word	0x40015000
   129fc:	40015104 	.word	0x40015104
   12a00:	2000c954 	.word	0x2000c954
   12a04:	2000c94c 	.word	0x2000c94c
   12a08:	40015140 	.word	0x40015140
   12a0c:	2000c6d0 	.word	0x2000c6d0

00012a10 <sys_clock_set_timeout>:
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   12a10:	4b14      	ldr	r3, [pc, #80]	; (12a64 <sys_clock_set_timeout+0x54>)
{
   12a12:	b513      	push	{r0, r1, r4, lr}
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   12a14:	f1b0 3fff 	cmp.w	r0, #4294967295
   12a18:	bf08      	it	eq
   12a1a:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   12a1c:	1e44      	subs	r4, r0, #1
   12a1e:	2c00      	cmp	r4, #0
   12a20:	dd1d      	ble.n	12a5e <sys_clock_set_timeout+0x4e>
   12a22:	429c      	cmp	r4, r3
   12a24:	bfa8      	it	ge
   12a26:	461c      	movge	r4, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   12a28:	f7ff fe7a 	bl	12720 <z_nrf_rtc_timer_read>
   12a2c:	4b0e      	ldr	r3, [pc, #56]	; (12a68 <sys_clock_set_timeout+0x58>)
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   12a2e:	490f      	ldr	r1, [pc, #60]	; (12a6c <sys_clock_set_timeout+0x5c>)
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   12a30:	e9d3 2300 	ldrd	r2, r3, [r3]
   12a34:	1a80      	subs	r0, r0, r2
		ticks = 0;
   12a36:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   12a3a:	bf28      	it	cs
   12a3c:	2400      	movcs	r4, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   12a3e:	3001      	adds	r0, #1
   12a40:	4404      	add	r4, r0
	uint64_t target_time = cyc + last_count;
   12a42:	4808      	ldr	r0, [pc, #32]	; (12a64 <sys_clock_set_timeout+0x54>)
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   12a44:	9100      	str	r1, [sp, #0]
	uint64_t target_time = cyc + last_count;
   12a46:	4284      	cmp	r4, r0
   12a48:	bf28      	it	cs
   12a4a:	4604      	movcs	r4, r0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   12a4c:	2000      	movs	r0, #0
   12a4e:	1912      	adds	r2, r2, r4
   12a50:	9001      	str	r0, [sp, #4]
   12a52:	f143 0300 	adc.w	r3, r3, #0
   12a56:	f7ff fe85 	bl	12764 <compare_set>
}
   12a5a:	b002      	add	sp, #8
   12a5c:	bd10      	pop	{r4, pc}
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
   12a5e:	2400      	movs	r4, #0
   12a60:	e7e2      	b.n	12a28 <sys_clock_set_timeout+0x18>
   12a62:	bf00      	nop
   12a64:	007fffff 	.word	0x007fffff
   12a68:	2000c6e0 	.word	0x2000c6e0
   12a6c:	00012619 	.word	0x00012619

00012a70 <sys_clock_elapsed>:
{
   12a70:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   12a72:	f7ff fe55 	bl	12720 <z_nrf_rtc_timer_read>
   12a76:	4b02      	ldr	r3, [pc, #8]	; (12a80 <sys_clock_elapsed+0x10>)
   12a78:	681b      	ldr	r3, [r3, #0]
}
   12a7a:	1ac0      	subs	r0, r0, r3
   12a7c:	bd08      	pop	{r3, pc}
   12a7e:	bf00      	nop
   12a80:	2000c6e0 	.word	0x2000c6e0

00012a84 <_nrf_modem_lib_init>:
	},
#endif
};

static int _nrf_modem_lib_init(const struct device *unused)
{
   12a84:	b538      	push	{r3, r4, r5, lr}
	if (!first_time_init) {
   12a86:	4d19      	ldr	r5, [pc, #100]	; (12aec <_nrf_modem_lib_init+0x68>)
   12a88:	4c19      	ldr	r4, [pc, #100]	; (12af0 <_nrf_modem_lib_init+0x6c>)
   12a8a:	782b      	ldrb	r3, [r5, #0]
   12a8c:	b933      	cbnz	r3, 12a9c <_nrf_modem_lib_init+0x18>
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
   12a8e:	e9c4 3300 	strd	r3, r3, [r4]
	return z_impl_k_mutex_init(mutex);
   12a92:	4818      	ldr	r0, [pc, #96]	; (12af4 <_nrf_modem_lib_init+0x70>)
   12a94:	f004 f8d8 	bl	16c48 <z_impl_k_mutex_init>
		sys_slist_init(&shutdown_threads);
		k_mutex_init(&slist_mutex);
		first_time_init = true;
   12a98:	2301      	movs	r3, #1
   12a9a:	702b      	strb	r3, [r5, #0]
	}

	/* Setup the network IRQ used by the Modem library.
	 * Note: No call to irq_enable() here, that is done through nrf_modem_init().
	 */
	IRQ_CONNECT(NRF_MODEM_NETWORK_IRQ, NRF_MODEM_NETWORK_IRQ_PRIORITY,
   12a9c:	2200      	movs	r2, #0
   12a9e:	202a      	movs	r0, #42	; 0x2a
   12aa0:	4611      	mov	r1, r2
   12aa2:	f7fe fd45 	bl	11530 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	init_ret = nrf_modem_init(&init_params, NORMAL_MODE);
   12aa6:	2100      	movs	r1, #0
   12aa8:	4813      	ldr	r0, [pc, #76]	; (12af8 <_nrf_modem_lib_init+0x74>)
   12aaa:	f002 f90d 	bl	14cc8 <nrf_modem_init>
   12aae:	4b13      	ldr	r3, [pc, #76]	; (12afc <_nrf_modem_lib_init+0x78>)
   12ab0:	6018      	str	r0, [r3, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
   12ab2:	f04f 32ff 	mov.w	r2, #4294967295
   12ab6:	f04f 33ff 	mov.w	r3, #4294967295
   12aba:	480e      	ldr	r0, [pc, #56]	; (12af4 <_nrf_modem_lib_init+0x70>)
   12abc:	f002 faf8 	bl	150b0 <z_impl_k_mutex_lock>

	k_mutex_lock(&slist_mutex, K_FOREVER);
	if (sys_slist_peek_head(&shutdown_threads) != NULL) {
   12ac0:	6820      	ldr	r0, [r4, #0]
   12ac2:	b170      	cbz	r0, 12ae2 <_nrf_modem_lib_init+0x5e>

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
   12ac4:	6804      	ldr	r4, [r0, #0]
   12ac6:	2c00      	cmp	r4, #0
   12ac8:	bf38      	it	cc
   12aca:	2400      	movcc	r4, #0
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   12acc:	3004      	adds	r0, #4
   12ace:	f002 fbb3 	bl	15238 <z_impl_k_sem_give>
		struct shutdown_thread *thread, *next_thread;

		/* Wake up all sleeping threads. */
		SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&shutdown_threads, thread,
   12ad2:	b134      	cbz	r4, 12ae2 <_nrf_modem_lib_init+0x5e>
   12ad4:	6823      	ldr	r3, [r4, #0]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   12ad6:	4620      	mov	r0, r4
   12ad8:	2b00      	cmp	r3, #0
   12ada:	bf38      	it	cc
   12adc:	2300      	movcc	r3, #0
   12ade:	461c      	mov	r4, r3
   12ae0:	e7f4      	b.n	12acc <_nrf_modem_lib_init+0x48>
	return z_impl_k_mutex_unlock(mutex);
   12ae2:	4804      	ldr	r0, [pc, #16]	; (12af4 <_nrf_modem_lib_init+0x70>)
   12ae4:	f002 fb62 	bl	151ac <z_impl_k_mutex_unlock>
		 */
		return 0;
	}

	return init_ret;
}
   12ae8:	2000      	movs	r0, #0
   12aea:	bd38      	pop	{r3, r4, r5, pc}
   12aec:	2000ccbf 	.word	0x2000ccbf
   12af0:	2000c95c 	.word	0x2000c95c
   12af4:	2000c964 	.word	0x2000c964
   12af8:	00017380 	.word	0x00017380
   12afc:	2000c958 	.word	0x2000c958

00012b00 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which nrf_modem_lib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   12b00:	b570      	push	{r4, r5, r6, lr}
	struct thread_monitor_entry *entry = thread_event_monitor;
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   12b02:	4c0d      	ldr	r4, [pc, #52]	; (12b38 <thread_monitor_entry_get+0x38>)
{
   12b04:	4602      	mov	r2, r0
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   12b06:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   12b08:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   12b0a:	4620      	mov	r0, r4
		entry_age = rpc_event_cnt - entry->cnt;
   12b0c:	4b0b      	ldr	r3, [pc, #44]	; (12b3c <thread_monitor_entry_get+0x3c>)
   12b0e:	681b      	ldr	r3, [r3, #0]
		if (entry->id == id) {
   12b10:	6801      	ldr	r1, [r0, #0]
   12b12:	4291      	cmp	r1, r2
   12b14:	d00e      	beq.n	12b34 <thread_monitor_entry_get+0x34>
		} else if (entry->id == 0) {
   12b16:	b151      	cbz	r1, 12b2e <thread_monitor_entry_get+0x2e>
		entry_age = rpc_event_cnt - entry->cnt;
   12b18:	6841      	ldr	r1, [r0, #4]
   12b1a:	1a59      	subs	r1, r3, r1
		if (entry_age > oldest_entry_age) {
   12b1c:	42b1      	cmp	r1, r6
   12b1e:	bfc4      	itt	gt
   12b20:	4604      	movgt	r4, r0
   12b22:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   12b24:	3d01      	subs	r5, #1
   12b26:	f100 0008 	add.w	r0, r0, #8
   12b2a:	d1f1      	bne.n	12b10 <thread_monitor_entry_get+0x10>
   12b2c:	4620      	mov	r0, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   12b2e:	3b01      	subs	r3, #1
	new_entry->id = id;
   12b30:	6002      	str	r2, [r0, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   12b32:	6043      	str	r3, [r0, #4]

	return new_entry;
}
   12b34:	bd70      	pop	{r4, r5, r6, pc}
   12b36:	bf00      	nop
   12b38:	2000c9d0 	.word	0x2000c9d0
   12b3c:	2000c9ac 	.word	0x2000c9ac

00012b40 <rpc_proxy_irq_handler>:
void nrf_modem_os_trace_irq_clear(void)
{
	NVIC_ClearPendingIRQ(TRACE_IRQ);
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   12b40:	4668      	mov	r0, sp
   12b42:	f020 0107 	bic.w	r1, r0, #7
   12b46:	468d      	mov	sp, r1
   12b48:	b519      	push	{r0, r3, r4, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   12b4a:	4b0f      	ldr	r3, [pc, #60]	; (12b88 <rpc_proxy_irq_handler+0x48>)
   12b4c:	e8d3 2fef 	ldaex	r2, [r3]
   12b50:	3201      	adds	r2, #1
   12b52:	e8c3 2fe1 	stlex	r1, r2, [r3]
   12b56:	2900      	cmp	r1, #0
   12b58:	d1f8      	bne.n	12b4c <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	nrf_modem_application_irq_handler();
   12b5a:	f001 f8f9 	bl	13d50 <nrf_modem_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   12b5e:	4b0b      	ldr	r3, [pc, #44]	; (12b8c <rpc_proxy_irq_handler+0x4c>)
   12b60:	681c      	ldr	r4, [r3, #0]
   12b62:	2c00      	cmp	r4, #0
   12b64:	bf38      	it	cc
   12b66:	2400      	movcc	r4, #0
   12b68:	b12c      	cbz	r4, 12b76 <rpc_proxy_irq_handler+0x36>
	z_impl_k_sem_give(sem);
   12b6a:	1d20      	adds	r0, r4, #4
   12b6c:	f002 fb64 	bl	15238 <z_impl_k_sem_give>
   12b70:	6824      	ldr	r4, [r4, #0]
   12b72:	2c00      	cmp	r4, #0
   12b74:	d1f8      	bne.n	12b68 <rpc_proxy_irq_handler+0x28>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   12b76:	f7fe fcf1 	bl	1155c <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING_ISR
	sys_trace_isr_exit();
#endif
	if (maybe_swap != 0) {
		z_arm_int_exit();
   12b7a:	f7fe fdcb 	bl	11714 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   12b7e:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   12b82:	4685      	mov	sp, r0
   12b84:	4770      	bx	lr
   12b86:	bf00      	nop
   12b88:	2000c9ac 	.word	0x2000c9ac
   12b8c:	2000c9c8 	.word	0x2000c9c8

00012b90 <nrf_modem_os_timedwait>:
{
   12b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12b94:	460c      	mov	r4, r1
   12b96:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
   12b98:	f004 f99f 	bl	16eda <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
   12b9c:	6823      	ldr	r3, [r4, #0]
   12b9e:	4680      	mov	r8, r0
   12ba0:	2b00      	cmp	r3, #0
   12ba2:	468a      	mov	sl, r1
   12ba4:	d103      	bne.n	12bae <nrf_modem_os_timedwait+0x1e>
	z_impl_k_yield();
   12ba6:	f002 fded 	bl	15784 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   12baa:	2074      	movs	r0, #116	; 0x74
   12bac:	e091      	b.n	12cd2 <nrf_modem_os_timedwait+0x142>
		*timeout = SYS_FOREVER_MS;
   12bae:	bfbc      	itt	lt
   12bb0:	f04f 33ff 	movlt.w	r3, #4294967295
   12bb4:	6023      	strlt	r3, [r4, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
   12bb6:	2201      	movs	r2, #1
   12bb8:	2100      	movs	r1, #0
   12bba:	a802      	add	r0, sp, #8
   12bbc:	f004 f84b 	bl	16c56 <z_impl_k_sem_init>
   12bc0:	ad01      	add	r5, sp, #4
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
   12bc2:	f04f 0320 	mov.w	r3, #32
   12bc6:	f3ef 8b11 	mrs	fp, BASEPRI
   12bca:	f383 8812 	msr	BASEPRI_MAX, r3
   12bce:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   12bd2:	f002 fe7f 	bl	158d4 <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   12bd6:	f7ff ff93 	bl	12b00 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   12bda:	4947      	ldr	r1, [pc, #284]	; (12cf8 <nrf_modem_os_timedwait+0x168>)
   12bdc:	6843      	ldr	r3, [r0, #4]
   12bde:	680a      	ldr	r2, [r1, #0]
   12be0:	4689      	mov	r9, r1
   12be2:	4293      	cmp	r3, r2
   12be4:	f04f 0300 	mov.w	r3, #0
   12be8:	d108      	bne.n	12bfc <nrf_modem_os_timedwait+0x6c>
	parent->next = child;
   12bea:	9301      	str	r3, [sp, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   12bec:	4b43      	ldr	r3, [pc, #268]	; (12cfc <nrf_modem_os_timedwait+0x16c>)
   12bee:	685a      	ldr	r2, [r3, #4]
   12bf0:	2a00      	cmp	r2, #0
   12bf2:	d171      	bne.n	12cd8 <nrf_modem_os_timedwait+0x148>
	list->head = node;
   12bf4:	e9c3 5500 	strd	r5, r5, [r3]
		allow_to_sleep = true;
   12bf8:	2301      	movs	r3, #1
}
   12bfa:	e000      	b.n	12bfe <nrf_modem_os_timedwait+0x6e>
	entry->cnt = rpc_event_cnt;
   12bfc:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   12bfe:	f38b 8811 	msr	BASEPRI, fp
   12c02:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   12c06:	2b00      	cmp	r3, #0
   12c08:	d062      	beq.n	12cd0 <nrf_modem_os_timedwait+0x140>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   12c0a:	6823      	ldr	r3, [r4, #0]
   12c0c:	1c5a      	adds	r2, r3, #1
   12c0e:	d066      	beq.n	12cde <nrf_modem_os_timedwait+0x14e>
   12c10:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
   12c14:	f240 30e7 	movw	r0, #999	; 0x3e7
   12c18:	2100      	movs	r1, #0
   12c1a:	ea23 7ce3 	bic.w	ip, r3, r3, asr #31
   12c1e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   12c22:	2300      	movs	r3, #0
   12c24:	fbce 010c 	smlal	r0, r1, lr, ip
   12c28:	f7fd fb08 	bl	1023c <__aeabi_uldivmod>
   12c2c:	4602      	mov	r2, r0
   12c2e:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
   12c30:	a802      	add	r0, sp, #8
   12c32:	f002 fb21 	bl	15278 <z_impl_k_sem_take>
	__asm__ volatile(
   12c36:	f04f 0320 	mov.w	r3, #32
   12c3a:	f3ef 8b11 	mrs	fp, BASEPRI
   12c3e:	f383 8812 	msr	BASEPRI_MAX, r3
   12c42:	f3bf 8f6f 	isb	sy
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   12c46:	2000      	movs	r0, #0
   12c48:	4b2c      	ldr	r3, [pc, #176]	; (12cfc <nrf_modem_os_timedwait+0x16c>)
   12c4a:	681a      	ldr	r2, [r3, #0]
   12c4c:	b15a      	cbz	r2, 12c66 <nrf_modem_os_timedwait+0xd6>
   12c4e:	42aa      	cmp	r2, r5
   12c50:	d14f      	bne.n	12cf2 <nrf_modem_os_timedwait+0x162>
Z_GENLIST_REMOVE(slist, snode)
   12c52:	9d01      	ldr	r5, [sp, #4]
   12c54:	2800      	cmp	r0, #0
   12c56:	d146      	bne.n	12ce6 <nrf_modem_os_timedwait+0x156>
   12c58:	6859      	ldr	r1, [r3, #4]
	list->head = node;
   12c5a:	601d      	str	r5, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   12c5c:	4291      	cmp	r1, r2
   12c5e:	d100      	bne.n	12c62 <nrf_modem_os_timedwait+0xd2>
	list->tail = node;
   12c60:	605d      	str	r5, [r3, #4]
	parent->next = child;
   12c62:	2300      	movs	r3, #0
   12c64:	9301      	str	r3, [sp, #4]
	return z_impl_z_current_get();
   12c66:	f002 fe35 	bl	158d4 <z_impl_z_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   12c6a:	f7ff ff49 	bl	12b00 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   12c6e:	f8d9 3000 	ldr.w	r3, [r9]
   12c72:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   12c74:	f38b 8811 	msr	BASEPRI, fp
   12c78:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
   12c7c:	6825      	ldr	r5, [r4, #0]
   12c7e:	1c6b      	adds	r3, r5, #1
   12c80:	d026      	beq.n	12cd0 <nrf_modem_os_timedwait+0x140>
	return z_impl_k_uptime_ticks();
   12c82:	f004 f92a 	bl	16eda <z_impl_k_uptime_ticks>
   12c86:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
   12c8a:	468e      	mov	lr, r1
   12c8c:	fba8 890c 	umull	r8, r9, r8, ip
   12c90:	fba0 010c 	umull	r0, r1, r0, ip
   12c94:	fb0c 990a 	mla	r9, ip, sl, r9
   12c98:	fb0c 110e 	mla	r1, ip, lr, r1
   12c9c:	ea4f 32d8 	mov.w	r2, r8, lsr #15
   12ca0:	ea42 4249 	orr.w	r2, r2, r9, lsl #17
	remaining = *timeout - k_uptime_delta(&start);
   12ca4:	1952      	adds	r2, r2, r5
   12ca6:	ea4f 33d9 	mov.w	r3, r9, lsr #15
   12caa:	eb43 73e5 	adc.w	r3, r3, r5, asr #31
   12cae:	0bc5      	lsrs	r5, r0, #15
   12cb0:	ea45 4541 	orr.w	r5, r5, r1, lsl #17
   12cb4:	1b56      	subs	r6, r2, r5
   12cb6:	ea4f 3cd1 	mov.w	ip, r1, lsr #15
   12cba:	eb63 070c 	sbc.w	r7, r3, ip
	*timeout = remaining > 0 ? remaining : 0;
   12cbe:	2e00      	cmp	r6, #0
   12cc0:	f177 0300 	sbcs.w	r3, r7, #0
   12cc4:	bfb8      	it	lt
   12cc6:	2600      	movlt	r6, #0
   12cc8:	6026      	str	r6, [r4, #0]
	if (*timeout == 0) {
   12cca:	2e00      	cmp	r6, #0
   12ccc:	f43f af6d 	beq.w	12baa <nrf_modem_os_timedwait+0x1a>
	return 0;
   12cd0:	2000      	movs	r0, #0
}
   12cd2:	b007      	add	sp, #28
   12cd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12cd8:	6015      	str	r5, [r2, #0]
	list->tail = node;
   12cda:	605d      	str	r5, [r3, #4]
   12cdc:	e78c      	b.n	12bf8 <nrf_modem_os_timedwait+0x68>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   12cde:	f04f 32ff 	mov.w	r2, #4294967295
   12ce2:	4613      	mov	r3, r2
   12ce4:	e7a4      	b.n	12c30 <nrf_modem_os_timedwait+0xa0>
	parent->next = child;
   12ce6:	6005      	str	r5, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   12ce8:	6859      	ldr	r1, [r3, #4]
   12cea:	4291      	cmp	r1, r2
	list->tail = node;
   12cec:	bf08      	it	eq
   12cee:	6058      	streq	r0, [r3, #4]
}
   12cf0:	e7b7      	b.n	12c62 <nrf_modem_os_timedwait+0xd2>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   12cf2:	4610      	mov	r0, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   12cf4:	6812      	ldr	r2, [r2, #0]
   12cf6:	e7a9      	b.n	12c4c <nrf_modem_os_timedwait+0xbc>
   12cf8:	2000c9ac 	.word	0x2000c9ac
   12cfc:	2000c9c8 	.word	0x2000c9c8

00012d00 <nrf_modem_os_sem_init>:
{
   12d00:	b470      	push	{r4, r5, r6}
	if (PART_OF_ARRAY(nrf_modem_os_sems, (struct k_sem *)*sem)) {
   12d02:	6804      	ldr	r4, [r0, #0]
   12d04:	4b09      	ldr	r3, [pc, #36]	; (12d2c <nrf_modem_os_sem_init+0x2c>)
   12d06:	b12c      	cbz	r4, 12d14 <nrf_modem_os_sem_init+0x14>
   12d08:	429c      	cmp	r4, r3
   12d0a:	d303      	bcc.n	12d14 <nrf_modem_os_sem_init+0x14>
   12d0c:	f103 0530 	add.w	r5, r3, #48	; 0x30
   12d10:	42ac      	cmp	r4, r5
   12d12:	d306      	bcc.n	12d22 <nrf_modem_os_sem_init+0x22>
	*sem = &nrf_modem_os_sems[used++];
   12d14:	4d06      	ldr	r5, [pc, #24]	; (12d30 <nrf_modem_os_sem_init+0x30>)
   12d16:	782c      	ldrb	r4, [r5, #0]
   12d18:	1c66      	adds	r6, r4, #1
   12d1a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   12d1e:	702e      	strb	r6, [r5, #0]
   12d20:	6003      	str	r3, [r0, #0]
	return k_sem_init((struct k_sem *)*sem, initial_count, limit);
   12d22:	6800      	ldr	r0, [r0, #0]
}
   12d24:	bc70      	pop	{r4, r5, r6}
	return z_impl_k_sem_init(sem, initial_count, limit);
   12d26:	f003 bf96 	b.w	16c56 <z_impl_k_sem_init>
   12d2a:	bf00      	nop
   12d2c:	2000c97c 	.word	0x2000c97c
   12d30:	2000ccc0 	.word	0x2000ccc0

00012d34 <nrf_modem_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12d34:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12d38:	4b01      	ldr	r3, [pc, #4]	; (12d40 <nrf_modem_os_application_irq_set+0xc>)
   12d3a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   12d3e:	4770      	bx	lr
   12d40:	e000e100 	.word	0xe000e100

00012d44 <nrf_modem_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12d44:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12d48:	4b01      	ldr	r3, [pc, #4]	; (12d50 <nrf_modem_os_application_irq_clear+0xc>)
   12d4a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   12d4e:	4770      	bx	lr
   12d50:	e000e100 	.word	0xe000e100

00012d54 <nrf_modem_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12d54:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   12d58:	4b01      	ldr	r3, [pc, #4]	; (12d60 <nrf_modem_os_trace_irq_set+0xc>)
   12d5a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   12d5e:	4770      	bx	lr
   12d60:	e000e100 	.word	0xe000e100

00012d64 <nrf_modem_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12d64:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   12d68:	4b01      	ldr	r3, [pc, #4]	; (12d70 <nrf_modem_os_trace_irq_clear+0xc>)
   12d6a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   12d6e:	4770      	bx	lr
   12d70:	e000e100 	.word	0xe000e100

00012d74 <nrf_modem_os_alloc>:
			   rpc_proxy_irq_handler, UNUSED_FLAGS);
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
}

void *nrf_modem_os_alloc(size_t bytes)
{
   12d74:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&library_heap, bytes, K_NO_WAIT);
   12d76:	2200      	movs	r2, #0
   12d78:	2300      	movs	r3, #0
   12d7a:	4801      	ldr	r0, [pc, #4]	; (12d80 <nrf_modem_os_alloc+0xc>)
   12d7c:	f003 bf30 	b.w	16be0 <k_heap_alloc>
   12d80:	2000c598 	.word	0x2000c598

00012d84 <nrf_modem_os_free>:
#endif
	return addr;
}

void nrf_modem_os_free(void *mem)
{
   12d84:	4601      	mov	r1, r0
	k_heap_free(&library_heap, mem);
   12d86:	4801      	ldr	r0, [pc, #4]	; (12d8c <nrf_modem_os_free+0x8>)
   12d88:	f003 bf34 	b.w	16bf4 <k_heap_free>
   12d8c:	2000c598 	.word	0x2000c598

00012d90 <nrf_modem_os_shm_tx_alloc>:
	LOG_INF("free(%p)", mem);
#endif
}

void *nrf_modem_os_shm_tx_alloc(size_t bytes)
{
   12d90:	4601      	mov	r1, r0
	void *addr = k_heap_alloc(&shmem_heap, bytes, K_NO_WAIT);
   12d92:	2200      	movs	r2, #0
   12d94:	2300      	movs	r3, #0
   12d96:	4801      	ldr	r0, [pc, #4]	; (12d9c <nrf_modem_os_shm_tx_alloc+0xc>)
   12d98:	f003 bf22 	b.w	16be0 <k_heap_alloc>
   12d9c:	2000c9b4 	.word	0x2000c9b4

00012da0 <nrf_modem_os_shm_tx_free>:
#endif
	return addr;
}

void nrf_modem_os_shm_tx_free(void *mem)
{
   12da0:	4601      	mov	r1, r0
	k_heap_free(&shmem_heap, mem);
   12da2:	4801      	ldr	r0, [pc, #4]	; (12da8 <nrf_modem_os_shm_tx_free+0x8>)
   12da4:	f003 bf26 	b.w	16bf4 <k_heap_free>
   12da8:	2000c9b4 	.word	0x2000c9b4

00012dac <nrf_modem_os_init>:
	}
}

/* This function is called by nrf_modem_init() */
void nrf_modem_os_init(void)
{
   12dac:	b510      	push	{r4, lr}
	list->head = NULL;
   12dae:	2400      	movs	r4, #0
   12db0:	4b0e      	ldr	r3, [pc, #56]	; (12dec <nrf_modem_os_init+0x40>)
	list->tail = NULL;
   12db2:	e9c3 4400 	strd	r4, r4, [r3]
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   12db6:	4b0e      	ldr	r3, [pc, #56]	; (12df0 <nrf_modem_os_init+0x44>)
   12db8:	e8d3 2fef 	ldaex	r2, [r3]
   12dbc:	e8c3 4fe1 	stlex	r1, r4, [r3]
   12dc0:	2900      	cmp	r1, #0
   12dc2:	d1f9      	bne.n	12db8 <nrf_modem_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   12dc4:	f003 fd8e 	bl	168e4 <read_task_create>
		trace_irq_init();
	}

#endif

	memset(&heap_diag, 0x00, sizeof(heap_diag));
   12dc8:	4621      	mov	r1, r4
   12dca:	2204      	movs	r2, #4
   12dcc:	4809      	ldr	r0, [pc, #36]	; (12df4 <nrf_modem_os_init+0x48>)
   12dce:	f003 fbe6 	bl	1659e <memset>
	memset(&shmem_diag, 0x00, sizeof(shmem_diag));
   12dd2:	4621      	mov	r1, r4
   12dd4:	2204      	movs	r2, #4
   12dd6:	4808      	ldr	r0, [pc, #32]	; (12df8 <nrf_modem_os_init+0x4c>)
   12dd8:	f003 fbe1 	bl	1659e <memset>
#ifdef CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIODIC
	k_work_init_delayable(&heap_task.work, diag_task);
	k_work_reschedule(&heap_task.work,
		K_MSEC(CONFIG_NRF_MODEM_LIB_HEAP_DUMP_PERIOD_MS));
#endif
}
   12ddc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_heap_init(&shmem_heap,
   12de0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   12de4:	4905      	ldr	r1, [pc, #20]	; (12dfc <nrf_modem_os_init+0x50>)
   12de6:	4806      	ldr	r0, [pc, #24]	; (12e00 <nrf_modem_os_init+0x54>)
   12de8:	f003 beab 	b.w	16b42 <k_heap_init>
   12dec:	2000c9c8 	.word	0x2000c9c8
   12df0:	2000c9ac 	.word	0x2000c9ac
   12df4:	2000c978 	.word	0x2000c978
   12df8:	2000c9b0 	.word	0x2000c9b0
   12dfc:	200084e8 	.word	0x200084e8
   12e00:	2000c9b4 	.word	0x2000c9b4

00012e04 <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(const struct device *dev)
{
   12e04:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);

	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   12e08:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
   12e0a:	4c21      	ldr	r4, [pc, #132]	; (12e90 <check_ext_api_requests+0x8c>)
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							uint32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const uint32_t ext_api_magic[] = {EXT_API_MAGIC};
   12e0c:	4e21      	ldr	r6, [pc, #132]	; (12e94 <check_ext_api_requests+0x90>)
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   12e0e:	f854 8c04 	ldr.w	r8, [r4, #-4]
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
   12e12:	f8df 9088 	ldr.w	r9, [pc, #136]	; 12e9c <check_ext_api_requests+0x98>
{
   12e16:	b085      	sub	sp, #20
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   12e18:	45a8      	cmp	r8, r5
   12e1a:	d803      	bhi.n	12e24 <check_ext_api_requests+0x20>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
   12e1c:	2000      	movs	r0, #0
   12e1e:	b005      	add	sp, #20
   12e20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((uint32_t)*(ext_api_req->ext_api))
   12e24:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12e26:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   12e2a:	681f      	ldr	r7, [r3, #0]
   12e2c:	ab01      	add	r3, sp, #4
   12e2e:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
   12e32:	220c      	movs	r2, #12
   12e34:	4619      	mov	r1, r3
   12e36:	4638      	mov	r0, r7
   12e38:	f003 fb96 	bl	16568 <memcmp>
   12e3c:	b990      	cbnz	r0, 12e64 <check_ext_api_requests+0x60>
   12e3e:	b18f      	cbz	r7, 12e64 <check_ext_api_requests+0x60>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   12e40:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const uint32_t req_id = ext_api_req->request.ext_api_id;
   12e42:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   12e44:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
   12e46:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   12e48:	4291      	cmp	r1, r2
   12e4a:	d10b      	bne.n	12e64 <check_ext_api_requests+0x60>
		&&  (ext_api->ext_api_version >= req_min_version)
   12e4c:	699a      	ldr	r2, [r3, #24]
	const uint32_t req_min_version = ext_api_req->request.ext_api_version;
   12e4e:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
   12e50:	4291      	cmp	r1, r2
   12e52:	d807      	bhi.n	12e64 <check_ext_api_requests+0x60>
	const uint32_t req_max_version = ext_api_req->ext_api_max_version;
   12e54:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
   12e56:	4291      	cmp	r1, r2
   12e58:	d904      	bls.n	12e64 <check_ext_api_requests+0x60>
	const uint32_t req_flags = ext_api_req->request.ext_api_flags;
   12e5a:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   12e5c:	695b      	ldr	r3, [r3, #20]
   12e5e:	ea32 0303 	bics.w	r3, r2, r3
   12e62:	d00a      	beq.n	12e7a <check_ext_api_requests+0x76>
		} else if (ext_api_req->required) {
   12e64:	6a27      	ldr	r7, [r4, #32]
   12e66:	b167      	cbz	r7, 12e82 <check_ext_api_requests+0x7e>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
   12e68:	480b      	ldr	r0, [pc, #44]	; (12e98 <check_ext_api_requests+0x94>)
   12e6a:	f003 f80c 	bl	15e86 <printk>
			k_panic();
   12e6e:	4040      	eors	r0, r0
   12e70:	f380 8811 	msr	BASEPRI, r0
   12e74:	f04f 0004 	mov.w	r0, #4
   12e78:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
   12e7a:	68e3      	ldr	r3, [r4, #12]
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   12e7c:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
   12e7e:	441c      	add	r4, r3
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   12e80:	e7ca      	b.n	12e18 <check_ext_api_requests+0x14>
			printk("WARNING: Optional EXT_API request not "
   12e82:	4648      	mov	r0, r9
   12e84:	f002 ffff 	bl	15e86 <printk>
			*ext_api_req->ext_api = NULL;
   12e88:	6a63      	ldr	r3, [r4, #36]	; 0x24
   12e8a:	601f      	str	r7, [r3, #0]
   12e8c:	e7f5      	b.n	12e7a <check_ext_api_requests+0x76>
   12e8e:	bf00      	nop
   12e90:	0001023c 	.word	0x0001023c
   12e94:	00017270 	.word	0x00017270
   12e98:	00017522 	.word	0x00017522
   12e9c:	0001754b 	.word	0x0001754b

00012ea0 <SystemInit>:
    static bool is_empty_word(uint32_t const volatile * word);
#endif

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK;
   12ea0:	4b01      	ldr	r3, [pc, #4]	; (12ea8 <SystemInit+0x8>)
   12ea2:	4a02      	ldr	r2, [pc, #8]	; (12eac <SystemInit+0xc>)
   12ea4:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   12ea6:	4770      	bx	lr
   12ea8:	2000c51c 	.word	0x2000c51c
   12eac:	03d09000 	.word	0x03d09000

00012eb0 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   12eb0:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   12eb2:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   12eb4:	6803      	ldr	r3, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   12eb6:	fab3 f283 	clz	r2, r3
        if (idx < 0) {
   12eba:	2a20      	cmp	r2, #32
        idx = 31 - NRF_CLZ(prev_mask);
   12ebc:	f1c2 041f 	rsb	r4, r2, #31
        if (idx < 0) {
   12ec0:	d010      	beq.n	12ee4 <nrfx_flag32_alloc+0x34>
        new_mask = prev_mask & ~NRFX_BIT(idx);
   12ec2:	fa05 f204 	lsl.w	r2, r5, r4
   12ec6:	ea23 0202 	bic.w	r2, r3, r2
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   12eca:	e8d0 6fef 	ldaex	r6, [r0]
   12ece:	429e      	cmp	r6, r3
   12ed0:	d104      	bne.n	12edc <nrfx_flag32_alloc+0x2c>
   12ed2:	e8c0 2fec 	stlex	ip, r2, [r0]
   12ed6:	f1bc 0f00 	cmp.w	ip, #0
   12eda:	d1f6      	bne.n	12eca <nrfx_flag32_alloc+0x1a>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   12edc:	d1ea      	bne.n	12eb4 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
   12ede:	4802      	ldr	r0, [pc, #8]	; (12ee8 <nrfx_flag32_alloc+0x38>)
    *p_flag = idx;
   12ee0:	700c      	strb	r4, [r1, #0]
}
   12ee2:	bd70      	pop	{r4, r5, r6, pc}
            return NRFX_ERROR_NO_MEM;
   12ee4:	4801      	ldr	r0, [pc, #4]	; (12eec <nrfx_flag32_alloc+0x3c>)
   12ee6:	e7fc      	b.n	12ee2 <nrfx_flag32_alloc+0x32>
   12ee8:	0bad0000 	.word	0x0bad0000
   12eec:	0bad0002 	.word	0x0bad0002

00012ef0 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   12ef0:	6803      	ldr	r3, [r0, #0]
{
   12ef2:	b510      	push	{r4, lr}
    if ((NRFX_BIT(flag) & *p_mask))
   12ef4:	40cb      	lsrs	r3, r1
   12ef6:	07db      	lsls	r3, r3, #31
   12ef8:	d411      	bmi.n	12f1e <nrfx_flag32_free+0x2e>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   12efa:	2301      	movs	r3, #1
   12efc:	fa03 f101 	lsl.w	r1, r3, r1
        prev_mask = *p_mask;
   12f00:	6803      	ldr	r3, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   12f02:	ea41 0203 	orr.w	r2, r1, r3
   12f06:	e8d0 4fef 	ldaex	r4, [r0]
   12f0a:	429c      	cmp	r4, r3
   12f0c:	d104      	bne.n	12f18 <nrfx_flag32_free+0x28>
   12f0e:	e8c0 2fec 	stlex	ip, r2, [r0]
   12f12:	f1bc 0f00 	cmp.w	ip, #0
   12f16:	d1f6      	bne.n	12f06 <nrfx_flag32_free+0x16>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   12f18:	d1f2      	bne.n	12f00 <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
   12f1a:	4802      	ldr	r0, [pc, #8]	; (12f24 <nrfx_flag32_free+0x34>)
}
   12f1c:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   12f1e:	4802      	ldr	r0, [pc, #8]	; (12f28 <nrfx_flag32_free+0x38>)
   12f20:	e7fc      	b.n	12f1c <nrfx_flag32_free+0x2c>
   12f22:	bf00      	nop
   12f24:	0bad0000 	.word	0x0bad0000
   12f28:	0bad0004 	.word	0x0bad0004

00012f2c <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   12f2c:	4b04      	ldr	r3, [pc, #16]	; (12f40 <nrfx_clock_init+0x14>)
   12f2e:	791a      	ldrb	r2, [r3, #4]
   12f30:	b922      	cbnz	r2, 12f3c <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   12f32:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   12f34:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   12f36:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   12f38:	4802      	ldr	r0, [pc, #8]	; (12f44 <nrfx_clock_init+0x18>)
   12f3a:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   12f3c:	4802      	ldr	r0, [pc, #8]	; (12f48 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   12f3e:	4770      	bx	lr
   12f40:	2000ca20 	.word	0x2000ca20
   12f44:	0bad0000 	.word	0x0bad0000
   12f48:	0bad000c 	.word	0x0bad000c

00012f4c <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   12f4c:	b110      	cbz	r0, 12f54 <nrfx_clock_start+0x8>
   12f4e:	2801      	cmp	r0, #1
   12f50:	d01e      	beq.n	12f90 <nrfx_clock_start+0x44>
   12f52:	4770      	bx	lr
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   12f54:	4b13      	ldr	r3, [pc, #76]	; (12fa4 <nrfx_clock_start+0x58>)
   12f56:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   12f5a:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
   12f5e:	f411 3f80 	tst.w	r1, #65536	; 0x10000
   12f62:	4619      	mov	r1, r3
   12f64:	d010      	beq.n	12f88 <nrfx_clock_start+0x3c>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
   12f66:	f002 0203 	and.w	r2, r2, #3
   12f6a:	2a02      	cmp	r2, #2
   12f6c:	d10c      	bne.n	12f88 <nrfx_clock_start+0x3c>
    p_reg->LFCLKSRC = (uint32_t)(source);
   12f6e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12f72:	2200      	movs	r2, #0
   12f74:	4b0c      	ldr	r3, [pc, #48]	; (12fa8 <nrfx_clock_start+0x5c>)
   12f76:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
   12f78:	2202      	movs	r2, #2
   12f7a:	681b      	ldr	r3, [r3, #0]
   12f7c:	4b09      	ldr	r3, [pc, #36]	; (12fa4 <nrfx_clock_start+0x58>)
   12f7e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12f82:	2201      	movs	r2, #1
   12f84:	609a      	str	r2, [r3, #8]
}
   12f86:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
   12f88:	2301      	movs	r3, #1
   12f8a:	f8c1 3518 	str.w	r3, [r1, #1304]	; 0x518
}
   12f8e:	e7f0      	b.n	12f72 <nrfx_clock_start+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12f90:	2200      	movs	r2, #0
   12f92:	4b06      	ldr	r3, [pc, #24]	; (12fac <nrfx_clock_start+0x60>)
   12f94:	601a      	str	r2, [r3, #0]
   12f96:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   12f98:	4b02      	ldr	r3, [pc, #8]	; (12fa4 <nrfx_clock_start+0x58>)
   12f9a:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12f9e:	6018      	str	r0, [r3, #0]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   12fa0:	4770      	bx	lr
   12fa2:	bf00      	nop
   12fa4:	40005000 	.word	0x40005000
   12fa8:	40005104 	.word	0x40005104
   12fac:	40005100 	.word	0x40005100

00012fb0 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
   12fb0:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   12fb2:	b110      	cbz	r0, 12fba <nrfx_clock_stop+0xa>
   12fb4:	2801      	cmp	r0, #1
   12fb6:	d016      	beq.n	12fe6 <nrfx_clock_stop+0x36>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   12fb8:	bd38      	pop	{r3, r4, r5, pc}
    p_reg->INTENCLR = mask;
   12fba:	2202      	movs	r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12fbc:	2101      	movs	r1, #1
   12fbe:	f242 7510 	movw	r5, #10000	; 0x2710
    p_reg->INTENCLR = mask;
   12fc2:	4c16      	ldr	r4, [pc, #88]	; (1301c <nrfx_clock_stop+0x6c>)
   12fc4:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12fc8:	4a15      	ldr	r2, [pc, #84]	; (13020 <nrfx_clock_stop+0x70>)
   12fca:	6010      	str	r0, [r2, #0]
   12fcc:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12fce:	4a15      	ldr	r2, [pc, #84]	; (13024 <nrfx_clock_stop+0x74>)
   12fd0:	6011      	str	r1, [r2, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   12fd2:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
   12fd6:	03db      	lsls	r3, r3, #15
   12fd8:	d5ee      	bpl.n	12fb8 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
   12fda:	2001      	movs	r0, #1
   12fdc:	f003 fc94 	bl	16908 <nrfx_busy_wait>
   12fe0:	3d01      	subs	r5, #1
   12fe2:	d1f6      	bne.n	12fd2 <nrfx_clock_stop+0x22>
   12fe4:	e7e8      	b.n	12fb8 <nrfx_clock_stop+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12fe6:	2200      	movs	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12fe8:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12fec:	4b0e      	ldr	r3, [pc, #56]	; (13028 <nrfx_clock_stop+0x78>)
    p_reg->INTENCLR = mask;
   12fee:	4c0b      	ldr	r4, [pc, #44]	; (1301c <nrfx_clock_stop+0x6c>)
   12ff0:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   12ff4:	601a      	str	r2, [r3, #0]
   12ff6:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   12ff8:	4b0c      	ldr	r3, [pc, #48]	; (1302c <nrfx_clock_stop+0x7c>)
   12ffa:	6018      	str	r0, [r3, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   12ffc:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   13000:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   13004:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   13008:	03d2      	lsls	r2, r2, #15
   1300a:	d5d5      	bpl.n	12fb8 <nrfx_clock_stop+0x8>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
   1300c:	2b00      	cmp	r3, #0
   1300e:	d0d3      	beq.n	12fb8 <nrfx_clock_stop+0x8>
   13010:	2001      	movs	r0, #1
   13012:	f003 fc79 	bl	16908 <nrfx_busy_wait>
   13016:	3d01      	subs	r5, #1
   13018:	d1f0      	bne.n	12ffc <nrfx_clock_stop+0x4c>
   1301a:	e7cd      	b.n	12fb8 <nrfx_clock_stop+0x8>
   1301c:	40005000 	.word	0x40005000
   13020:	40005104 	.word	0x40005104
   13024:	4000500c 	.word	0x4000500c
   13028:	40005100 	.word	0x40005100
   1302c:	40005004 	.word	0x40005004

00013030 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   13030:	4b15      	ldr	r3, [pc, #84]	; (13088 <nrfx_power_clock_irq_handler+0x58>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   13032:	b510      	push	{r4, lr}
   13034:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   13036:	b14a      	cbz	r2, 1304c <nrfx_power_clock_irq_handler+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   13038:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   1303a:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1303c:	6018      	str	r0, [r3, #0]
   1303e:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
   13040:	4b12      	ldr	r3, [pc, #72]	; (1308c <nrfx_power_clock_irq_handler+0x5c>)
   13042:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   13046:	4b12      	ldr	r3, [pc, #72]	; (13090 <nrfx_power_clock_irq_handler+0x60>)
   13048:	681b      	ldr	r3, [r3, #0]
   1304a:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1304c:	4b11      	ldr	r3, [pc, #68]	; (13094 <nrfx_power_clock_irq_handler+0x64>)
   1304e:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   13050:	b182      	cbz	r2, 13074 <nrfx_power_clock_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   13052:	2200      	movs	r2, #0
   13054:	601a      	str	r2, [r3, #0]
   13056:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   13058:	4b0c      	ldr	r3, [pc, #48]	; (1308c <nrfx_power_clock_irq_handler+0x5c>)
   1305a:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1305e:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   13062:	f002 0203 	and.w	r2, r2, #3
   13066:	2a01      	cmp	r2, #1
   13068:	f04f 0102 	mov.w	r1, #2
   1306c:	d103      	bne.n	13076 <nrfx_power_clock_irq_handler+0x46>
    p_reg->LFCLKSRC = (uint32_t)(source);
   1306e:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   13072:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
   13074:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
   13076:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   1307a:	4b05      	ldr	r3, [pc, #20]	; (13090 <nrfx_power_clock_irq_handler+0x60>)
   1307c:	2001      	movs	r0, #1
}
   1307e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   13082:	681b      	ldr	r3, [r3, #0]
   13084:	4718      	bx	r3
   13086:	bf00      	nop
   13088:	40005100 	.word	0x40005100
   1308c:	40005000 	.word	0x40005000
   13090:	2000ca20 	.word	0x2000ca20
   13094:	40005104 	.word	0x40005104

00013098 <nrfx_dppi_channel_alloc>:
    // Clear all allocated groups.
    m_allocated_groups = DPPI_AVAILABLE_GROUPS_MASK;
}

nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
   13098:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_allocated_channels, p_channel);
   1309a:	4801      	ldr	r0, [pc, #4]	; (130a0 <nrfx_dppi_channel_alloc+0x8>)
   1309c:	f7ff bf08 	b.w	12eb0 <nrfx_flag32_alloc>
   130a0:	2000c520 	.word	0x2000c520

000130a4 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   130a4:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   130a6:	4c0d      	ldr	r4, [pc, #52]	; (130dc <call_handler+0x38>)
   130a8:	f100 0308 	add.w	r3, r0, #8
   130ac:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   130b0:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   130b2:	05da      	lsls	r2, r3, #23
{
   130b4:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   130b6:	d507      	bpl.n	130c8 <call_handler+0x24>
   130b8:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   130bc:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   130c0:	6852      	ldr	r2, [r2, #4]
   130c2:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   130c6:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   130c8:	68a3      	ldr	r3, [r4, #8]
   130ca:	b12b      	cbz	r3, 130d8 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   130cc:	4631      	mov	r1, r6
   130ce:	4628      	mov	r0, r5
   130d0:	68e2      	ldr	r2, [r4, #12]
    }
}
   130d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   130d6:	4718      	bx	r3
}
   130d8:	bd70      	pop	{r4, r5, r6, pc}
   130da:	bf00      	nop
   130dc:	2000c524 	.word	0x2000c524

000130e0 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   130e0:	4b12      	ldr	r3, [pc, #72]	; (1312c <release_handler+0x4c>)
   130e2:	3008      	adds	r0, #8
   130e4:	f833 2010 	ldrh.w	r2, [r3, r0, lsl #1]
{
   130e8:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   130ea:	05d1      	lsls	r1, r2, #23
   130ec:	d51b      	bpl.n	13126 <release_handler+0x46>
   130ee:	f3c2 2143 	ubfx	r1, r2, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   130f2:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
   130f6:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   130fa:	2000      	movs	r0, #0
   130fc:	f103 0410 	add.w	r4, r3, #16
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   13100:	f834 2b02 	ldrh.w	r2, [r4], #2
   13104:	f412 7f80 	tst.w	r2, #256	; 0x100
   13108:	d003      	beq.n	13112 <release_handler+0x32>
   1310a:	f3c2 2243 	ubfx	r2, r2, #9, #4
   1310e:	4291      	cmp	r1, r2
   13110:	d009      	beq.n	13126 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   13112:	3001      	adds	r0, #1
   13114:	2820      	cmp	r0, #32
   13116:	d1f3      	bne.n	13100 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   13118:	2200      	movs	r2, #0
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   1311a:	4805      	ldr	r0, [pc, #20]	; (13130 <release_handler+0x50>)
}
   1311c:	bc10      	pop	{r4}
        m_cb.handlers[handler_id].handler = NULL;
   1311e:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   13122:	f7ff bee5 	b.w	12ef0 <nrfx_flag32_free>
}
   13126:	bc10      	pop	{r4}
   13128:	4770      	bx	lr
   1312a:	bf00      	nop
   1312c:	2000c524 	.word	0x2000c524
   13130:	2000c578 	.word	0x2000c578

00013134 <pin_handler_trigger_uninit>:
{
   13134:	b538      	push	{r3, r4, r5, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   13136:	4c0c      	ldr	r4, [pc, #48]	; (13168 <pin_handler_trigger_uninit+0x34>)
   13138:	f100 0508 	add.w	r5, r0, #8
   1313c:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
    if (pin_in_use_by_te(pin))
   13140:	069a      	lsls	r2, r3, #26
   13142:	d50a      	bpl.n	1315a <pin_handler_trigger_uninit+0x26>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   13144:	2200      	movs	r2, #0
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   13146:	0b5b      	lsrs	r3, r3, #13
   13148:	009b      	lsls	r3, r3, #2
   1314a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1314e:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   13152:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
   13156:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
    release_handler(pin);
   1315a:	f7ff ffc1 	bl	130e0 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   1315e:	2300      	movs	r3, #0
   13160:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   13164:	bd38      	pop	{r3, r4, r5, pc}
   13166:	bf00      	nop
   13168:	2000c524 	.word	0x2000c524

0001316c <nrf_gpio_cfg_sense_set>:
    *p_pin = pin_number & 0x1F;
   1316c:	f000 021f 	and.w	r2, r0, #31
   13170:	4805      	ldr	r0, [pc, #20]	; (13188 <nrf_gpio_cfg_sense_set+0x1c>)
   13172:	eb00 0082 	add.w	r0, r0, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   13176:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
    cnf &= ~to_update;
   1317a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   1317e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
   13182:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
}
   13186:	4770      	bx	lr
   13188:	40842500 	.word	0x40842500

0001318c <nrfx_gpiote_input_configure>:
{
   1318c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1318e:	4604      	mov	r4, r0
    if (p_input_config)
   13190:	b1f9      	cbz	r1, 131d2 <nrfx_gpiote_input_configure+0x46>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   13192:	4f4c      	ldr	r7, [pc, #304]	; (132c4 <nrfx_gpiote_input_configure+0x138>)
   13194:	f100 0c08 	add.w	ip, r0, #8
   13198:	f837 001c 	ldrh.w	r0, [r7, ip, lsl #1]
        if (pin_is_task_output(pin))
   1319c:	f000 0522 	and.w	r5, r0, #34	; 0x22
   131a0:	2d22      	cmp	r5, #34	; 0x22
   131a2:	d102      	bne.n	131aa <nrfx_gpiote_input_configure+0x1e>
            return NRFX_ERROR_INVALID_PARAM;
   131a4:	4848      	ldr	r0, [pc, #288]	; (132c8 <nrfx_gpiote_input_configure+0x13c>)
}
   131a6:	b003      	add	sp, #12
   131a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint32_t cnf = reg->PIN_CNF[pin_number];
   131aa:	4d48      	ldr	r5, [pc, #288]	; (132cc <nrfx_gpiote_input_configure+0x140>)
    *p_pin = pin_number & 0x1F;
   131ac:	f004 061f 	and.w	r6, r4, #31
   131b0:	eb05 0686 	add.w	r6, r5, r6, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number];
   131b4:	f8d6 5200 	ldr.w	r5, [r6, #512]	; 0x200
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   131b8:	7809      	ldrb	r1, [r1, #0]
    cnf &= ~to_update;
   131ba:	f025 050f 	bic.w	r5, r5, #15
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   131be:	f020 0002 	bic.w	r0, r0, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   131c2:	ea45 0181 	orr.w	r1, r5, r1, lsl #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   131c6:	f040 0001 	orr.w	r0, r0, #1
    reg->PIN_CNF[pin_number] = cnf;
   131ca:	f8c6 1200 	str.w	r1, [r6, #512]	; 0x200
   131ce:	f827 001c 	strh.w	r0, [r7, ip, lsl #1]
    if (p_trigger_config)
   131d2:	b192      	cbz	r2, 131fa <nrfx_gpiote_input_configure+0x6e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   131d4:	483b      	ldr	r0, [pc, #236]	; (132c4 <nrfx_gpiote_input_configure+0x138>)
   131d6:	f104 0608 	add.w	r6, r4, #8
   131da:	f830 1016 	ldrh.w	r1, [r0, r6, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   131de:	7815      	ldrb	r5, [r2, #0]
        if (pin_is_output(pin))
   131e0:	078f      	lsls	r7, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   131e2:	6852      	ldr	r2, [r2, #4]
        if (pin_is_output(pin))
   131e4:	d50c      	bpl.n	13200 <nrfx_gpiote_input_configure+0x74>
            if (use_evt)
   131e6:	2a00      	cmp	r2, #0
   131e8:	d1dc      	bne.n	131a4 <nrfx_gpiote_input_configure+0x18>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   131ea:	f830 2016 	ldrh.w	r2, [r0, r6, lsl #1]
   131ee:	f022 021c 	bic.w	r2, r2, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   131f2:	ea42 0585 	orr.w	r5, r2, r5, lsl #2
   131f6:	f820 5016 	strh.w	r5, [r0, r6, lsl #1]
    if (p_handler_config)
   131fa:	bbd3      	cbnz	r3, 13272 <nrfx_gpiote_input_configure+0xe6>
    return NRFX_SUCCESS;
   131fc:	4834      	ldr	r0, [pc, #208]	; (132d0 <nrfx_gpiote_input_configure+0x144>)
   131fe:	e7d2      	b.n	131a6 <nrfx_gpiote_input_configure+0x1a>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   13200:	f021 0120 	bic.w	r1, r1, #32
   13204:	04c9      	lsls	r1, r1, #19
   13206:	0cc9      	lsrs	r1, r1, #19
   13208:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
            if (use_evt)
   1320c:	2a00      	cmp	r2, #0
   1320e:	d0ec      	beq.n	131ea <nrfx_gpiote_input_configure+0x5e>
                if (!edge)
   13210:	2d03      	cmp	r5, #3
   13212:	d8c7      	bhi.n	131a4 <nrfx_gpiote_input_configure+0x18>
                uint8_t ch = *p_trigger_config->p_in_channel;
   13214:	f892 c000 	ldrb.w	ip, [r2]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   13218:	4662      	mov	r2, ip
   1321a:	0092      	lsls	r2, r2, #2
   1321c:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   13220:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   13224:	b925      	cbnz	r5, 13230 <nrfx_gpiote_input_configure+0xa4>
    p_reg->CONFIG[idx] = 0;
   13226:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   1322a:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
#endif
}
   1322e:	e7dc      	b.n	131ea <nrfx_gpiote_input_configure+0x5e>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   13230:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   13234:	ea4f 2e04 	mov.w	lr, r4, lsl #8
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   13238:	f027 0703 	bic.w	r7, r7, #3
   1323c:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   13240:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   13244:	f40e 5ef8 	and.w	lr, lr, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   13248:	f427 3747 	bic.w	r7, r7, #203776	; 0x31c00
   1324c:	f427 7740 	bic.w	r7, r7, #768	; 0x300
   13250:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   13254:	f8d2 7510 	ldr.w	r7, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   13258:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   1325c:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
   13260:	ea47 070e 	orr.w	r7, r7, lr
   13264:	f041 0120 	orr.w	r1, r1, #32
   13268:	f8c2 7510 	str.w	r7, [r2, #1296]	; 0x510
   1326c:	f820 1016 	strh.w	r1, [r0, r6, lsl #1]
   13270:	e7bb      	b.n	131ea <nrfx_gpiote_input_configure+0x5e>
    release_handler(pin);
   13272:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   13274:	e9d3 6700 	ldrd	r6, r7, [r3]
    release_handler(pin);
   13278:	f7ff ff32 	bl	130e0 <release_handler>
    if (!handler)
   1327c:	2e00      	cmp	r6, #0
   1327e:	d0bd      	beq.n	131fc <nrfx_gpiote_input_configure+0x70>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   13280:	4d10      	ldr	r5, [pc, #64]	; (132c4 <nrfx_gpiote_input_configure+0x138>)
   13282:	682b      	ldr	r3, [r5, #0]
   13284:	429e      	cmp	r6, r3
   13286:	d104      	bne.n	13292 <nrfx_gpiote_input_configure+0x106>
   13288:	686b      	ldr	r3, [r5, #4]
   1328a:	429f      	cmp	r7, r3
   1328c:	d101      	bne.n	13292 <nrfx_gpiote_input_configure+0x106>
   1328e:	2200      	movs	r2, #0
   13290:	e009      	b.n	132a6 <nrfx_gpiote_input_configure+0x11a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   13292:	4810      	ldr	r0, [pc, #64]	; (132d4 <nrfx_gpiote_input_configure+0x148>)
   13294:	f10d 0107 	add.w	r1, sp, #7
   13298:	f7ff fe0a 	bl	12eb0 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   1329c:	4b0c      	ldr	r3, [pc, #48]	; (132d0 <nrfx_gpiote_input_configure+0x144>)
   1329e:	4298      	cmp	r0, r3
   132a0:	d181      	bne.n	131a6 <nrfx_gpiote_input_configure+0x1a>
        handler_id = (int32_t)id;
   132a2:	f89d 2007 	ldrb.w	r2, [sp, #7]
    m_cb.handlers[handler_id].p_context = p_context;
   132a6:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   132aa:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   132ac:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   132ae:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   132b2:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   132b6:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   132ba:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   132be:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
   132c2:	e79b      	b.n	131fc <nrfx_gpiote_input_configure+0x70>
   132c4:	2000c524 	.word	0x2000c524
   132c8:	0bad0004 	.word	0x0bad0004
   132cc:	40842500 	.word	0x40842500
   132d0:	0bad0000 	.word	0x0bad0000
   132d4:	2000c578 	.word	0x2000c578

000132d8 <nrfx_gpiote_output_configure>:
{
   132d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    if (p_config)
   132dc:	2900      	cmp	r1, #0
   132de:	d044      	beq.n	1336a <nrfx_gpiote_output_configure+0x92>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   132e0:	4e43      	ldr	r6, [pc, #268]	; (133f0 <nrfx_gpiote_output_configure+0x118>)
   132e2:	f100 0c08 	add.w	ip, r0, #8
   132e6:	f836 501c 	ldrh.w	r5, [r6, ip, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   132ea:	07ab      	lsls	r3, r5, #30
   132ec:	d404      	bmi.n	132f8 <nrfx_gpiote_output_configure+0x20>
   132ee:	06af      	lsls	r7, r5, #26
   132f0:	d502      	bpl.n	132f8 <nrfx_gpiote_output_configure+0x20>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   132f2:	4840      	ldr	r0, [pc, #256]	; (133f4 <nrfx_gpiote_output_configure+0x11c>)
}
   132f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   132f8:	f015 0f1c 	tst.w	r5, #28
   132fc:	d002      	beq.n	13304 <nrfx_gpiote_output_configure+0x2c>
   132fe:	784b      	ldrb	r3, [r1, #1]
   13300:	2b01      	cmp	r3, #1
   13302:	d0f6      	beq.n	132f2 <nrfx_gpiote_output_configure+0x1a>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   13304:	4b3c      	ldr	r3, [pc, #240]	; (133f8 <nrfx_gpiote_output_configure+0x120>)
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   13306:	f111 0e01 	adds.w	lr, r1, #1
    *p_pin = pin_number & 0x1F;
   1330a:	f000 071f 	and.w	r7, r0, #31
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   1330e:	bf14      	ite	ne
   13310:	2402      	movne	r4, #2
   13312:	2400      	moveq	r4, #0
   13314:	eb03 0787 	add.w	r7, r3, r7, lsl #2
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   13318:	1c8b      	adds	r3, r1, #2
   1331a:	bf14      	ite	ne
   1331c:	f04f 090c 	movne.w	r9, #12
   13320:	f04f 0900 	moveq.w	r9, #0
   13324:	ea44 0409 	orr.w	r4, r4, r9
    uint32_t cnf = reg->PIN_CNF[pin_number];
   13328:	f8d7 8200 	ldr.w	r8, [r7, #512]	; 0x200
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   1332c:	f444 64e0 	orr.w	r4, r4, #1792	; 0x700
   13330:	f044 0401 	orr.w	r4, r4, #1
    cnf &= ~to_update;
   13334:	ea28 0804 	bic.w	r8, r8, r4
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   13338:	f1be 0f00 	cmp.w	lr, #0
   1333c:	d003      	beq.n	13346 <nrfx_gpiote_output_configure+0x6e>
   1333e:	f891 e001 	ldrb.w	lr, [r1, #1]
   13342:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   13346:	b10b      	cbz	r3, 1334c <nrfx_gpiote_output_configure+0x74>
   13348:	788c      	ldrb	r4, [r1, #2]
   1334a:	00a3      	lsls	r3, r4, #2
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   1334c:	7809      	ldrb	r1, [r1, #0]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   1334e:	f045 0503 	orr.w	r5, r5, #3
   13352:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   13356:	ea43 0308 	orr.w	r3, r3, r8
   1335a:	ea43 030e 	orr.w	r3, r3, lr
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   1335e:	f043 0301 	orr.w	r3, r3, #1
    reg->PIN_CNF[pin_number] = cnf;
   13362:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200
   13366:	f826 501c 	strh.w	r5, [r6, ip, lsl #1]
    if (p_task_config)
   1336a:	b90a      	cbnz	r2, 13370 <nrfx_gpiote_output_configure+0x98>
    return NRFX_SUCCESS;
   1336c:	4823      	ldr	r0, [pc, #140]	; (133fc <nrfx_gpiote_output_configure+0x124>)
   1336e:	e7c1      	b.n	132f4 <nrfx_gpiote_output_configure+0x1c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   13370:	4d1f      	ldr	r5, [pc, #124]	; (133f0 <nrfx_gpiote_output_configure+0x118>)
   13372:	f100 0608 	add.w	r6, r0, #8
   13376:	f835 4016 	ldrh.w	r4, [r5, r6, lsl #1]
        if (pin_is_input(pin))
   1337a:	07a3      	lsls	r3, r4, #30
   1337c:	d5b9      	bpl.n	132f2 <nrfx_gpiote_output_configure+0x1a>
    p_reg->CONFIG[idx] = 0;
   1337e:	2300      	movs	r3, #0
        uint32_t ch = p_task_config->task_ch;
   13380:	7817      	ldrb	r7, [r2, #0]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   13382:	f024 0420 	bic.w	r4, r4, #32
   13386:	00b9      	lsls	r1, r7, #2
   13388:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   1338c:	04e4      	lsls	r4, r4, #19
   1338e:	f501 3144 	add.w	r1, r1, #200704	; 0x31000
   13392:	0ce4      	lsrs	r4, r4, #19
   13394:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   13398:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
    p_reg->CONFIG[idx] = 0;
   1339c:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   133a0:	f892 c001 	ldrb.w	ip, [r2, #1]
   133a4:	f1bc 0f00 	cmp.w	ip, #0
   133a8:	d0e0      	beq.n	1336c <nrfx_gpiote_output_configure+0x94>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   133aa:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
   133ae:	7892      	ldrb	r2, [r2, #2]
   133b0:	f423 1398 	bic.w	r3, r3, #1245184	; 0x130000
   133b4:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   133b8:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   133bc:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   133c0:	0203      	lsls	r3, r0, #8
   133c2:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   133c6:	ea4f 400c 	mov.w	r0, ip, lsl #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   133ca:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   133ce:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   133d2:	0512      	lsls	r2, r2, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   133d4:	4303      	orrs	r3, r0
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   133d6:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   133da:	ea44 3447 	orr.w	r4, r4, r7, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   133de:	4313      	orrs	r3, r2
   133e0:	f044 0420 	orr.w	r4, r4, #32
   133e4:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   133e8:	f825 4016 	strh.w	r4, [r5, r6, lsl #1]
   133ec:	e7be      	b.n	1336c <nrfx_gpiote_output_configure+0x94>
   133ee:	bf00      	nop
   133f0:	2000c524 	.word	0x2000c524
   133f4:	0bad0004 	.word	0x0bad0004
   133f8:	40842500 	.word	0x40842500
   133fc:	0bad0000 	.word	0x0bad0000

00013400 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   13400:	4b01      	ldr	r3, [pc, #4]	; (13408 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   13402:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   13406:	4770      	bx	lr
   13408:	2000c524 	.word	0x2000c524

0001340c <nrfx_gpiote_channel_get>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   1340c:	4b05      	ldr	r3, [pc, #20]	; (13424 <nrfx_gpiote_channel_get+0x18>)
   1340e:	3008      	adds	r0, #8
   13410:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    if (pin_in_use_by_te(pin))
   13414:	069a      	lsls	r2, r3, #26
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   13416:	bf43      	ittte	mi
   13418:	0b5b      	lsrmi	r3, r3, #13
        return NRFX_SUCCESS;
   1341a:	4803      	ldrmi	r0, [pc, #12]	; (13428 <nrfx_gpiote_channel_get+0x1c>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   1341c:	700b      	strbmi	r3, [r1, #0]
        return NRFX_ERROR_INVALID_PARAM;
   1341e:	4803      	ldrpl	r0, [pc, #12]	; (1342c <nrfx_gpiote_channel_get+0x20>)
}
   13420:	4770      	bx	lr
   13422:	bf00      	nop
   13424:	2000c524 	.word	0x2000c524
   13428:	0bad0000 	.word	0x0bad0000
   1342c:	0bad0004 	.word	0x0bad0004

00013430 <nrfx_gpiote_init>:
{
   13430:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   13432:	4c0e      	ldr	r4, [pc, #56]	; (1346c <nrfx_gpiote_init+0x3c>)
   13434:	f894 5058 	ldrb.w	r5, [r4, #88]	; 0x58
   13438:	b9b5      	cbnz	r5, 13468 <nrfx_gpiote_init+0x38>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   1343a:	2240      	movs	r2, #64	; 0x40
   1343c:	4629      	mov	r1, r5
   1343e:	f104 0010 	add.w	r0, r4, #16
   13442:	f003 f8ac 	bl	1659e <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   13446:	2031      	movs	r0, #49	; 0x31
   13448:	f7fe f854 	bl	114f4 <arch_irq_enable>
    p_reg->INTENSET = mask;
   1344c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   13450:	4b07      	ldr	r3, [pc, #28]	; (13470 <nrfx_gpiote_init+0x40>)
    return err_code;
   13452:	4808      	ldr	r0, [pc, #32]	; (13474 <nrfx_gpiote_init+0x44>)
   13454:	601d      	str	r5, [r3, #0]
   13456:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
   13458:	4b07      	ldr	r3, [pc, #28]	; (13478 <nrfx_gpiote_init+0x48>)
   1345a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   1345e:	2301      	movs	r3, #1
   13460:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   13464:	6563      	str	r3, [r4, #84]	; 0x54
}
   13466:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   13468:	4804      	ldr	r0, [pc, #16]	; (1347c <nrfx_gpiote_init+0x4c>)
   1346a:	e7fc      	b.n	13466 <nrfx_gpiote_init+0x36>
   1346c:	2000c524 	.word	0x2000c524
   13470:	4003117c 	.word	0x4003117c
   13474:	0bad0000 	.word	0x0bad0000
   13478:	40031000 	.word	0x40031000
   1347c:	0bad0005 	.word	0x0bad0005

00013480 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   13480:	4b03      	ldr	r3, [pc, #12]	; (13490 <nrfx_gpiote_is_init+0x10>)
   13482:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
   13486:	3800      	subs	r0, #0
   13488:	bf18      	it	ne
   1348a:	2001      	movne	r0, #1
   1348c:	4770      	bx	lr
   1348e:	bf00      	nop
   13490:	2000c524 	.word	0x2000c524

00013494 <nrfx_gpiote_channel_free>:
{
   13494:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   13496:	4801      	ldr	r0, [pc, #4]	; (1349c <nrfx_gpiote_channel_free+0x8>)
   13498:	f7ff bd2a 	b.w	12ef0 <nrfx_flag32_free>
   1349c:	2000c574 	.word	0x2000c574

000134a0 <nrfx_gpiote_channel_alloc>:
{
   134a0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   134a2:	4801      	ldr	r0, [pc, #4]	; (134a8 <nrfx_gpiote_channel_alloc+0x8>)
   134a4:	f7ff bd04 	b.w	12eb0 <nrfx_flag32_alloc>
   134a8:	2000c574 	.word	0x2000c574

000134ac <nrfx_gpiote_trigger_enable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   134ac:	4b1b      	ldr	r3, [pc, #108]	; (1351c <nrfx_gpiote_trigger_enable+0x70>)
   134ae:	f100 0208 	add.w	r2, r0, #8
   134b2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   134b6:	b410      	push	{r4}
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   134b8:	069a      	lsls	r2, r3, #26
   134ba:	d51a      	bpl.n	134f2 <nrfx_gpiote_trigger_enable+0x46>
   134bc:	f013 0402 	ands.w	r4, r3, #2
   134c0:	d117      	bne.n	134f2 <nrfx_gpiote_trigger_enable+0x46>
    return ((uint32_t)p_reg + event);
   134c2:	4817      	ldr	r0, [pc, #92]	; (13520 <nrfx_gpiote_trigger_enable+0x74>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   134c4:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   134c6:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   134c8:	5084      	str	r4, [r0, r2]
   134ca:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   134cc:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   134d0:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   134d4:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   134d8:	f040 0001 	orr.w	r0, r0, #1
   134dc:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   134e0:	b129      	cbz	r1, 134ee <nrfx_gpiote_trigger_enable+0x42>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   134e2:	2201      	movs	r2, #1
   134e4:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   134e8:	4a0e      	ldr	r2, [pc, #56]	; (13524 <nrfx_gpiote_trigger_enable+0x78>)
   134ea:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   134ee:	bc10      	pop	{r4}
   134f0:	4770      	bx	lr
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   134f2:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   134f6:	2b04      	cmp	r3, #4
   134f8:	d00c      	beq.n	13514 <nrfx_gpiote_trigger_enable+0x68>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   134fa:	2b05      	cmp	r3, #5
   134fc:	d00c      	beq.n	13518 <nrfx_gpiote_trigger_enable+0x6c>
    return p_reg->IN;
   134fe:	4b0a      	ldr	r3, [pc, #40]	; (13528 <nrfx_gpiote_trigger_enable+0x7c>)
   13500:	6919      	ldr	r1, [r3, #16]
    *p_pin = pin_number & 0x1F;
   13502:	f000 031f 	and.w	r3, r0, #31
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   13506:	40d9      	lsrs	r1, r3
   13508:	f001 0101 	and.w	r1, r1, #1
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   1350c:	3102      	adds	r1, #2
}
   1350e:	bc10      	pop	{r4}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   13510:	f7ff be2c 	b.w	1316c <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   13514:	2103      	movs	r1, #3
   13516:	e7fa      	b.n	1350e <nrfx_gpiote_trigger_enable+0x62>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   13518:	2102      	movs	r1, #2
   1351a:	e7f8      	b.n	1350e <nrfx_gpiote_trigger_enable+0x62>
   1351c:	2000c524 	.word	0x2000c524
   13520:	40031100 	.word	0x40031100
   13524:	40031000 	.word	0x40031000
   13528:	40842500 	.word	0x40842500

0001352c <nrfx_gpiote_trigger_disable>:
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   1352c:	4b0e      	ldr	r3, [pc, #56]	; (13568 <nrfx_gpiote_trigger_disable+0x3c>)
   1352e:	f100 0208 	add.w	r2, r0, #8
   13532:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   13536:	0699      	lsls	r1, r3, #26
   13538:	d513      	bpl.n	13562 <nrfx_gpiote_trigger_disable+0x36>
   1353a:	079a      	lsls	r2, r3, #30
   1353c:	d411      	bmi.n	13562 <nrfx_gpiote_trigger_disable+0x36>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   1353e:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   13540:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   13542:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   13544:	4909      	ldr	r1, [pc, #36]	; (1356c <nrfx_gpiote_trigger_disable+0x40>)
   13546:	009b      	lsls	r3, r3, #2
   13548:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1354c:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   13550:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   13554:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   13558:	f022 0203 	bic.w	r2, r2, #3
   1355c:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   13560:	4770      	bx	lr
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   13562:	2100      	movs	r1, #0
   13564:	f7ff be02 	b.w	1316c <nrf_gpio_cfg_sense_set>
   13568:	2000c524 	.word	0x2000c524
   1356c:	40031000 	.word	0x40031000

00013570 <nrfx_gpiote_pin_uninit>:
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   13570:	4b0c      	ldr	r3, [pc, #48]	; (135a4 <nrfx_gpiote_pin_uninit+0x34>)
   13572:	f100 0208 	add.w	r2, r0, #8
   13576:	f813 3012 	ldrb.w	r3, [r3, r2, lsl #1]
{
   1357a:	b510      	push	{r4, lr}
    if (!pin_in_use(pin))
   1357c:	07db      	lsls	r3, r3, #31
{
   1357e:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   13580:	d50d      	bpl.n	1359e <nrfx_gpiote_pin_uninit+0x2e>
    nrfx_gpiote_trigger_disable(pin);
   13582:	f7ff ffd3 	bl	1352c <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   13586:	4620      	mov	r0, r4
   13588:	f7ff fdd4 	bl	13134 <pin_handler_trigger_uninit>
    reg->PIN_CNF[pin_number] = cnf;
   1358c:	2202      	movs	r2, #2
   1358e:	4b06      	ldr	r3, [pc, #24]	; (135a8 <nrfx_gpiote_pin_uninit+0x38>)
    *p_pin = pin_number & 0x1F;
   13590:	f004 041f 	and.w	r4, r4, #31
    reg->PIN_CNF[pin_number] = cnf;
   13594:	3480      	adds	r4, #128	; 0x80
   13596:	4805      	ldr	r0, [pc, #20]	; (135ac <nrfx_gpiote_pin_uninit+0x3c>)
   13598:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
}
   1359c:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   1359e:	4804      	ldr	r0, [pc, #16]	; (135b0 <nrfx_gpiote_pin_uninit+0x40>)
   135a0:	e7fc      	b.n	1359c <nrfx_gpiote_pin_uninit+0x2c>
   135a2:	bf00      	nop
   135a4:	2000c524 	.word	0x2000c524
   135a8:	40842500 	.word	0x40842500
   135ac:	0bad0000 	.word	0x0bad0000
   135b0:	0bad0004 	.word	0x0bad0004

000135b4 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   135b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   135b8:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   135ba:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   135bc:	4634      	mov	r4, r6
{
   135be:	4b4b      	ldr	r3, [pc, #300]	; (136ec <nrfx_gpiote_irq_handler+0x138>)
    return p_reg->INTENSET & mask;
   135c0:	484b      	ldr	r0, [pc, #300]	; (136f0 <nrfx_gpiote_irq_handler+0x13c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   135c2:	494c      	ldr	r1, [pc, #304]	; (136f4 <nrfx_gpiote_irq_handler+0x140>)
{
   135c4:	b085      	sub	sp, #20
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   135c6:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   135c8:	b135      	cbz	r5, 135d8 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   135ca:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   135ce:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   135d0:	bf1e      	ittt	ne
   135d2:	601c      	strne	r4, [r3, #0]
   135d4:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   135d6:	4316      	orrne	r6, r2
        }
        mask <<= 1;
   135d8:	3304      	adds	r3, #4
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   135da:	428b      	cmp	r3, r1
        mask <<= 1;
   135dc:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   135e0:	d1f1      	bne.n	135c6 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   135e2:	4f45      	ldr	r7, [pc, #276]	; (136f8 <nrfx_gpiote_irq_handler+0x144>)
   135e4:	683b      	ldr	r3, [r7, #0]
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   135e6:	b183      	cbz	r3, 1360a <nrfx_gpiote_irq_handler+0x56>
        *p_masks = gpio_regs[i]->LATCH;
   135e8:	4d44      	ldr	r5, [pc, #272]	; (136fc <nrfx_gpiote_irq_handler+0x148>)
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   135ea:	f10d 080c 	add.w	r8, sp, #12
   135ee:	6a2b      	ldr	r3, [r5, #32]
   135f0:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   135f2:	622b      	str	r3, [r5, #32]
   135f4:	f04f 0901 	mov.w	r9, #1
            while (latch[i])
   135f8:	9803      	ldr	r0, [sp, #12]
   135fa:	b940      	cbnz	r0, 1360e <nrfx_gpiote_irq_handler+0x5a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   135fc:	6038      	str	r0, [r7, #0]
   135fe:	683b      	ldr	r3, [r7, #0]
        *p_masks = gpio_regs[i]->LATCH;
   13600:	6a2b      	ldr	r3, [r5, #32]
   13602:	9303      	str	r3, [sp, #12]
        gpio_regs[i]->LATCH = *p_masks;
   13604:	622b      	str	r3, [r5, #32]
        if (latch[port_idx])
   13606:	2b00      	cmp	r3, #0
   13608:	d1f4      	bne.n	135f4 <nrfx_gpiote_irq_handler+0x40>
        mask &= ~NRFX_BIT(ch);
   1360a:	2401      	movs	r4, #1
   1360c:	e069      	b.n	136e2 <nrfx_gpiote_irq_handler+0x12e>
                uint32_t pin = NRF_CTZ(latch[i]);
   1360e:	fa90 faa0 	rbit	sl, r0
   13612:	faba fa8a 	clz	sl, sl
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   13616:	4a3a      	ldr	r2, [pc, #232]	; (13700 <nrfx_gpiote_irq_handler+0x14c>)
   13618:	f10a 0308 	add.w	r3, sl, #8
   1361c:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   13620:	ea4f 0cda 	mov.w	ip, sl, lsr #3
    bit = BITMASK_RELBIT_GET(bit);
   13624:	f00a 0307 	and.w	r3, sl, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   13628:	fa09 f403 	lsl.w	r4, r9, r3
   1362c:	f818 300c 	ldrb.w	r3, [r8, ip]
   13630:	f3c1 0282 	ubfx	r2, r1, #2, #3
   13634:	ea23 0304 	bic.w	r3, r3, r4
   13638:	f808 300c 	strb.w	r3, [r8, ip]
   1363c:	eb05 038a 	add.w	r3, r5, sl, lsl #2
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   13640:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    if (is_level(trigger))
   13644:	06c8      	lsls	r0, r1, #27
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   13646:	4693      	mov	fp, r2
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   13648:	f3c4 4401 	ubfx	r4, r4, #16, #2
    if (is_level(trigger))
   1364c:	d518      	bpl.n	13680 <nrfx_gpiote_irq_handler+0xcc>
        call_handler(pin, trigger);
   1364e:	4611      	mov	r1, r2
   13650:	4650      	mov	r0, sl
   13652:	9301      	str	r3, [sp, #4]
   13654:	f7ff fd26 	bl	130a4 <call_handler>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   13658:	9b01      	ldr	r3, [sp, #4]
   1365a:	b2e4      	uxtb	r4, r4
   1365c:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
        if (nrf_gpio_pin_sense_get(pin) == sense)
   13660:	f3c3 4301 	ubfx	r3, r3, #16, #2
   13664:	429c      	cmp	r4, r3
   13666:	d107      	bne.n	13678 <nrfx_gpiote_irq_handler+0xc4>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   13668:	2100      	movs	r1, #0
   1366a:	4650      	mov	r0, sl
   1366c:	f7ff fd7e 	bl	1316c <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   13670:	4621      	mov	r1, r4
   13672:	4650      	mov	r0, sl
   13674:	f7ff fd7a 	bl	1316c <nrf_gpio_cfg_sense_set>
    reg->LATCH = (1 << pin_number);
   13678:	fa09 f00a 	lsl.w	r0, r9, sl
   1367c:	6228      	str	r0, [r5, #32]
}
   1367e:	e7bb      	b.n	135f8 <nrfx_gpiote_irq_handler+0x44>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   13680:	2c02      	cmp	r4, #2
        nrf_gpio_cfg_sense_set(pin, next_sense);
   13682:	bf0c      	ite	eq
   13684:	2103      	moveq	r1, #3
   13686:	2102      	movne	r1, #2
   13688:	4650      	mov	r0, sl
   1368a:	9201      	str	r2, [sp, #4]
   1368c:	f7ff fd6e 	bl	1316c <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   13690:	9a01      	ldr	r2, [sp, #4]
   13692:	2a03      	cmp	r2, #3
   13694:	d004      	beq.n	136a0 <nrfx_gpiote_irq_handler+0xec>
   13696:	2c02      	cmp	r4, #2
   13698:	d107      	bne.n	136aa <nrfx_gpiote_irq_handler+0xf6>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   1369a:	f1bb 0f01 	cmp.w	fp, #1
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   1369e:	d1eb      	bne.n	13678 <nrfx_gpiote_irq_handler+0xc4>
            call_handler(pin, trigger);
   136a0:	4659      	mov	r1, fp
   136a2:	4650      	mov	r0, sl
   136a4:	f7ff fcfe 	bl	130a4 <call_handler>
   136a8:	e7e6      	b.n	13678 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   136aa:	2c03      	cmp	r4, #3
   136ac:	d1e4      	bne.n	13678 <nrfx_gpiote_irq_handler+0xc4>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   136ae:	f1bb 0f02 	cmp.w	fp, #2
   136b2:	e7f4      	b.n	1369e <nrfx_gpiote_irq_handler+0xea>
        uint32_t ch = NRF_CTZ(mask);
   136b4:	fa96 f3a6 	rbit	r3, r6
   136b8:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   136bc:	fa04 f203 	lsl.w	r2, r4, r3
   136c0:	009b      	lsls	r3, r3, #2
   136c2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   136c6:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   136ca:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   136ce:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   136d2:	f3c0 2004 	ubfx	r0, r0, #8, #5
   136d6:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   136da:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   136de:	f7ff fce1 	bl	130a4 <call_handler>
    while (mask)
   136e2:	2e00      	cmp	r6, #0
   136e4:	d1e6      	bne.n	136b4 <nrfx_gpiote_irq_handler+0x100>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   136e6:	b005      	add	sp, #20
   136e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   136ec:	40031100 	.word	0x40031100
   136f0:	40031000 	.word	0x40031000
   136f4:	40031120 	.word	0x40031120
   136f8:	4003117c 	.word	0x4003117c
   136fc:	40842500 	.word	0x40842500
   13700:	2000c524 	.word	0x2000c524

00013704 <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
   13704:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   13706:	4c08      	ldr	r4, [pc, #32]	; (13728 <nrfx_ipc_init+0x24>)
{
   13708:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   1370a:	7923      	ldrb	r3, [r4, #4]
{
   1370c:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   1370e:	b943      	cbnz	r3, 13722 <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
   13710:	202a      	movs	r0, #42	; 0x2a
   13712:	f7fd feef 	bl	114f4 <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   13716:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
   13718:	4804      	ldr	r0, [pc, #16]	; (1372c <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
   1371a:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
   1371c:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
   1371e:	60a5      	str	r5, [r4, #8]
}
   13720:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   13722:	4803      	ldr	r0, [pc, #12]	; (13730 <nrfx_ipc_init+0x2c>)
   13724:	e7fc      	b.n	13720 <nrfx_ipc_init+0x1c>
   13726:	bf00      	nop
   13728:	2000ca28 	.word	0x2000ca28
   1372c:	0bad0000 	.word	0x0bad0000
   13730:	0bad000c 	.word	0x0bad000c

00013734 <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
   13734:	2300      	movs	r3, #0
{
   13736:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
   13738:	4a0d      	ldr	r2, [pc, #52]	; (13770 <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
   1373a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   1373e:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
   13742:	3301      	adds	r3, #1
   13744:	2b08      	cmp	r3, #8
   13746:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   1374a:	d1f6      	bne.n	1373a <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
   1374c:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
   1374e:	4a08      	ldr	r2, [pc, #32]	; (13770 <nrfx_ipc_config_load+0x3c>)
   13750:	f100 0120 	add.w	r1, r0, #32
   13754:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
   13758:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
   1375c:	3301      	adds	r3, #1
   1375e:	2b08      	cmp	r3, #8
   13760:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
   13764:	d1f6      	bne.n	13754 <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
   13766:	6c03      	ldr	r3, [r0, #64]	; 0x40
    p_reg->INTENSET = mask;
   13768:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   1376c:	bd30      	pop	{r4, r5, pc}
   1376e:	bf00      	nop
   13770:	4002a000 	.word	0x4002a000

00013774 <nrfx_ipc_uninit>:
    p_reg->SEND_CNF[index] = channels_mask;
   13774:	2300      	movs	r3, #0
   13776:	4a14      	ldr	r2, [pc, #80]	; (137c8 <nrfx_ipc_uninit+0x54>)
   13778:	4914      	ldr	r1, [pc, #80]	; (137cc <nrfx_ipc_uninit+0x58>)
   1377a:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   1377e:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   13782:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
   13786:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
   1378a:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
   1378e:	f8c2 3520 	str.w	r3, [r2, #1312]	; 0x520
   13792:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
   13796:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    p_reg->RECEIVE_CNF[index] = channels_mask;
   1379a:	f8c1 3590 	str.w	r3, [r1, #1424]	; 0x590
   1379e:	f8c2 3590 	str.w	r3, [r2, #1424]	; 0x590
   137a2:	f8c2 3594 	str.w	r3, [r2, #1428]	; 0x594
   137a6:	f8c2 3598 	str.w	r3, [r2, #1432]	; 0x598
   137aa:	f8c2 359c 	str.w	r3, [r2, #1436]	; 0x59c
   137ae:	f8c2 35a0 	str.w	r3, [r2, #1440]	; 0x5a0
   137b2:	f8c2 35a4 	str.w	r3, [r2, #1444]	; 0x5a4
   137b6:	f8c2 35a8 	str.w	r3, [r2, #1448]	; 0x5a8
    p_reg->INTENCLR = mask;
   137ba:	f04f 32ff 	mov.w	r2, #4294967295
   137be:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, 0);
    }

    nrf_ipc_int_disable(NRF_IPC, 0xFFFFFFFF);
    m_ipc_cb.state = NRFX_DRV_STATE_UNINITIALIZED;
   137c2:	4a03      	ldr	r2, [pc, #12]	; (137d0 <nrfx_ipc_uninit+0x5c>)
   137c4:	7113      	strb	r3, [r2, #4]
}
   137c6:	4770      	bx	lr
   137c8:	4002a004 	.word	0x4002a004
   137cc:	4002a000 	.word	0x4002a000
   137d0:	2000ca28 	.word	0x2000ca28

000137d4 <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
   137d4:	4b0c      	ldr	r3, [pc, #48]	; (13808 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
   137d6:	b430      	push	{r4, r5}
   137d8:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = NRF_CTZ(bitmask);
        bitmask &= ~(1UL << event_idx);
   137dc:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
   137de:	4603      	mov	r3, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   137e0:	2500      	movs	r5, #0
    while (bitmask)
   137e2:	b923      	cbnz	r3, 137ee <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
   137e4:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
   137e6:	4b09      	ldr	r3, [pc, #36]	; (1380c <nrfx_ipc_irq_handler+0x38>)
   137e8:	681a      	ldr	r2, [r3, #0]
   137ea:	6899      	ldr	r1, [r3, #8]
   137ec:	4710      	bx	r2
        uint8_t event_idx = NRF_CTZ(bitmask);
   137ee:	fa93 f2a3 	rbit	r2, r3
   137f2:	fab2 f282 	clz	r2, r2
        bitmask &= ~(1UL << event_idx);
   137f6:	fa04 f102 	lsl.w	r1, r4, r2
   137fa:	ea23 0301 	bic.w	r3, r3, r1
   137fe:	4904      	ldr	r1, [pc, #16]	; (13810 <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
   13800:	0092      	lsls	r2, r2, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   13802:	508d      	str	r5, [r1, r2]
}
   13804:	e7ed      	b.n	137e2 <nrfx_ipc_irq_handler+0xe>
   13806:	bf00      	nop
   13808:	4002a000 	.word	0x4002a000
   1380c:	2000ca28 	.word	0x2000ca28
   13810:	4002a100 	.word	0x4002a100

00013814 <rpc_handle_data_message>:
   13814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13818:	4680      	mov	r8, r0
   1381a:	4604      	mov	r4, r0
   1381c:	2700      	movs	r7, #0
   1381e:	f858 6b08 	ldr.w	r6, [r8], #8
   13822:	4d0c      	ldr	r5, [pc, #48]	; (13854 <rpc_handle_data_message+0x40>)
   13824:	b2f6      	uxtb	r6, r6
   13826:	782b      	ldrb	r3, [r5, #0]
   13828:	42b3      	cmp	r3, r6
   1382a:	d00a      	beq.n	13842 <rpc_handle_data_message+0x2e>
   1382c:	3701      	adds	r7, #1
   1382e:	2f04      	cmp	r7, #4
   13830:	f105 050c 	add.w	r5, r5, #12
   13834:	d1f7      	bne.n	13826 <rpc_handle_data_message+0x12>
   13836:	68a0      	ldr	r0, [r4, #8]
   13838:	b150      	cbz	r0, 13850 <rpc_handle_data_message+0x3c>
   1383a:	f003 f8b4 	bl	169a6 <rpc_transport_peer_data_free>
   1383e:	2000      	movs	r0, #0
   13840:	e006      	b.n	13850 <rpc_handle_data_message+0x3c>
   13842:	6821      	ldr	r1, [r4, #0]
   13844:	4640      	mov	r0, r8
   13846:	686b      	ldr	r3, [r5, #4]
   13848:	0c09      	lsrs	r1, r1, #16
   1384a:	4798      	blx	r3
   1384c:	2802      	cmp	r0, #2
   1384e:	d0ed      	beq.n	1382c <rpc_handle_data_message+0x18>
   13850:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13854:	000173a4 	.word	0x000173a4

00013858 <trace_write>:
   13858:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1385c:	4f53      	ldr	r7, [pc, #332]	; (139ac <trace_write+0x154>)
   1385e:	4605      	mov	r5, r0
   13860:	2100      	movs	r1, #0
   13862:	6838      	ldr	r0, [r7, #0]
   13864:	f003 f81b 	bl	1689e <nrf_modem_os_sem_take>
   13868:	4604      	mov	r4, r0
   1386a:	2800      	cmp	r0, #0
   1386c:	d14c      	bne.n	13908 <trace_write+0xb0>
   1386e:	782b      	ldrb	r3, [r5, #0]
   13870:	f8d5 8008 	ldr.w	r8, [r5, #8]
   13874:	2b62      	cmp	r3, #98	; 0x62
   13876:	d043      	beq.n	13900 <trace_write+0xa8>
   13878:	2b63      	cmp	r3, #99	; 0x63
   1387a:	d043      	beq.n	13904 <trace_write+0xac>
   1387c:	2b61      	cmp	r3, #97	; 0x61
   1387e:	d102      	bne.n	13886 <trace_write+0x2e>
   13880:	4b4b      	ldr	r3, [pc, #300]	; (139b0 <trace_write+0x158>)
   13882:	881c      	ldrh	r4, [r3, #0]
   13884:	b2a4      	uxth	r4, r4
   13886:	6838      	ldr	r0, [r7, #0]
   13888:	f003 f807 	bl	1689a <nrf_modem_os_sem_give>
   1388c:	f8d5 a00c 	ldr.w	sl, [r5, #12]
   13890:	6929      	ldr	r1, [r5, #16]
   13892:	eba8 080a 	sub.w	r8, r8, sl
   13896:	eba1 030a 	sub.w	r3, r1, sl
   1389a:	b29b      	uxth	r3, r3
   1389c:	fa14 f488 	uxtah	r4, r4, r8
   138a0:	fbb4 f2f3 	udiv	r2, r4, r3
   138a4:	fb03 4412 	mls	r4, r3, r2, r4
   138a8:	686a      	ldr	r2, [r5, #4]
   138aa:	eba2 020a 	sub.w	r2, r2, sl
   138ae:	fa13 f282 	uxtah	r2, r3, r2
   138b2:	1b12      	subs	r2, r2, r4
   138b4:	fb92 f0f3 	sdiv	r0, r2, r3
   138b8:	fb03 2210 	mls	r2, r3, r0, r2
   138bc:	fa1f f982 	uxth.w	r9, r2
   138c0:	fa14 f282 	uxtah	r2, r4, r2
   138c4:	4293      	cmp	r3, r2
   138c6:	44a2      	add	sl, r4
   138c8:	da22      	bge.n	13910 <trace_write+0xb8>
   138ca:	eba1 030a 	sub.w	r3, r1, sl
   138ce:	b29b      	uxth	r3, r3
   138d0:	eba9 0403 	sub.w	r4, r9, r3
   138d4:	4699      	mov	r9, r3
   138d6:	b2a4      	uxth	r4, r4
   138d8:	f1b9 0f00 	cmp.w	r9, #0
   138dc:	d064      	beq.n	139a8 <trace_write+0x150>
   138de:	2005      	movs	r0, #5
   138e0:	f7ff fa48 	bl	12d74 <nrf_modem_os_alloc>
   138e4:	4680      	mov	r8, r0
   138e6:	2800      	cmp	r0, #0
   138e8:	d05e      	beq.n	139a8 <trace_write+0x150>
   138ea:	b19c      	cbz	r4, 13914 <trace_write+0xbc>
   138ec:	2005      	movs	r0, #5
   138ee:	f7ff fa41 	bl	12d74 <nrf_modem_os_alloc>
   138f2:	4606      	mov	r6, r0
   138f4:	b970      	cbnz	r0, 13914 <trace_write+0xbc>
   138f6:	4640      	mov	r0, r8
   138f8:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   138fc:	f7ff ba42 	b.w	12d84 <nrf_modem_os_free>
   13900:	4b2c      	ldr	r3, [pc, #176]	; (139b4 <trace_write+0x15c>)
   13902:	e7be      	b.n	13882 <trace_write+0x2a>
   13904:	4b2c      	ldr	r3, [pc, #176]	; (139b8 <trace_write+0x160>)
   13906:	e7bc      	b.n	13882 <trace_write+0x2a>
   13908:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1390c:	f7ff ba22 	b.w	12d54 <nrf_modem_os_trace_irq_set>
   13910:	2400      	movs	r4, #0
   13912:	e7e1      	b.n	138d8 <trace_write+0x80>
   13914:	2100      	movs	r1, #0
   13916:	6838      	ldr	r0, [r7, #0]
   13918:	f002 ffc1 	bl	1689e <nrf_modem_os_sem_take>
   1391c:	b140      	cbz	r0, 13930 <trace_write+0xd8>
   1391e:	f7ff fa19 	bl	12d54 <nrf_modem_os_trace_irq_set>
   13922:	4640      	mov	r0, r8
   13924:	f7ff fa2e 	bl	12d84 <nrf_modem_os_free>
   13928:	2c00      	cmp	r4, #0
   1392a:	d03d      	beq.n	139a8 <trace_write+0x150>
   1392c:	4630      	mov	r0, r6
   1392e:	e7e3      	b.n	138f8 <trace_write+0xa0>
   13930:	782b      	ldrb	r3, [r5, #0]
   13932:	2b62      	cmp	r3, #98	; 0x62
   13934:	d034      	beq.n	139a0 <trace_write+0x148>
   13936:	2b63      	cmp	r3, #99	; 0x63
   13938:	d034      	beq.n	139a4 <trace_write+0x14c>
   1393a:	2b61      	cmp	r3, #97	; 0x61
   1393c:	d107      	bne.n	1394e <trace_write+0xf6>
   1393e:	4a1c      	ldr	r2, [pc, #112]	; (139b0 <trace_write+0x158>)
   13940:	8813      	ldrh	r3, [r2, #0]
   13942:	eb04 0109 	add.w	r1, r4, r9
   13946:	fa11 f383 	uxtah	r3, r1, r3
   1394a:	b29b      	uxth	r3, r3
   1394c:	8013      	strh	r3, [r2, #0]
   1394e:	6838      	ldr	r0, [r7, #0]
   13950:	f06f 0b10 	mvn.w	fp, #16
   13954:	f06f 0741 	mvn.w	r7, #65	; 0x41
   13958:	f002 ff9f 	bl	1689a <nrf_modem_os_sem_give>
   1395c:	f888 b000 	strb.w	fp, [r8]
   13960:	f888 7001 	strb.w	r7, [r8, #1]
   13964:	782b      	ldrb	r3, [r5, #0]
   13966:	2105      	movs	r1, #5
   13968:	4640      	mov	r0, r8
   1396a:	f888 3004 	strb.w	r3, [r8, #4]
   1396e:	f8a8 9002 	strh.w	r9, [r8, #2]
   13972:	f002 ffc2 	bl	168fa <nrf_modem_os_trace_put>
   13976:	4649      	mov	r1, r9
   13978:	4650      	mov	r0, sl
   1397a:	f002 ffbe 	bl	168fa <nrf_modem_os_trace_put>
   1397e:	b19c      	cbz	r4, 139a8 <trace_write+0x150>
   13980:	f886 b000 	strb.w	fp, [r6]
   13984:	7077      	strb	r7, [r6, #1]
   13986:	782b      	ldrb	r3, [r5, #0]
   13988:	2105      	movs	r1, #5
   1398a:	4630      	mov	r0, r6
   1398c:	7133      	strb	r3, [r6, #4]
   1398e:	8074      	strh	r4, [r6, #2]
   13990:	f002 ffb3 	bl	168fa <nrf_modem_os_trace_put>
   13994:	4621      	mov	r1, r4
   13996:	68e8      	ldr	r0, [r5, #12]
   13998:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1399c:	f002 bfad 	b.w	168fa <nrf_modem_os_trace_put>
   139a0:	4a04      	ldr	r2, [pc, #16]	; (139b4 <trace_write+0x15c>)
   139a2:	e7cd      	b.n	13940 <trace_write+0xe8>
   139a4:	4a04      	ldr	r2, [pc, #16]	; (139b8 <trace_write+0x160>)
   139a6:	e7cb      	b.n	13940 <trace_write+0xe8>
   139a8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   139ac:	2000ca44 	.word	0x2000ca44
   139b0:	2000ccb4 	.word	0x2000ccb4
   139b4:	2000ccb0 	.word	0x2000ccb0
   139b8:	2000ccb2 	.word	0x2000ccb2

000139bc <ipc_trace_init>:
   139bc:	2300      	movs	r3, #0
   139be:	4a08      	ldr	r2, [pc, #32]	; (139e0 <ipc_trace_init+0x24>)
   139c0:	b510      	push	{r4, lr}
   139c2:	8013      	strh	r3, [r2, #0]
   139c4:	4a07      	ldr	r2, [pc, #28]	; (139e4 <ipc_trace_init+0x28>)
   139c6:	4604      	mov	r4, r0
   139c8:	8013      	strh	r3, [r2, #0]
   139ca:	4a07      	ldr	r2, [pc, #28]	; (139e8 <ipc_trace_init+0x2c>)
   139cc:	4807      	ldr	r0, [pc, #28]	; (139ec <ipc_trace_init+0x30>)
   139ce:	8013      	strh	r3, [r2, #0]
   139d0:	2201      	movs	r2, #1
   139d2:	4611      	mov	r1, r2
   139d4:	f7ff f994 	bl	12d00 <nrf_modem_os_sem_init>
   139d8:	4b05      	ldr	r3, [pc, #20]	; (139f0 <ipc_trace_init+0x34>)
   139da:	601c      	str	r4, [r3, #0]
   139dc:	bd10      	pop	{r4, pc}
   139de:	bf00      	nop
   139e0:	2000ccb4 	.word	0x2000ccb4
   139e4:	2000ccb0 	.word	0x2000ccb0
   139e8:	2000ccb2 	.word	0x2000ccb2
   139ec:	2000ca44 	.word	0x2000ca44
   139f0:	2000ca40 	.word	0x2000ca40

000139f4 <nrf_modem_trace_irq_handler>:
   139f4:	b508      	push	{r3, lr}
   139f6:	4b10      	ldr	r3, [pc, #64]	; (13a38 <nrf_modem_trace_irq_handler+0x44>)
   139f8:	781b      	ldrb	r3, [r3, #0]
   139fa:	b90b      	cbnz	r3, 13a00 <nrf_modem_trace_irq_handler+0xc>
   139fc:	f7ff f9b2 	bl	12d64 <nrf_modem_os_trace_irq_clear>
   13a00:	4b0e      	ldr	r3, [pc, #56]	; (13a3c <nrf_modem_trace_irq_handler+0x48>)
   13a02:	6818      	ldr	r0, [r3, #0]
   13a04:	6842      	ldr	r2, [r0, #4]
   13a06:	6883      	ldr	r3, [r0, #8]
   13a08:	429a      	cmp	r2, r3
   13a0a:	d001      	beq.n	13a10 <nrf_modem_trace_irq_handler+0x1c>
   13a0c:	f7ff ff24 	bl	13858 <trace_write>
   13a10:	4b0b      	ldr	r3, [pc, #44]	; (13a40 <nrf_modem_trace_irq_handler+0x4c>)
   13a12:	6818      	ldr	r0, [r3, #0]
   13a14:	6882      	ldr	r2, [r0, #8]
   13a16:	6843      	ldr	r3, [r0, #4]
   13a18:	429a      	cmp	r2, r3
   13a1a:	d001      	beq.n	13a20 <nrf_modem_trace_irq_handler+0x2c>
   13a1c:	f7ff ff1c 	bl	13858 <trace_write>
   13a20:	4b08      	ldr	r3, [pc, #32]	; (13a44 <nrf_modem_trace_irq_handler+0x50>)
   13a22:	6818      	ldr	r0, [r3, #0]
   13a24:	6882      	ldr	r2, [r0, #8]
   13a26:	6843      	ldr	r3, [r0, #4]
   13a28:	429a      	cmp	r2, r3
   13a2a:	d003      	beq.n	13a34 <nrf_modem_trace_irq_handler+0x40>
   13a2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   13a30:	f7ff bf12 	b.w	13858 <trace_write>
   13a34:	bd08      	pop	{r3, pc}
   13a36:	bf00      	nop
   13a38:	2000ccc1 	.word	0x2000ccc1
   13a3c:	2000ca3c 	.word	0x2000ca3c
   13a40:	2000ca34 	.word	0x2000ca34
   13a44:	2000ca38 	.word	0x2000ca38

00013a48 <ipc_trace_handle>:
   13a48:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13a4c:	4b43      	ldr	r3, [pc, #268]	; (13b5c <ipc_trace_handle+0x114>)
   13a4e:	681b      	ldr	r3, [r3, #0]
   13a50:	6919      	ldr	r1, [r3, #16]
   13a52:	f8d3 a014 	ldr.w	sl, [r3, #20]
   13a56:	7c1a      	ldrb	r2, [r3, #16]
   13a58:	2200      	movs	r2, #0
   13a5a:	741a      	strb	r2, [r3, #16]
   13a5c:	7c58      	ldrb	r0, [r3, #17]
   13a5e:	745a      	strb	r2, [r3, #17]
   13a60:	7c98      	ldrb	r0, [r3, #18]
   13a62:	749a      	strb	r2, [r3, #18]
   13a64:	7cd8      	ldrb	r0, [r3, #19]
   13a66:	74da      	strb	r2, [r3, #19]
   13a68:	7d18      	ldrb	r0, [r3, #20]
   13a6a:	751a      	strb	r2, [r3, #20]
   13a6c:	7d58      	ldrb	r0, [r3, #21]
   13a6e:	755a      	strb	r2, [r3, #21]
   13a70:	7d98      	ldrb	r0, [r3, #22]
   13a72:	759a      	strb	r2, [r3, #22]
   13a74:	7dd8      	ldrb	r0, [r3, #23]
   13a76:	75da      	strb	r2, [r3, #23]
   13a78:	2900      	cmp	r1, #0
   13a7a:	d033      	beq.n	13ae4 <ipc_trace_handle+0x9c>
   13a7c:	3901      	subs	r1, #1
   13a7e:	2903      	cmp	r1, #3
   13a80:	d830      	bhi.n	13ae4 <ipc_trace_handle+0x9c>
   13a82:	e8df f001 	tbb	[pc, r1]
   13a86:	6502      	.short	0x6502
   13a88:	534c      	.short	0x534c
   13a8a:	4a35      	ldr	r2, [pc, #212]	; (13b60 <ipc_trace_handle+0x118>)
   13a8c:	7811      	ldrb	r1, [r2, #0]
   13a8e:	b109      	cbz	r1, 13a94 <ipc_trace_handle+0x4c>
   13a90:	2100      	movs	r1, #0
   13a92:	7011      	strb	r1, [r2, #0]
   13a94:	2200      	movs	r2, #0
   13a96:	4691      	mov	r9, r2
   13a98:	4617      	mov	r7, r2
   13a9a:	4614      	mov	r4, r2
   13a9c:	4d31      	ldr	r5, [pc, #196]	; (13b64 <ipc_trace_handle+0x11c>)
   13a9e:	4932      	ldr	r1, [pc, #200]	; (13b68 <ipc_trace_handle+0x120>)
   13aa0:	4832      	ldr	r0, [pc, #200]	; (13b6c <ipc_trace_handle+0x124>)
   13aa2:	f8d5 e000 	ldr.w	lr, [r5]
   13aa6:	f8d1 8000 	ldr.w	r8, [r1]
   13aaa:	6806      	ldr	r6, [r0, #0]
   13aac:	f8da b008 	ldr.w	fp, [sl, #8]
   13ab0:	9501      	str	r5, [sp, #4]
   13ab2:	45a3      	cmp	fp, r4
   13ab4:	d119      	bne.n	13aea <ipc_trace_handle+0xa2>
   13ab6:	b107      	cbz	r7, 13aba <ipc_trace_handle+0x72>
   13ab8:	6006      	str	r6, [r0, #0]
   13aba:	f1b9 0f00 	cmp.w	r9, #0
   13abe:	d001      	beq.n	13ac4 <ipc_trace_handle+0x7c>
   13ac0:	f8c1 8000 	str.w	r8, [r1]
   13ac4:	b112      	cbz	r2, 13acc <ipc_trace_handle+0x84>
   13ac6:	9a01      	ldr	r2, [sp, #4]
   13ac8:	f8c2 e000 	str.w	lr, [r2]
   13acc:	7a1a      	ldrb	r2, [r3, #8]
   13ace:	2101      	movs	r1, #1
   13ad0:	2200      	movs	r2, #0
   13ad2:	7219      	strb	r1, [r3, #8]
   13ad4:	7a59      	ldrb	r1, [r3, #9]
   13ad6:	725a      	strb	r2, [r3, #9]
   13ad8:	7a99      	ldrb	r1, [r3, #10]
   13ada:	729a      	strb	r2, [r3, #10]
   13adc:	7ada      	ldrb	r2, [r3, #11]
   13ade:	f06f 025f 	mvn.w	r2, #95	; 0x5f
   13ae2:	72da      	strb	r2, [r3, #11]
   13ae4:	b003      	add	sp, #12
   13ae6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13aea:	1ca5      	adds	r5, r4, #2
   13aec:	eb0a 0585 	add.w	r5, sl, r5, lsl #2
   13af0:	686d      	ldr	r5, [r5, #4]
   13af2:	f895 c000 	ldrb.w	ip, [r5]
   13af6:	f1bc 0f62 	cmp.w	ip, #98	; 0x62
   13afa:	d009      	beq.n	13b10 <ipc_trace_handle+0xc8>
   13afc:	f1bc 0f63 	cmp.w	ip, #99	; 0x63
   13b00:	d00a      	beq.n	13b18 <ipc_trace_handle+0xd0>
   13b02:	f1bc 0f61 	cmp.w	ip, #97	; 0x61
   13b06:	bf04      	itt	eq
   13b08:	462e      	moveq	r6, r5
   13b0a:	2701      	moveq	r7, #1
   13b0c:	3401      	adds	r4, #1
   13b0e:	e7d0      	b.n	13ab2 <ipc_trace_handle+0x6a>
   13b10:	46a8      	mov	r8, r5
   13b12:	f04f 0901 	mov.w	r9, #1
   13b16:	e7f9      	b.n	13b0c <ipc_trace_handle+0xc4>
   13b18:	46ae      	mov	lr, r5
   13b1a:	2201      	movs	r2, #1
   13b1c:	e7f6      	b.n	13b0c <ipc_trace_handle+0xc4>
   13b1e:	2101      	movs	r1, #1
   13b20:	4a0f      	ldr	r2, [pc, #60]	; (13b60 <ipc_trace_handle+0x118>)
   13b22:	7011      	strb	r1, [r2, #0]
   13b24:	7a1a      	ldrb	r2, [r3, #8]
   13b26:	2103      	movs	r1, #3
   13b28:	2200      	movs	r2, #0
   13b2a:	e7d2      	b.n	13ad2 <ipc_trace_handle+0x8a>
   13b2c:	7a19      	ldrb	r1, [r3, #8]
   13b2e:	2104      	movs	r1, #4
   13b30:	7219      	strb	r1, [r3, #8]
   13b32:	7a59      	ldrb	r1, [r3, #9]
   13b34:	725a      	strb	r2, [r3, #9]
   13b36:	7a99      	ldrb	r1, [r3, #10]
   13b38:	729a      	strb	r2, [r3, #10]
   13b3a:	7ad9      	ldrb	r1, [r3, #11]
   13b3c:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   13b40:	72d9      	strb	r1, [r3, #11]
   13b42:	4b07      	ldr	r3, [pc, #28]	; (13b60 <ipc_trace_handle+0x118>)
   13b44:	701a      	strb	r2, [r3, #0]
   13b46:	b003      	add	sp, #12
   13b48:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13b4c:	f7ff bf52 	b.w	139f4 <nrf_modem_trace_irq_handler>
   13b50:	b003      	add	sp, #12
   13b52:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13b56:	f7ff b8fd 	b.w	12d54 <nrf_modem_os_trace_irq_set>
   13b5a:	bf00      	nop
   13b5c:	2000ca40 	.word	0x2000ca40
   13b60:	2000ccc1 	.word	0x2000ccc1
   13b64:	2000ca38 	.word	0x2000ca38
   13b68:	2000ca34 	.word	0x2000ca34
   13b6c:	2000ca3c 	.word	0x2000ca3c

00013b70 <rpc_trace_coredump_in_progress>:
   13b70:	4b01      	ldr	r3, [pc, #4]	; (13b78 <rpc_trace_coredump_in_progress+0x8>)
   13b72:	7818      	ldrb	r0, [r3, #0]
   13b74:	4770      	bx	lr
   13b76:	bf00      	nop
   13b78:	2000ccc1 	.word	0x2000ccc1

00013b7c <handle_modem_rpc_msg>:
   13b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13b80:	4606      	mov	r6, r0
   13b82:	460f      	mov	r7, r1
   13b84:	2500      	movs	r5, #0
   13b86:	f8df 8074 	ldr.w	r8, [pc, #116]	; 13bfc <handle_modem_rpc_msg+0x80>
   13b8a:	6833      	ldr	r3, [r6, #0]
   13b8c:	42ab      	cmp	r3, r5
   13b8e:	d801      	bhi.n	13b94 <handle_modem_rpc_msg+0x18>
   13b90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13b94:	eb06 04c5 	add.w	r4, r6, r5, lsl #3
   13b98:	68a3      	ldr	r3, [r4, #8]
   13b9a:	b1fb      	cbz	r3, 13bdc <handle_modem_rpc_msg+0x60>
   13b9c:	6863      	ldr	r3, [r4, #4]
   13b9e:	b2db      	uxtb	r3, r3
   13ba0:	2b01      	cmp	r3, #1
   13ba2:	d11b      	bne.n	13bdc <handle_modem_rpc_msg+0x60>
   13ba4:	6862      	ldr	r2, [r4, #4]
   13ba6:	f8b8 3000 	ldrh.w	r3, [r8]
   13baa:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   13bae:	d115      	bne.n	13bdc <handle_modem_rpc_msg+0x60>
   13bb0:	2f02      	cmp	r7, #2
   13bb2:	68a0      	ldr	r0, [r4, #8]
   13bb4:	d114      	bne.n	13be0 <handle_modem_rpc_msg+0x64>
   13bb6:	f7ff fe2d 	bl	13814 <rpc_handle_data_message>
   13bba:	2802      	cmp	r0, #2
   13bbc:	d00e      	beq.n	13bdc <handle_modem_rpc_msg+0x60>
   13bbe:	2801      	cmp	r0, #1
   13bc0:	d113      	bne.n	13bea <handle_modem_rpc_msg+0x6e>
   13bc2:	6863      	ldr	r3, [r4, #4]
   13bc4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   13bc8:	f043 0302 	orr.w	r3, r3, #2
   13bcc:	6063      	str	r3, [r4, #4]
   13bce:	f8b8 3000 	ldrh.w	r3, [r8]
   13bd2:	3301      	adds	r3, #1
   13bd4:	f8a8 3000 	strh.w	r3, [r8]
   13bd8:	f7ff f8ac 	bl	12d34 <nrf_modem_os_application_irq_set>
   13bdc:	3501      	adds	r5, #1
   13bde:	e7d4      	b.n	13b8a <handle_modem_rpc_msg+0xe>
   13be0:	6801      	ldr	r1, [r0, #0]
   13be2:	0c09      	lsrs	r1, r1, #16
   13be4:	f002 fe9d 	bl	16922 <rpc_handle_ctrl_message>
   13be8:	e7e7      	b.n	13bba <handle_modem_rpc_msg+0x3e>
   13bea:	2800      	cmp	r0, #0
   13bec:	d1ef      	bne.n	13bce <handle_modem_rpc_msg+0x52>
   13bee:	6863      	ldr	r3, [r4, #4]
   13bf0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   13bf4:	f043 0303 	orr.w	r3, r3, #3
   13bf8:	e7e8      	b.n	13bcc <handle_modem_rpc_msg+0x50>
   13bfa:	bf00      	nop
   13bfc:	2000ccb6 	.word	0x2000ccb6

00013c00 <rpc_transport_ipc_msg_alloc>:
   13c00:	b570      	push	{r4, r5, r6, lr}
   13c02:	4616      	mov	r6, r2
   13c04:	2400      	movs	r4, #0
   13c06:	6803      	ldr	r3, [r0, #0]
   13c08:	42a3      	cmp	r3, r4
   13c0a:	d101      	bne.n	13c10 <rpc_transport_ipc_msg_alloc+0x10>
   13c0c:	2300      	movs	r3, #0
   13c0e:	e01c      	b.n	13c4a <rpc_transport_ipc_msg_alloc+0x4a>
   13c10:	eb00 02c4 	add.w	r2, r0, r4, lsl #3
   13c14:	6855      	ldr	r5, [r2, #4]
   13c16:	b2ed      	uxtb	r5, r5
   13c18:	2d03      	cmp	r5, #3
   13c1a:	d118      	bne.n	13c4e <rpc_transport_ipc_msg_alloc+0x4e>
   13c1c:	eb01 1384 	add.w	r3, r1, r4, lsl #6
   13c20:	6093      	str	r3, [r2, #8]
   13c22:	6851      	ldr	r1, [r2, #4]
   13c24:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   13c28:	6051      	str	r1, [r2, #4]
   13c2a:	490c      	ldr	r1, [pc, #48]	; (13c5c <rpc_transport_ipc_msg_alloc+0x5c>)
   13c2c:	8808      	ldrh	r0, [r1, #0]
   13c2e:	1c44      	adds	r4, r0, #1
   13c30:	800c      	strh	r4, [r1, #0]
   13c32:	6851      	ldr	r1, [r2, #4]
   13c34:	b289      	uxth	r1, r1
   13c36:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   13c3a:	6051      	str	r1, [r2, #4]
   13c3c:	4618      	mov	r0, r3
   13c3e:	2240      	movs	r2, #64	; 0x40
   13c40:	2100      	movs	r1, #0
   13c42:	f002 fcac 	bl	1659e <memset>
   13c46:	4603      	mov	r3, r0
   13c48:	6046      	str	r6, [r0, #4]
   13c4a:	4618      	mov	r0, r3
   13c4c:	bd70      	pop	{r4, r5, r6, pc}
   13c4e:	b915      	cbnz	r5, 13c56 <rpc_transport_ipc_msg_alloc+0x56>
   13c50:	6895      	ldr	r5, [r2, #8]
   13c52:	2d00      	cmp	r5, #0
   13c54:	d0e2      	beq.n	13c1c <rpc_transport_ipc_msg_alloc+0x1c>
   13c56:	3401      	adds	r4, #1
   13c58:	e7d6      	b.n	13c08 <rpc_transport_ipc_msg_alloc+0x8>
   13c5a:	bf00      	nop
   13c5c:	2000ccb8 	.word	0x2000ccb8

00013c60 <rpc_transport_ipc_data_msg_send>:
   13c60:	b508      	push	{r3, lr}
   13c62:	4b0b      	ldr	r3, [pc, #44]	; (13c90 <rpc_transport_ipc_data_msg_send+0x30>)
   13c64:	681b      	ldr	r3, [r3, #0]
   13c66:	1ac0      	subs	r0, r0, r3
   13c68:	4b0a      	ldr	r3, [pc, #40]	; (13c94 <rpc_transport_ipc_data_msg_send+0x34>)
   13c6a:	f3c0 1089 	ubfx	r0, r0, #6, #10
   13c6e:	681b      	ldr	r3, [r3, #0]
   13c70:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   13c74:	6843      	ldr	r3, [r0, #4]
   13c76:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   13c7a:	f043 0301 	orr.w	r3, r3, #1
   13c7e:	6043      	str	r3, [r0, #4]
   13c80:	2003      	movs	r0, #3
   13c82:	f002 fe06 	bl	16892 <nrf_modem_os_busywait>
   13c86:	2201      	movs	r2, #1
   13c88:	4b03      	ldr	r3, [pc, #12]	; (13c98 <rpc_transport_ipc_data_msg_send+0x38>)
   13c8a:	601a      	str	r2, [r3, #0]
   13c8c:	bd08      	pop	{r3, pc}
   13c8e:	bf00      	nop
   13c90:	2000ca60 	.word	0x2000ca60
   13c94:	2000ca64 	.word	0x2000ca64
   13c98:	4002a00c 	.word	0x4002a00c

00013c9c <rpc_transport_ipc_ctrl_msg_send>:
   13c9c:	b508      	push	{r3, lr}
   13c9e:	4b0b      	ldr	r3, [pc, #44]	; (13ccc <rpc_transport_ipc_ctrl_msg_send+0x30>)
   13ca0:	681b      	ldr	r3, [r3, #0]
   13ca2:	1ac0      	subs	r0, r0, r3
   13ca4:	4b0a      	ldr	r3, [pc, #40]	; (13cd0 <rpc_transport_ipc_ctrl_msg_send+0x34>)
   13ca6:	f3c0 1089 	ubfx	r0, r0, #6, #10
   13caa:	681b      	ldr	r3, [r3, #0]
   13cac:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   13cb0:	6843      	ldr	r3, [r0, #4]
   13cb2:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   13cb6:	f043 0301 	orr.w	r3, r3, #1
   13cba:	6043      	str	r3, [r0, #4]
   13cbc:	2003      	movs	r0, #3
   13cbe:	f002 fde8 	bl	16892 <nrf_modem_os_busywait>
   13cc2:	2201      	movs	r2, #1
   13cc4:	4b03      	ldr	r3, [pc, #12]	; (13cd4 <rpc_transport_ipc_ctrl_msg_send+0x38>)
   13cc6:	601a      	str	r2, [r3, #0]
   13cc8:	bd08      	pop	{r3, pc}
   13cca:	bf00      	nop
   13ccc:	2000ca58 	.word	0x2000ca58
   13cd0:	2000ca5c 	.word	0x2000ca5c
   13cd4:	4002a004 	.word	0x4002a004

00013cd8 <rpc_transport_ipc_data_msg_alloc>:
   13cd8:	4b05      	ldr	r3, [pc, #20]	; (13cf0 <rpc_transport_ipc_data_msg_alloc+0x18>)
   13cda:	781b      	ldrb	r3, [r3, #0]
   13cdc:	b933      	cbnz	r3, 13cec <rpc_transport_ipc_data_msg_alloc+0x14>
   13cde:	4b05      	ldr	r3, [pc, #20]	; (13cf4 <rpc_transport_ipc_data_msg_alloc+0x1c>)
   13ce0:	2202      	movs	r2, #2
   13ce2:	6819      	ldr	r1, [r3, #0]
   13ce4:	4b04      	ldr	r3, [pc, #16]	; (13cf8 <rpc_transport_ipc_data_msg_alloc+0x20>)
   13ce6:	6818      	ldr	r0, [r3, #0]
   13ce8:	f7ff bf8a 	b.w	13c00 <rpc_transport_ipc_msg_alloc>
   13cec:	2000      	movs	r0, #0
   13cee:	4770      	bx	lr
   13cf0:	2000ccc3 	.word	0x2000ccc3
   13cf4:	2000ca60 	.word	0x2000ca60
   13cf8:	2000ca64 	.word	0x2000ca64

00013cfc <rpc_transport_ipc_ctrl_msg_alloc>:
   13cfc:	230a      	movs	r3, #10
   13cfe:	b537      	push	{r0, r1, r2, r4, r5, lr}
   13d00:	4c0c      	ldr	r4, [pc, #48]	; (13d34 <rpc_transport_ipc_ctrl_msg_alloc+0x38>)
   13d02:	4d0d      	ldr	r5, [pc, #52]	; (13d38 <rpc_transport_ipc_ctrl_msg_alloc+0x3c>)
   13d04:	9301      	str	r3, [sp, #4]
   13d06:	2201      	movs	r2, #1
   13d08:	6821      	ldr	r1, [r4, #0]
   13d0a:	6828      	ldr	r0, [r5, #0]
   13d0c:	f7ff ff78 	bl	13c00 <rpc_transport_ipc_msg_alloc>
   13d10:	b968      	cbnz	r0, 13d2e <rpc_transport_ipc_ctrl_msg_alloc+0x32>
   13d12:	f002 fdc0 	bl	16896 <nrf_modem_os_is_in_isr>
   13d16:	b918      	cbnz	r0, 13d20 <rpc_transport_ipc_ctrl_msg_alloc+0x24>
   13d18:	a901      	add	r1, sp, #4
   13d1a:	f7fe ff39 	bl	12b90 <nrf_modem_os_timedwait>
   13d1e:	e7f2      	b.n	13d06 <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   13d20:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   13d24:	9b01      	ldr	r3, [sp, #4]
   13d26:	4358      	muls	r0, r3
   13d28:	f002 fdb3 	bl	16892 <nrf_modem_os_busywait>
   13d2c:	e7eb      	b.n	13d06 <rpc_transport_ipc_ctrl_msg_alloc+0xa>
   13d2e:	b003      	add	sp, #12
   13d30:	bd30      	pop	{r4, r5, pc}
   13d32:	bf00      	nop
   13d34:	2000ca58 	.word	0x2000ca58
   13d38:	2000ca5c 	.word	0x2000ca5c

00013d3c <rpc_transport_ipc_data_alloc>:
   13d3c:	4b03      	ldr	r3, [pc, #12]	; (13d4c <rpc_transport_ipc_data_alloc+0x10>)
   13d3e:	781b      	ldrb	r3, [r3, #0]
   13d40:	b90b      	cbnz	r3, 13d46 <rpc_transport_ipc_data_alloc+0xa>
   13d42:	f7ff b825 	b.w	12d90 <nrf_modem_os_shm_tx_alloc>
   13d46:	2000      	movs	r0, #0
   13d48:	4770      	bx	lr
   13d4a:	bf00      	nop
   13d4c:	2000ccc3 	.word	0x2000ccc3

00013d50 <nrf_modem_application_irq_handler>:
   13d50:	b510      	push	{r4, lr}
   13d52:	4c06      	ldr	r4, [pc, #24]	; (13d6c <nrf_modem_application_irq_handler+0x1c>)
   13d54:	f7fe fff6 	bl	12d44 <nrf_modem_os_application_irq_clear>
   13d58:	6820      	ldr	r0, [r4, #0]
   13d5a:	2101      	movs	r1, #1
   13d5c:	f7ff ff0e 	bl	13b7c <handle_modem_rpc_msg>
   13d60:	6860      	ldr	r0, [r4, #4]
   13d62:	2102      	movs	r1, #2
   13d64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   13d68:	f7ff bf08 	b.w	13b7c <handle_modem_rpc_msg>
   13d6c:	2000ca4c 	.word	0x2000ca4c

00013d70 <rpc_transport_ipc_msg_free>:
   13d70:	2300      	movs	r3, #0
   13d72:	4911      	ldr	r1, [pc, #68]	; (13db8 <rpc_transport_ipc_msg_free+0x48>)
   13d74:	b530      	push	{r4, r5, lr}
   13d76:	680a      	ldr	r2, [r1, #0]
   13d78:	6814      	ldr	r4, [r2, #0]
   13d7a:	42a3      	cmp	r3, r4
   13d7c:	d10b      	bne.n	13d96 <rpc_transport_ipc_msg_free+0x26>
   13d7e:	2300      	movs	r3, #0
   13d80:	684a      	ldr	r2, [r1, #4]
   13d82:	6811      	ldr	r1, [r2, #0]
   13d84:	428b      	cmp	r3, r1
   13d86:	d015      	beq.n	13db4 <rpc_transport_ipc_msg_free+0x44>
   13d88:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
   13d8c:	68a4      	ldr	r4, [r4, #8]
   13d8e:	42a0      	cmp	r0, r4
   13d90:	d008      	beq.n	13da4 <rpc_transport_ipc_msg_free+0x34>
   13d92:	3301      	adds	r3, #1
   13d94:	e7f6      	b.n	13d84 <rpc_transport_ipc_msg_free+0x14>
   13d96:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
   13d9a:	68ad      	ldr	r5, [r5, #8]
   13d9c:	42a8      	cmp	r0, r5
   13d9e:	d001      	beq.n	13da4 <rpc_transport_ipc_msg_free+0x34>
   13da0:	3301      	adds	r3, #1
   13da2:	e7ea      	b.n	13d7a <rpc_transport_ipc_msg_free+0xa>
   13da4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   13da8:	685a      	ldr	r2, [r3, #4]
   13daa:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   13dae:	f042 0203 	orr.w	r2, r2, #3
   13db2:	605a      	str	r2, [r3, #4]
   13db4:	bd30      	pop	{r4, r5, pc}
   13db6:	bf00      	nop
   13db8:	2000ca4c 	.word	0x2000ca4c

00013dbc <rpc_transport_ipc_init>:
   13dbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13dc0:	2200      	movs	r2, #0
   13dc2:	b095      	sub	sp, #84	; 0x54
   13dc4:	4605      	mov	r5, r0
   13dc6:	494d      	ldr	r1, [pc, #308]	; (13efc <rpc_transport_ipc_init+0x140>)
   13dc8:	7900      	ldrb	r0, [r0, #4]
   13dca:	f7ff fc9b 	bl	13704 <nrfx_ipc_init>
   13dce:	2238      	movs	r2, #56	; 0x38
   13dd0:	2100      	movs	r1, #0
   13dd2:	a803      	add	r0, sp, #12
   13dd4:	f002 fbe3 	bl	1659e <memset>
   13dd8:	2302      	movs	r3, #2
   13dda:	9304      	str	r3, [sp, #16]
   13ddc:	2308      	movs	r3, #8
   13dde:	9306      	str	r3, [sp, #24]
   13de0:	2320      	movs	r3, #32
   13de2:	9308      	str	r3, [sp, #32]
   13de4:	2301      	movs	r3, #1
   13de6:	930b      	str	r3, [sp, #44]	; 0x2c
   13de8:	2304      	movs	r3, #4
   13dea:	930d      	str	r3, [sp, #52]	; 0x34
   13dec:	2310      	movs	r3, #16
   13dee:	f04f 0c40 	mov.w	ip, #64	; 0x40
   13df2:	930f      	str	r3, [sp, #60]	; 0x3c
   13df4:	2380      	movs	r3, #128	; 0x80
   13df6:	e9cd c311 	strd	ip, r3, [sp, #68]	; 0x44
   13dfa:	23d5      	movs	r3, #213	; 0xd5
   13dfc:	a803      	add	r0, sp, #12
   13dfe:	9313      	str	r3, [sp, #76]	; 0x4c
   13e00:	f7ff fc98 	bl	13734 <nrfx_ipc_config_load>
   13e04:	682b      	ldr	r3, [r5, #0]
   13e06:	2100      	movs	r1, #0
   13e08:	685a      	ldr	r2, [r3, #4]
   13e0a:	6818      	ldr	r0, [r3, #0]
   13e0c:	f002 fbc7 	bl	1659e <memset>
   13e10:	682a      	ldr	r2, [r5, #0]
   13e12:	6814      	ldr	r4, [r2, #0]
   13e14:	69d3      	ldr	r3, [r2, #28]
   13e16:	f104 0660 	add.w	r6, r4, #96	; 0x60
   13e1a:	f104 07a4 	add.w	r7, r4, #164	; 0xa4
   13e1e:	f104 0ae8 	add.w	sl, r4, #232	; 0xe8
   13e22:	f504 7b3a 	add.w	fp, r4, #744	; 0x2e8
   13e26:	f104 0920 	add.w	r9, r4, #32
   13e2a:	2b00      	cmp	r3, #0
   13e2c:	d060      	beq.n	13ef0 <rpc_transport_ipc_init+0x134>
   13e2e:	f104 0840 	add.w	r8, r4, #64	; 0x40
   13e32:	4933      	ldr	r1, [pc, #204]	; (13f00 <rpc_transport_ipc_init+0x144>)
   13e34:	f8c1 9000 	str.w	r9, [r1]
   13e38:	b13b      	cbz	r3, 13e4a <rpc_transport_ipc_init+0x8e>
   13e3a:	6992      	ldr	r2, [r2, #24]
   13e3c:	4640      	mov	r0, r8
   13e3e:	f8c8 2004 	str.w	r2, [r8, #4]
   13e42:	f8c8 3000 	str.w	r3, [r8]
   13e46:	f7ff fdb9 	bl	139bc <ipc_trace_init>
   13e4a:	6828      	ldr	r0, [r5, #0]
   13e4c:	2300      	movs	r3, #0
   13e4e:	6902      	ldr	r2, [r0, #16]
   13e50:	2101      	movs	r1, #1
   13e52:	6062      	str	r2, [r4, #4]
   13e54:	6942      	ldr	r2, [r0, #20]
   13e56:	70a1      	strb	r1, [r4, #2]
   13e58:	60a2      	str	r2, [r4, #8]
   13e5a:	4a2a      	ldr	r2, [pc, #168]	; (13f04 <rpc_transport_ipc_init+0x148>)
   13e5c:	7023      	strb	r3, [r4, #0]
   13e5e:	6017      	str	r7, [r2, #0]
   13e60:	4a29      	ldr	r2, [pc, #164]	; (13f08 <rpc_transport_ipc_init+0x14c>)
   13e62:	7063      	strb	r3, [r4, #1]
   13e64:	6016      	str	r6, [r2, #0]
   13e66:	2208      	movs	r2, #8
   13e68:	70e3      	strb	r3, [r4, #3]
   13e6a:	60e6      	str	r6, [r4, #12]
   13e6c:	6127      	str	r7, [r4, #16]
   13e6e:	f884 20a4 	strb.w	r2, [r4, #164]	; 0xa4
   13e72:	f8c4 9014 	str.w	r9, [r4, #20]
   13e76:	f8c4 8018 	str.w	r8, [r4, #24]
   13e7a:	707b      	strb	r3, [r7, #1]
   13e7c:	70bb      	strb	r3, [r7, #2]
   13e7e:	70fb      	strb	r3, [r7, #3]
   13e80:	2714      	movs	r7, #20
   13e82:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
   13e86:	4a21      	ldr	r2, [pc, #132]	; (13f0c <rpc_transport_ipc_init+0x150>)
   13e88:	4d21      	ldr	r5, [pc, #132]	; (13f10 <rpc_transport_ipc_init+0x154>)
   13e8a:	f8c2 b000 	str.w	fp, [r2]
   13e8e:	4a21      	ldr	r2, [pc, #132]	; (13f14 <rpc_transport_ipc_init+0x158>)
   13e90:	7073      	strb	r3, [r6, #1]
   13e92:	f8c2 a000 	str.w	sl, [r2]
   13e96:	4a20      	ldr	r2, [pc, #128]	; (13f18 <rpc_transport_ipc_init+0x15c>)
   13e98:	70b3      	strb	r3, [r6, #2]
   13e9a:	70f3      	strb	r3, [r6, #3]
   13e9c:	f8c2 4610 	str.w	r4, [r2, #1552]	; 0x610
   13ea0:	f8c2 3614 	str.w	r3, [r2, #1556]	; 0x614
   13ea4:	4c1d      	ldr	r4, [pc, #116]	; (13f1c <rpc_transport_ipc_init+0x160>)
   13ea6:	7029      	strb	r1, [r5, #0]
   13ea8:	491d      	ldr	r1, [pc, #116]	; (13f20 <rpc_transport_ipc_init+0x164>)
   13eaa:	6023      	str	r3, [r4, #0]
   13eac:	9302      	str	r3, [sp, #8]
   13eae:	600b      	str	r3, [r1, #0]
   13eb0:	680b      	ldr	r3, [r1, #0]
   13eb2:	4e1c      	ldr	r6, [pc, #112]	; (13f24 <rpc_transport_ipc_init+0x168>)
   13eb4:	9302      	str	r3, [sp, #8]
   13eb6:	9b02      	ldr	r3, [sp, #8]
   13eb8:	2000      	movs	r0, #0
   13eba:	a901      	add	r1, sp, #4
   13ebc:	9701      	str	r7, [sp, #4]
   13ebe:	f7fe fe67 	bl	12b90 <nrf_modem_os_timedwait>
   13ec2:	9b01      	ldr	r3, [sp, #4]
   13ec4:	3b14      	subs	r3, #20
   13ec6:	441e      	add	r6, r3
   13ec8:	782b      	ldrb	r3, [r5, #0]
   13eca:	2b01      	cmp	r3, #1
   13ecc:	d104      	bne.n	13ed8 <rpc_transport_ipc_init+0x11c>
   13ece:	2e00      	cmp	r6, #0
   13ed0:	d1f2      	bne.n	13eb8 <rpc_transport_ipc_init+0xfc>
   13ed2:	f06f 0373 	mvn.w	r3, #115	; 0x73
   13ed6:	6023      	str	r3, [r4, #0]
   13ed8:	6824      	ldr	r4, [r4, #0]
   13eda:	b95c      	cbnz	r4, 13ef4 <rpc_transport_ipc_init+0x138>
   13edc:	4b12      	ldr	r3, [pc, #72]	; (13f28 <rpc_transport_ipc_init+0x16c>)
   13ede:	701c      	strb	r4, [r3, #0]
   13ee0:	4b12      	ldr	r3, [pc, #72]	; (13f2c <rpc_transport_ipc_init+0x170>)
   13ee2:	801c      	strh	r4, [r3, #0]
   13ee4:	4b12      	ldr	r3, [pc, #72]	; (13f30 <rpc_transport_ipc_init+0x174>)
   13ee6:	801c      	strh	r4, [r3, #0]
   13ee8:	4620      	mov	r0, r4
   13eea:	b015      	add	sp, #84	; 0x54
   13eec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13ef0:	4698      	mov	r8, r3
   13ef2:	e79e      	b.n	13e32 <rpc_transport_ipc_init+0x76>
   13ef4:	f7ff fc3e 	bl	13774 <nrfx_ipc_uninit>
   13ef8:	e7f6      	b.n	13ee8 <rpc_transport_ipc_init+0x12c>
   13efa:	bf00      	nop
   13efc:	00013f35 	.word	0x00013f35
   13f00:	2000ca54 	.word	0x2000ca54
   13f04:	2000ca64 	.word	0x2000ca64
   13f08:	2000ca5c 	.word	0x2000ca5c
   13f0c:	2000ca60 	.word	0x2000ca60
   13f10:	2000ccc2 	.word	0x2000ccc2
   13f14:	2000ca58 	.word	0x2000ca58
   13f18:	4002a000 	.word	0x4002a000
   13f1c:	2000ca48 	.word	0x2000ca48
   13f20:	40005610 	.word	0x40005610
   13f24:	000249f0 	.word	0x000249f0
   13f28:	2000ccc3 	.word	0x2000ccc3
   13f2c:	2000ccb8 	.word	0x2000ccb8
   13f30:	2000ccb6 	.word	0x2000ccb6

00013f34 <ipc_irq_handler>:
   13f34:	b570      	push	{r4, r5, r6, lr}
   13f36:	4604      	mov	r4, r0
   13f38:	0620      	lsls	r0, r4, #24
   13f3a:	d50c      	bpl.n	13f56 <ipc_irq_handler+0x22>
   13f3c:	f7ff fd84 	bl	13a48 <ipc_trace_handle>
   13f40:	f7ff fe16 	bl	13b70 <rpc_trace_coredump_in_progress>
   13f44:	b138      	cbz	r0, 13f56 <ipc_irq_handler+0x22>
   13f46:	22e0      	movs	r2, #224	; 0xe0
   13f48:	4b3e      	ldr	r3, [pc, #248]	; (14044 <ipc_irq_handler+0x110>)
   13f4a:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
   13f4e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   13f52:	605a      	str	r2, [r3, #4]
   13f54:	bd70      	pop	{r4, r5, r6, pc}
   13f56:	07e1      	lsls	r1, r4, #31
   13f58:	d548      	bpl.n	13fec <ipc_irq_handler+0xb8>
   13f5a:	f248 0202 	movw	r2, #32770	; 0x8002
   13f5e:	4b3a      	ldr	r3, [pc, #232]	; (14048 <ipc_irq_handler+0x114>)
   13f60:	f8d3 3614 	ldr.w	r3, [r3, #1556]	; 0x614
   13f64:	4293      	cmp	r3, r2
   13f66:	d035      	beq.n	13fd4 <ipc_irq_handler+0xa0>
   13f68:	d81b      	bhi.n	13fa2 <ipc_irq_handler+0x6e>
   13f6a:	f243 0232 	movw	r2, #12338	; 0x3032
   13f6e:	4293      	cmp	r3, r2
   13f70:	d036      	beq.n	13fe0 <ipc_irq_handler+0xac>
   13f72:	d80b      	bhi.n	13f8c <ipc_irq_handler+0x58>
   13f74:	3b01      	subs	r3, #1
   13f76:	2b01      	cmp	r3, #1
   13f78:	d8ec      	bhi.n	13f54 <ipc_irq_handler+0x20>
   13f7a:	2203      	movs	r2, #3
   13f7c:	200e      	movs	r0, #14
   13f7e:	4b33      	ldr	r3, [pc, #204]	; (1404c <ipc_irq_handler+0x118>)
   13f80:	701a      	strb	r2, [r3, #0]
   13f82:	4b33      	ldr	r3, [pc, #204]	; (14050 <ipc_irq_handler+0x11c>)
   13f84:	6018      	str	r0, [r3, #0]
   13f86:	f002 fd9a 	bl	16abe <rpc_transport_ipc_fault_handler>
   13f8a:	e7e3      	b.n	13f54 <ipc_irq_handler+0x20>
   13f8c:	f248 0201 	movw	r2, #32769	; 0x8001
   13f90:	4293      	cmp	r3, r2
   13f92:	d1df      	bne.n	13f54 <ipc_irq_handler+0x20>
   13f94:	2203      	movs	r2, #3
   13f96:	4b2d      	ldr	r3, [pc, #180]	; (1404c <ipc_irq_handler+0x118>)
   13f98:	701a      	strb	r2, [r3, #0]
   13f9a:	2216      	movs	r2, #22
   13f9c:	4b2c      	ldr	r3, [pc, #176]	; (14050 <ipc_irq_handler+0x11c>)
   13f9e:	601a      	str	r2, [r3, #0]
   13fa0:	e7d8      	b.n	13f54 <ipc_irq_handler+0x20>
   13fa2:	4a2c      	ldr	r2, [pc, #176]	; (14054 <ipc_irq_handler+0x120>)
   13fa4:	4293      	cmp	r3, r2
   13fa6:	d80c      	bhi.n	13fc2 <ipc_irq_handler+0x8e>
   13fa8:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   13fac:	d80c      	bhi.n	13fc8 <ipc_irq_handler+0x94>
   13fae:	f248 0203 	movw	r2, #32771	; 0x8003
   13fb2:	4293      	cmp	r3, r2
   13fb4:	d1ce      	bne.n	13f54 <ipc_irq_handler+0x20>
   13fb6:	2203      	movs	r2, #3
   13fb8:	4b24      	ldr	r3, [pc, #144]	; (1404c <ipc_irq_handler+0x118>)
   13fba:	701a      	strb	r2, [r3, #0]
   13fbc:	220c      	movs	r2, #12
   13fbe:	4b24      	ldr	r3, [pc, #144]	; (14050 <ipc_irq_handler+0x11c>)
   13fc0:	e7ed      	b.n	13f9e <ipc_irq_handler+0x6a>
   13fc2:	4a25      	ldr	r2, [pc, #148]	; (14058 <ipc_irq_handler+0x124>)
   13fc4:	4293      	cmp	r3, r2
   13fc6:	d1c5      	bne.n	13f54 <ipc_irq_handler+0x20>
   13fc8:	2103      	movs	r1, #3
   13fca:	4a20      	ldr	r2, [pc, #128]	; (1404c <ipc_irq_handler+0x118>)
   13fcc:	7011      	strb	r1, [r2, #0]
   13fce:	4a20      	ldr	r2, [pc, #128]	; (14050 <ipc_irq_handler+0x11c>)
   13fd0:	6013      	str	r3, [r2, #0]
   13fd2:	e7bf      	b.n	13f54 <ipc_irq_handler+0x20>
   13fd4:	2203      	movs	r2, #3
   13fd6:	4b1d      	ldr	r3, [pc, #116]	; (1404c <ipc_irq_handler+0x118>)
   13fd8:	701a      	strb	r2, [r3, #0]
   13fda:	225f      	movs	r2, #95	; 0x5f
   13fdc:	4b1c      	ldr	r3, [pc, #112]	; (14050 <ipc_irq_handler+0x11c>)
   13fde:	e7de      	b.n	13f9e <ipc_irq_handler+0x6a>
   13fe0:	2203      	movs	r2, #3
   13fe2:	4b1a      	ldr	r3, [pc, #104]	; (1404c <ipc_irq_handler+0x118>)
   13fe4:	701a      	strb	r2, [r3, #0]
   13fe6:	2205      	movs	r2, #5
   13fe8:	4b19      	ldr	r3, [pc, #100]	; (14050 <ipc_irq_handler+0x11c>)
   13fea:	e7d8      	b.n	13f9e <ipc_irq_handler+0x6a>
   13fec:	f014 0540 	ands.w	r5, r4, #64	; 0x40
   13ff0:	d003      	beq.n	13ffa <ipc_irq_handler+0xc6>
   13ff2:	2202      	movs	r2, #2
   13ff4:	4b15      	ldr	r3, [pc, #84]	; (1404c <ipc_irq_handler+0x118>)
   13ff6:	701a      	strb	r2, [r3, #0]
   13ff8:	e7ac      	b.n	13f54 <ipc_irq_handler+0x20>
   13ffa:	0762      	lsls	r2, r4, #29
   13ffc:	d505      	bpl.n	1400a <ipc_irq_handler+0xd6>
   13ffe:	4b13      	ldr	r3, [pc, #76]	; (1404c <ipc_irq_handler+0x118>)
   14000:	781a      	ldrb	r2, [r3, #0]
   14002:	461e      	mov	r6, r3
   14004:	b93a      	cbnz	r2, 14016 <ipc_irq_handler+0xe2>
   14006:	f7fe fe95 	bl	12d34 <nrf_modem_os_application_irq_set>
   1400a:	06e3      	lsls	r3, r4, #27
   1400c:	d5a2      	bpl.n	13f54 <ipc_irq_handler+0x20>
   1400e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   14012:	f7fe be8f 	b.w	12d34 <nrf_modem_os_application_irq_set>
   14016:	2a01      	cmp	r2, #1
   14018:	d1f7      	bne.n	1400a <ipc_irq_handler+0xd6>
   1401a:	4a10      	ldr	r2, [pc, #64]	; (1405c <ipc_irq_handler+0x128>)
   1401c:	4810      	ldr	r0, [pc, #64]	; (14060 <ipc_irq_handler+0x12c>)
   1401e:	6812      	ldr	r2, [r2, #0]
   14020:	6891      	ldr	r1, [r2, #8]
   14022:	6041      	str	r1, [r0, #4]
   14024:	6852      	ldr	r2, [r2, #4]
   14026:	6002      	str	r2, [r0, #0]
   14028:	b121      	cbz	r1, 14034 <ipc_irq_handler+0x100>
   1402a:	b11a      	cbz	r2, 14034 <ipc_irq_handler+0x100>
   1402c:	6809      	ldr	r1, [r1, #0]
   1402e:	b109      	cbz	r1, 14034 <ipc_irq_handler+0x100>
   14030:	6812      	ldr	r2, [r2, #0]
   14032:	b92a      	cbnz	r2, 14040 <ipc_irq_handler+0x10c>
   14034:	2303      	movs	r3, #3
   14036:	2205      	movs	r2, #5
   14038:	7033      	strb	r3, [r6, #0]
   1403a:	4b05      	ldr	r3, [pc, #20]	; (14050 <ipc_irq_handler+0x11c>)
   1403c:	601a      	str	r2, [r3, #0]
   1403e:	e7e4      	b.n	1400a <ipc_irq_handler+0xd6>
   14040:	701d      	strb	r5, [r3, #0]
   14042:	e7e2      	b.n	1400a <ipc_irq_handler+0xd6>
   14044:	e000e100 	.word	0xe000e100
   14048:	4002a000 	.word	0x4002a000
   1404c:	2000ccc2 	.word	0x2000ccc2
   14050:	2000ca48 	.word	0x2000ca48
   14054:	04400004 	.word	0x04400004
   14058:	05500001 	.word	0x05500001
   1405c:	2000ca54 	.word	0x2000ca54
   14060:	2000ca4c 	.word	0x2000ca4c

00014064 <interface_init>:
   14064:	b508      	push	{r3, lr}
   14066:	f44f 72b0 	mov.w	r2, #352	; 0x160
   1406a:	2100      	movs	r1, #0
   1406c:	4802      	ldr	r0, [pc, #8]	; (14078 <interface_init+0x14>)
   1406e:	f002 fa96 	bl	1659e <memset>
   14072:	2000      	movs	r0, #0
   14074:	bd08      	pop	{r3, pc}
   14076:	bf00      	nop
   14078:	2000ca68 	.word	0x2000ca68

0001407c <interface_socket_wait>:
   1407c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14080:	4615      	mov	r5, r2
   14082:	222c      	movs	r2, #44	; 0x2c
   14084:	4350      	muls	r0, r2
   14086:	461e      	mov	r6, r3
   14088:	4b0e      	ldr	r3, [pc, #56]	; (140c4 <interface_socket_wait+0x48>)
   1408a:	460c      	mov	r4, r1
   1408c:	181f      	adds	r7, r3, r0
   1408e:	581b      	ldr	r3, [r3, r0]
   14090:	402b      	ands	r3, r5
   14092:	428b      	cmp	r3, r1
   14094:	d102      	bne.n	1409c <interface_socket_wait+0x20>
   14096:	2000      	movs	r0, #0
   14098:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1409c:	687b      	ldr	r3, [r7, #4]
   1409e:	2b00      	cmp	r3, #0
   140a0:	d1f9      	bne.n	14096 <interface_socket_wait+0x1a>
   140a2:	46b8      	mov	r8, r7
   140a4:	f8d8 3000 	ldr.w	r3, [r8]
   140a8:	402b      	ands	r3, r5
   140aa:	42a3      	cmp	r3, r4
   140ac:	d0f3      	beq.n	14096 <interface_socket_wait+0x1a>
   140ae:	f8d8 3004 	ldr.w	r3, [r8, #4]
   140b2:	2b00      	cmp	r3, #0
   140b4:	d1ef      	bne.n	14096 <interface_socket_wait+0x1a>
   140b6:	4631      	mov	r1, r6
   140b8:	4638      	mov	r0, r7
   140ba:	f7fe fd69 	bl	12b90 <nrf_modem_os_timedwait>
   140be:	2800      	cmp	r0, #0
   140c0:	d0f0      	beq.n	140a4 <interface_socket_wait+0x28>
   140c2:	e7e9      	b.n	14098 <interface_socket_wait+0x1c>
   140c4:	2000ca68 	.word	0x2000ca68

000140c8 <interface_sockets_aux_state_set>:
   140c8:	4a0d      	ldr	r2, [pc, #52]	; (14100 <interface_sockets_aux_state_set+0x38>)
   140ca:	b570      	push	{r4, r5, r6, lr}
   140cc:	2300      	movs	r3, #0
   140ce:	4611      	mov	r1, r2
   140d0:	252c      	movs	r5, #44	; 0x2c
   140d2:	fb05 f403 	mul.w	r4, r5, r3
   140d6:	590c      	ldr	r4, [r1, r4]
   140d8:	b15c      	cbz	r4, 140f2 <interface_sockets_aux_state_set+0x2a>
   140da:	68d4      	ldr	r4, [r2, #12]
   140dc:	f024 0608 	bic.w	r6, r4, #8
   140e0:	2e02      	cmp	r6, #2
   140e2:	d001      	beq.n	140e8 <interface_sockets_aux_state_set+0x20>
   140e4:	2c05      	cmp	r4, #5
   140e6:	d104      	bne.n	140f2 <interface_sockets_aux_state_set+0x2a>
   140e8:	fb05 f603 	mul.w	r6, r5, r3
   140ec:	598c      	ldr	r4, [r1, r6]
   140ee:	4304      	orrs	r4, r0
   140f0:	518c      	str	r4, [r1, r6]
   140f2:	3301      	adds	r3, #1
   140f4:	2b08      	cmp	r3, #8
   140f6:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   140fa:	d1ea      	bne.n	140d2 <interface_sockets_aux_state_set+0xa>
   140fc:	bd70      	pop	{r4, r5, r6, pc}
   140fe:	bf00      	nop
   14100:	2000ca68 	.word	0x2000ca68

00014104 <interface_sockets_aux_state_clear>:
   14104:	4a0d      	ldr	r2, [pc, #52]	; (1413c <interface_sockets_aux_state_clear+0x38>)
   14106:	b570      	push	{r4, r5, r6, lr}
   14108:	2300      	movs	r3, #0
   1410a:	4611      	mov	r1, r2
   1410c:	252c      	movs	r5, #44	; 0x2c
   1410e:	43c0      	mvns	r0, r0
   14110:	fb05 f403 	mul.w	r4, r5, r3
   14114:	590c      	ldr	r4, [r1, r4]
   14116:	b15c      	cbz	r4, 14130 <interface_sockets_aux_state_clear+0x2c>
   14118:	68d4      	ldr	r4, [r2, #12]
   1411a:	f024 0608 	bic.w	r6, r4, #8
   1411e:	2e02      	cmp	r6, #2
   14120:	d001      	beq.n	14126 <interface_sockets_aux_state_clear+0x22>
   14122:	2c05      	cmp	r4, #5
   14124:	d104      	bne.n	14130 <interface_sockets_aux_state_clear+0x2c>
   14126:	fb05 f603 	mul.w	r6, r5, r3
   1412a:	598c      	ldr	r4, [r1, r6]
   1412c:	4004      	ands	r4, r0
   1412e:	518c      	str	r4, [r1, r6]
   14130:	3301      	adds	r3, #1
   14132:	2b08      	cmp	r3, #8
   14134:	f102 022c 	add.w	r2, r2, #44	; 0x2c
   14138:	d1ea      	bne.n	14110 <interface_sockets_aux_state_clear+0xc>
   1413a:	bd70      	pop	{r4, r5, r6, pc}
   1413c:	2000ca68 	.word	0x2000ca68

00014140 <interface_from_internal_id_search>:
   14140:	4b0a      	ldr	r3, [pc, #40]	; (1416c <interface_from_internal_id_search+0x2c>)
   14142:	4602      	mov	r2, r0
   14144:	b530      	push	{r4, r5, lr}
   14146:	2000      	movs	r0, #0
   14148:	461c      	mov	r4, r3
   1414a:	212c      	movs	r1, #44	; 0x2c
   1414c:	fb01 f500 	mul.w	r5, r1, r0
   14150:	5965      	ldr	r5, [r4, r5]
   14152:	b115      	cbz	r5, 1415a <interface_from_internal_id_search+0x1a>
   14154:	699d      	ldr	r5, [r3, #24]
   14156:	4295      	cmp	r5, r2
   14158:	d006      	beq.n	14168 <interface_from_internal_id_search+0x28>
   1415a:	3001      	adds	r0, #1
   1415c:	2808      	cmp	r0, #8
   1415e:	f103 032c 	add.w	r3, r3, #44	; 0x2c
   14162:	d1f3      	bne.n	1414c <interface_from_internal_id_search+0xc>
   14164:	f04f 30ff 	mov.w	r0, #4294967295
   14168:	bd30      	pop	{r4, r5, pc}
   1416a:	bf00      	nop
   1416c:	2000ca68 	.word	0x2000ca68

00014170 <interface_socket_from_handle_get>:
   14170:	2807      	cmp	r0, #7
   14172:	d808      	bhi.n	14186 <interface_socket_from_handle_get+0x16>
   14174:	232c      	movs	r3, #44	; 0x2c
   14176:	4343      	muls	r3, r0
   14178:	4a04      	ldr	r2, [pc, #16]	; (1418c <interface_socket_from_handle_get+0x1c>)
   1417a:	18d0      	adds	r0, r2, r3
   1417c:	58d3      	ldr	r3, [r2, r3]
   1417e:	2b00      	cmp	r3, #0
   14180:	bf08      	it	eq
   14182:	2000      	moveq	r0, #0
   14184:	4770      	bx	lr
   14186:	2000      	movs	r0, #0
   14188:	4770      	bx	lr
   1418a:	bf00      	nop
   1418c:	2000ca68 	.word	0x2000ca68

00014190 <rpc_error_to_nrf_errno>:
   14190:	286a      	cmp	r0, #106	; 0x6a
   14192:	bf9a      	itte	ls
   14194:	4b01      	ldrls	r3, [pc, #4]	; (1419c <rpc_error_to_nrf_errno+0xc>)
   14196:	5c18      	ldrbls	r0, [r3, r0]
   14198:	205f      	movhi	r0, #95	; 0x5f
   1419a:	4770      	bx	lr
   1419c:	00017583 	.word	0x00017583

000141a0 <rpc_error_to_nrf_gai_errno>:
   141a0:	2805      	cmp	r0, #5
   141a2:	d013      	beq.n	141cc <rpc_error_to_nrf_gai_errno+0x2c>
   141a4:	d807      	bhi.n	141b6 <rpc_error_to_nrf_gai_errno+0x16>
   141a6:	b170      	cbz	r0, 141c6 <rpc_error_to_nrf_gai_errno+0x26>
   141a8:	4b0b      	ldr	r3, [pc, #44]	; (141d8 <rpc_error_to_nrf_gai_errno+0x38>)
   141aa:	5c1b      	ldrb	r3, [r3, r0]
   141ac:	4a0b      	ldr	r2, [pc, #44]	; (141dc <rpc_error_to_nrf_gai_errno+0x3c>)
   141ae:	f240 1015 	movw	r0, #277	; 0x115
   141b2:	6013      	str	r3, [r2, #0]
   141b4:	4770      	bx	lr
   141b6:	2806      	cmp	r0, #6
   141b8:	d00b      	beq.n	141d2 <rpc_error_to_nrf_gai_errno+0x32>
   141ba:	280d      	cmp	r0, #13
   141bc:	d009      	beq.n	141d2 <rpc_error_to_nrf_gai_errno+0x32>
   141be:	286a      	cmp	r0, #106	; 0x6a
   141c0:	d9f2      	bls.n	141a8 <rpc_error_to_nrf_gai_errno+0x8>
   141c2:	235f      	movs	r3, #95	; 0x5f
   141c4:	e7f2      	b.n	141ac <rpc_error_to_nrf_gai_errno+0xc>
   141c6:	4b05      	ldr	r3, [pc, #20]	; (141dc <rpc_error_to_nrf_gai_errno+0x3c>)
   141c8:	6018      	str	r0, [r3, #0]
   141ca:	4770      	bx	lr
   141cc:	f44f 708a 	mov.w	r0, #276	; 0x114
   141d0:	4770      	bx	lr
   141d2:	f240 1011 	movw	r0, #273	; 0x111
   141d6:	4770      	bx	lr
   141d8:	00017583 	.word	0x00017583
   141dc:	2000cbd0 	.word	0x2000cbd0

000141e0 <ip_interface_init>:
   141e0:	b510      	push	{r4, lr}
   141e2:	2400      	movs	r4, #0
   141e4:	4b06      	ldr	r3, [pc, #24]	; (14200 <ip_interface_init+0x20>)
   141e6:	2220      	movs	r2, #32
   141e8:	601c      	str	r4, [r3, #0]
   141ea:	4b06      	ldr	r3, [pc, #24]	; (14204 <ip_interface_init+0x24>)
   141ec:	4621      	mov	r1, r4
   141ee:	4806      	ldr	r0, [pc, #24]	; (14208 <ip_interface_init+0x28>)
   141f0:	601c      	str	r4, [r3, #0]
   141f2:	f002 f9d4 	bl	1659e <memset>
   141f6:	2201      	movs	r2, #1
   141f8:	4b04      	ldr	r3, [pc, #16]	; (1420c <ip_interface_init+0x2c>)
   141fa:	4620      	mov	r0, r4
   141fc:	701a      	strb	r2, [r3, #0]
   141fe:	bd10      	pop	{r4, pc}
   14200:	2000cbdc 	.word	0x2000cbdc
   14204:	2000cbd8 	.word	0x2000cbd8
   14208:	2000cbe0 	.word	0x2000cbe0
   1420c:	2000ccc5 	.word	0x2000ccc5

00014210 <rpc_ip_event_handler>:
   14210:	f248 030f 	movw	r3, #32783	; 0x800f
   14214:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14218:	4299      	cmp	r1, r3
   1421a:	4604      	mov	r4, r0
   1421c:	460e      	mov	r6, r1
   1421e:	b089      	sub	sp, #36	; 0x24
   14220:	f000 80a4 	beq.w	1436c <rpc_ip_event_handler+0x15c>
   14224:	f249 0304 	movw	r3, #36868	; 0x9004
   14228:	4299      	cmp	r1, r3
   1422a:	f000 80ab 	beq.w	14384 <rpc_ip_event_handler+0x174>
   1422e:	f248 030d 	movw	r3, #32781	; 0x800d
   14232:	4299      	cmp	r1, r3
   14234:	f040 80b8 	bne.w	143a8 <rpc_ip_event_handler+0x198>
   14238:	4bbc      	ldr	r3, [pc, #752]	; (1452c <rpc_ip_event_handler+0x31c>)
   1423a:	681a      	ldr	r2, [r3, #0]
   1423c:	9303      	str	r3, [sp, #12]
   1423e:	2a01      	cmp	r2, #1
   14240:	d12d      	bne.n	1429e <rpc_ip_event_handler+0x8e>
   14242:	6940      	ldr	r0, [r0, #20]
   14244:	2800      	cmp	r0, #0
   14246:	f040 808c 	bne.w	14362 <rpc_ip_event_handler+0x152>
   1424a:	f8d4 a018 	ldr.w	sl, [r4, #24]
   1424e:	f8d4 8000 	ldr.w	r8, [r4]
   14252:	ea4f 134a 	mov.w	r3, sl, lsl #5
   14256:	4618      	mov	r0, r3
   14258:	9301      	str	r3, [sp, #4]
   1425a:	f7fe fd8b 	bl	12d74 <nrf_modem_os_alloc>
   1425e:	4607      	mov	r7, r0
   14260:	b310      	cbz	r0, 142a8 <rpc_ip_event_handler+0x98>
   14262:	2024      	movs	r0, #36	; 0x24
   14264:	fb00 f00a 	mul.w	r0, r0, sl
   14268:	f7fe fd84 	bl	12d74 <nrf_modem_os_alloc>
   1426c:	4605      	mov	r5, r0
   1426e:	b1e8      	cbz	r0, 142ac <rpc_ip_event_handler+0x9c>
   14270:	2604      	movs	r6, #4
   14272:	eb00 03ca 	add.w	r3, r0, sl, lsl #3
   14276:	f107 0920 	add.w	r9, r7, #32
   1427a:	9302      	str	r3, [sp, #8]
   1427c:	9b02      	ldr	r3, [sp, #8]
   1427e:	42ab      	cmp	r3, r5
   14280:	d118      	bne.n	142b4 <rpc_ip_event_handler+0xa4>
   14282:	f1ba 0f00 	cmp.w	sl, #0
   14286:	d005      	beq.n	14294 <rpc_ip_event_handler+0x84>
   14288:	9b01      	ldr	r3, [sp, #4]
   1428a:	443b      	add	r3, r7
   1428c:	4699      	mov	r9, r3
   1428e:	2300      	movs	r3, #0
   14290:	f849 3c04 	str.w	r3, [r9, #-4]
   14294:	4ba6      	ldr	r3, [pc, #664]	; (14530 <rpc_ip_event_handler+0x320>)
   14296:	601f      	str	r7, [r3, #0]
   14298:	2302      	movs	r3, #2
   1429a:	9a03      	ldr	r2, [sp, #12]
   1429c:	6013      	str	r3, [r2, #0]
   1429e:	6820      	ldr	r0, [r4, #0]
   142a0:	2800      	cmp	r0, #0
   142a2:	f040 81c7 	bne.w	14634 <rpc_ip_event_handler+0x424>
   142a6:	e1c7      	b.n	14638 <rpc_ip_event_handler+0x428>
   142a8:	f7fe fd6c 	bl	12d84 <nrf_modem_os_free>
   142ac:	220c      	movs	r2, #12
   142ae:	4ba1      	ldr	r3, [pc, #644]	; (14534 <rpc_ip_event_handler+0x324>)
   142b0:	601a      	str	r2, [r3, #0]
   142b2:	e7ef      	b.n	14294 <rpc_ip_event_handler+0x84>
   142b4:	f858 2006 	ldr.w	r2, [r8, r6]
   142b8:	eb08 0106 	add.w	r1, r8, r6
   142bc:	f849 2c20 	str.w	r2, [r9, #-32]
   142c0:	eb08 0206 	add.w	r2, r8, r6
   142c4:	6852      	ldr	r2, [r2, #4]
   142c6:	f8b1 b012 	ldrh.w	fp, [r1, #18]
   142ca:	3a01      	subs	r2, #1
   142cc:	2a04      	cmp	r2, #4
   142ce:	bf8c      	ite	hi
   142d0:	2200      	movhi	r2, #0
   142d2:	4b99      	ldrls	r3, [pc, #612]	; (14538 <rpc_ip_event_handler+0x328>)
   142d4:	f106 0614 	add.w	r6, r6, #20
   142d8:	bf98      	it	ls
   142da:	569a      	ldrsbls	r2, [r3, r2]
   142dc:	4b97      	ldr	r3, [pc, #604]	; (1453c <rpc_ip_event_handler+0x32c>)
   142de:	f849 2c1c 	str.w	r2, [r9, #-28]
   142e2:	681a      	ldr	r2, [r3, #0]
   142e4:	4b96      	ldr	r3, [pc, #600]	; (14540 <rpc_ip_event_handler+0x330>)
   142e6:	f849 2c18 	str.w	r2, [r9, #-24]
   142ea:	681a      	ldr	r2, [r3, #0]
   142ec:	f849 2c14 	str.w	r2, [r9, #-20]
   142f0:	8a0a      	ldrh	r2, [r1, #16]
   142f2:	4994      	ldr	r1, [pc, #592]	; (14544 <rpc_ip_event_handler+0x334>)
   142f4:	2a04      	cmp	r2, #4
   142f6:	8808      	ldrh	r0, [r1, #0]
   142f8:	f849 2c10 	str.w	r2, [r9, #-16]
   142fc:	f849 5c0c 	str.w	r5, [r9, #-12]
   14300:	eb08 0106 	add.w	r1, r8, r6
   14304:	d121      	bne.n	1434a <rpc_ip_event_handler+0x13a>
   14306:	2202      	movs	r2, #2
   14308:	606a      	str	r2, [r5, #4]
   1430a:	2210      	movs	r2, #16
   1430c:	8128      	strh	r0, [r5, #8]
   1430e:	702a      	strb	r2, [r5, #0]
   14310:	680a      	ldr	r2, [r1, #0]
   14312:	60ea      	str	r2, [r5, #12]
   14314:	f859 2c10 	ldr.w	r2, [r9, #-16]
   14318:	f10b 0001 	add.w	r0, fp, #1
   1431c:	4416      	add	r6, r2
   1431e:	f7fe fd29 	bl	12d74 <nrf_modem_os_alloc>
   14322:	f849 0c08 	str.w	r0, [r9, #-8]
   14326:	b148      	cbz	r0, 1433c <rpc_ip_event_handler+0x12c>
   14328:	465a      	mov	r2, fp
   1432a:	eb08 0106 	add.w	r1, r8, r6
   1432e:	f002 f92b 	bl	16588 <memcpy>
   14332:	2100      	movs	r1, #0
   14334:	f859 2c08 	ldr.w	r2, [r9, #-8]
   14338:	f802 100b 	strb.w	r1, [r2, fp]
   1433c:	f849 9c04 	str.w	r9, [r9, #-4]
   14340:	445e      	add	r6, fp
   14342:	f109 0920 	add.w	r9, r9, #32
   14346:	3508      	adds	r5, #8
   14348:	e798      	b.n	1427c <rpc_ip_event_handler+0x6c>
   1434a:	230a      	movs	r3, #10
   1434c:	f04f 0c24 	mov.w	ip, #36	; 0x24
   14350:	8128      	strh	r0, [r5, #8]
   14352:	606b      	str	r3, [r5, #4]
   14354:	f885 c000 	strb.w	ip, [r5]
   14358:	f105 0010 	add.w	r0, r5, #16
   1435c:	f002 f914 	bl	16588 <memcpy>
   14360:	e7d8      	b.n	14314 <rpc_ip_event_handler+0x104>
   14362:	f7ff ff1d 	bl	141a0 <rpc_error_to_nrf_gai_errno>
   14366:	4b73      	ldr	r3, [pc, #460]	; (14534 <rpc_ip_event_handler+0x324>)
   14368:	6018      	str	r0, [r3, #0]
   1436a:	e795      	b.n	14298 <rpc_ip_event_handler+0x88>
   1436c:	6943      	ldr	r3, [r0, #20]
   1436e:	2b6a      	cmp	r3, #106	; 0x6a
   14370:	bf8e      	itee	hi
   14372:	235f      	movhi	r3, #95	; 0x5f
   14374:	4a74      	ldrls	r2, [pc, #464]	; (14548 <rpc_ip_event_handler+0x338>)
   14376:	5cd3      	ldrbls	r3, [r2, r3]
   14378:	4a74      	ldr	r2, [pc, #464]	; (1454c <rpc_ip_event_handler+0x33c>)
   1437a:	6013      	str	r3, [r2, #0]
   1437c:	4b74      	ldr	r3, [pc, #464]	; (14550 <rpc_ip_event_handler+0x340>)
   1437e:	2201      	movs	r2, #1
   14380:	701a      	strb	r2, [r3, #0]
   14382:	e159      	b.n	14638 <rpc_ip_event_handler+0x428>
   14384:	6903      	ldr	r3, [r0, #16]
   14386:	2b03      	cmp	r3, #3
   14388:	d807      	bhi.n	1439a <rpc_ip_event_handler+0x18a>
   1438a:	e8df f003 	tbb	[pc, r3]
   1438e:	0802      	.short	0x0802
   14390:	0802      	.short	0x0802
   14392:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   14396:	f7ff fe97 	bl	140c8 <interface_sockets_aux_state_set>
   1439a:	4b6e      	ldr	r3, [pc, #440]	; (14554 <rpc_ip_event_handler+0x344>)
   1439c:	e7ef      	b.n	1437e <rpc_ip_event_handler+0x16e>
   1439e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
   143a2:	f7ff feaf 	bl	14104 <interface_sockets_aux_state_clear>
   143a6:	e7f8      	b.n	1439a <rpc_ip_event_handler+0x18a>
   143a8:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   143ac:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   143b0:	68c0      	ldr	r0, [r0, #12]
   143b2:	d13b      	bne.n	1442c <rpc_ip_event_handler+0x21c>
   143b4:	f7ff fec4 	bl	14140 <interface_from_internal_id_search>
   143b8:	4607      	mov	r7, r0
   143ba:	4638      	mov	r0, r7
   143bc:	f7ff fed8 	bl	14170 <interface_socket_from_handle_get>
   143c0:	4605      	mov	r5, r0
   143c2:	2800      	cmp	r0, #0
   143c4:	f43f af6b 	beq.w	1429e <rpc_ip_event_handler+0x8e>
   143c8:	4601      	mov	r1, r0
   143ca:	4633      	mov	r3, r6
   143cc:	4622      	mov	r2, r4
   143ce:	4638      	mov	r0, r7
   143d0:	f000 f9f4 	bl	147bc <tls_rpc_ip_event_handler>
   143d4:	2800      	cmp	r0, #0
   143d6:	f000 812f 	beq.w	14638 <rpc_ip_event_handler+0x428>
   143da:	f248 030c 	movw	r3, #32780	; 0x800c
   143de:	429e      	cmp	r6, r3
   143e0:	d826      	bhi.n	14430 <rpc_ip_event_handler+0x220>
   143e2:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
   143e6:	f67f af5a 	bls.w	1429e <rpc_ip_event_handler+0x8e>
   143ea:	f5a6 4600 	sub.w	r6, r6, #32768	; 0x8000
   143ee:	3e01      	subs	r6, #1
   143f0:	2e0b      	cmp	r6, #11
   143f2:	f63f af54 	bhi.w	1429e <rpc_ip_event_handler+0x8e>
   143f6:	a301      	add	r3, pc, #4	; (adr r3, 143fc <rpc_ip_event_handler+0x1ec>)
   143f8:	f853 f026 	ldr.w	pc, [r3, r6, lsl #2]
   143fc:	000144c1 	.word	0x000144c1
   14400:	00014575 	.word	0x00014575
   14404:	00014691 	.word	0x00014691
   14408:	000146af 	.word	0x000146af
   1440c:	00014559 	.word	0x00014559
   14410:	00014641 	.word	0x00014641
   14414:	00014641 	.word	0x00014641
   14418:	000145b9 	.word	0x000145b9
   1441c:	000144db 	.word	0x000144db
   14420:	0001429f 	.word	0x0001429f
   14424:	0001429f 	.word	0x0001429f
   14428:	000145e3 	.word	0x000145e3
   1442c:	0c07      	lsrs	r7, r0, #16
   1442e:	e7c4      	b.n	143ba <rpc_ip_event_handler+0x1aa>
   14430:	f249 0302 	movw	r3, #36866	; 0x9002
   14434:	429e      	cmp	r6, r3
   14436:	f000 80cc 	beq.w	145d2 <rpc_ip_event_handler+0x3c2>
   1443a:	f249 0303 	movw	r3, #36867	; 0x9003
   1443e:	429e      	cmp	r6, r3
   14440:	d05b      	beq.n	144fa <rpc_ip_event_handler+0x2ea>
   14442:	f249 0301 	movw	r3, #36865	; 0x9001
   14446:	429e      	cmp	r6, r3
   14448:	f47f af29 	bne.w	1429e <rpc_ip_event_handler+0x8e>
   1444c:	682e      	ldr	r6, [r5, #0]
   1444e:	f416 1680 	ands.w	r6, r6, #1048576	; 0x100000
   14452:	f000 80ee 	beq.w	14632 <rpc_ip_event_handler+0x422>
   14456:	68a3      	ldr	r3, [r4, #8]
   14458:	2b04      	cmp	r3, #4
   1445a:	f240 80e7 	bls.w	1462c <rpc_ip_event_handler+0x41c>
   1445e:	8a63      	ldrh	r3, [r4, #18]
   14460:	2b00      	cmp	r3, #0
   14462:	f000 80e4 	beq.w	1462e <rpc_ip_event_handler+0x41e>
   14466:	2b10      	cmp	r3, #16
   14468:	f040 80cc 	bne.w	14604 <rpc_ip_event_handler+0x3f4>
   1446c:	2024      	movs	r0, #36	; 0x24
   1446e:	f7fe fc81 	bl	12d74 <nrf_modem_os_alloc>
   14472:	b318      	cbz	r0, 144bc <rpc_ip_event_handler+0x2ac>
   14474:	230a      	movs	r3, #10
   14476:	6043      	str	r3, [r0, #4]
   14478:	2324      	movs	r3, #36	; 0x24
   1447a:	7003      	strb	r3, [r0, #0]
   1447c:	7c62      	ldrb	r2, [r4, #17]
   1447e:	7c23      	ldrb	r3, [r4, #16]
   14480:	f104 0124 	add.w	r1, r4, #36	; 0x24
   14484:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   14488:	8103      	strh	r3, [r0, #8]
   1448a:	f100 0210 	add.w	r2, r0, #16
   1448e:	f104 0314 	add.w	r3, r4, #20
   14492:	f853 6b04 	ldr.w	r6, [r3], #4
   14496:	428b      	cmp	r3, r1
   14498:	f842 6b04 	str.w	r6, [r2], #4
   1449c:	d1f9      	bne.n	14492 <rpc_ip_event_handler+0x282>
   1449e:	2324      	movs	r3, #36	; 0x24
   144a0:	6822      	ldr	r2, [r4, #0]
   144a2:	9307      	str	r3, [sp, #28]
   144a4:	9204      	str	r2, [sp, #16]
   144a6:	6862      	ldr	r2, [r4, #4]
   144a8:	a904      	add	r1, sp, #16
   144aa:	e9cd 2005 	strd	r2, r0, [sp, #20]
   144ae:	69e8      	ldr	r0, [r5, #28]
   144b0:	6803      	ldr	r3, [r0, #0]
   144b2:	685b      	ldr	r3, [r3, #4]
   144b4:	4798      	blx	r3
   144b6:	3001      	adds	r0, #1
   144b8:	f040 808f 	bne.w	145da <rpc_ip_event_handler+0x3ca>
   144bc:	2002      	movs	r0, #2
   144be:	e0bc      	b.n	1463a <rpc_ip_event_handler+0x42a>
   144c0:	682b      	ldr	r3, [r5, #0]
   144c2:	2b01      	cmp	r3, #1
   144c4:	f040 80b8 	bne.w	14638 <rpc_ip_event_handler+0x428>
   144c8:	6960      	ldr	r0, [r4, #20]
   144ca:	2800      	cmp	r0, #0
   144cc:	f040 80e9 	bne.w	146a2 <rpc_ip_event_handler+0x492>
   144d0:	2302      	movs	r3, #2
   144d2:	602b      	str	r3, [r5, #0]
   144d4:	69a3      	ldr	r3, [r4, #24]
   144d6:	61ab      	str	r3, [r5, #24]
   144d8:	e0af      	b.n	1463a <rpc_ip_event_handler+0x42a>
   144da:	682b      	ldr	r3, [r5, #0]
   144dc:	b29b      	uxth	r3, r3
   144de:	2b0d      	cmp	r3, #13
   144e0:	f040 80aa 	bne.w	14638 <rpc_ip_event_handler+0x428>
   144e4:	6960      	ldr	r0, [r4, #20]
   144e6:	2800      	cmp	r0, #0
   144e8:	f040 80db 	bne.w	146a2 <rpc_ip_event_handler+0x492>
   144ec:	682b      	ldr	r3, [r5, #0]
   144ee:	0c1b      	lsrs	r3, r3, #16
   144f0:	041b      	lsls	r3, r3, #16
   144f2:	f043 030e 	orr.w	r3, r3, #14
   144f6:	602b      	str	r3, [r5, #0]
   144f8:	e09f      	b.n	1463a <rpc_ip_event_handler+0x42a>
   144fa:	682b      	ldr	r3, [r5, #0]
   144fc:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   14500:	602b      	str	r3, [r5, #0]
   14502:	682b      	ldr	r3, [r5, #0]
   14504:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   14508:	602b      	str	r3, [r5, #0]
   1450a:	6923      	ldr	r3, [r4, #16]
   1450c:	2b6c      	cmp	r3, #108	; 0x6c
   1450e:	d107      	bne.n	14520 <rpc_ip_event_handler+0x310>
   14510:	682b      	ldr	r3, [r5, #0]
   14512:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   14516:	602b      	str	r3, [r5, #0]
   14518:	2380      	movs	r3, #128	; 0x80
   1451a:	606b      	str	r3, [r5, #4]
   1451c:	60ab      	str	r3, [r5, #8]
   1451e:	e08b      	b.n	14638 <rpc_ip_event_handler+0x428>
   14520:	2b6a      	cmp	r3, #106	; 0x6a
   14522:	bf96      	itet	ls
   14524:	4a08      	ldrls	r2, [pc, #32]	; (14548 <rpc_ip_event_handler+0x338>)
   14526:	235f      	movhi	r3, #95	; 0x5f
   14528:	5cd3      	ldrbls	r3, [r2, r3]
   1452a:	e7f6      	b.n	1451a <rpc_ip_event_handler+0x30a>
   1452c:	2000cbd8 	.word	0x2000cbd8
   14530:	2000cbdc 	.word	0x2000cbdc
   14534:	2000cbd4 	.word	0x2000cbd4
   14538:	0001757e 	.word	0x0001757e
   1453c:	2000cbcc 	.word	0x2000cbcc
   14540:	2000cbc8 	.word	0x2000cbc8
   14544:	2000ccba 	.word	0x2000ccba
   14548:	00017583 	.word	0x00017583
   1454c:	2000cc00 	.word	0x2000cc00
   14550:	2000ccc6 	.word	0x2000ccc6
   14554:	2000ccc4 	.word	0x2000ccc4
   14558:	682b      	ldr	r3, [r5, #0]
   1455a:	b29b      	uxth	r3, r3
   1455c:	2b03      	cmp	r3, #3
   1455e:	d16b      	bne.n	14638 <rpc_ip_event_handler+0x428>
   14560:	6960      	ldr	r0, [r4, #20]
   14562:	2800      	cmp	r0, #0
   14564:	f040 809d 	bne.w	146a2 <rpc_ip_event_handler+0x492>
   14568:	682b      	ldr	r3, [r5, #0]
   1456a:	0c1b      	lsrs	r3, r3, #16
   1456c:	041b      	lsls	r3, r3, #16
   1456e:	f043 0304 	orr.w	r3, r3, #4
   14572:	e7c0      	b.n	144f6 <rpc_ip_event_handler+0x2e6>
   14574:	682b      	ldr	r3, [r5, #0]
   14576:	0099      	lsls	r1, r3, #2
   14578:	d55e      	bpl.n	14638 <rpc_ip_event_handler+0x428>
   1457a:	682b      	ldr	r3, [r5, #0]
   1457c:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   14580:	602b      	str	r3, [r5, #0]
   14582:	6960      	ldr	r0, [r4, #20]
   14584:	b968      	cbnz	r0, 145a2 <rpc_ip_event_handler+0x392>
   14586:	682b      	ldr	r3, [r5, #0]
   14588:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1458c:	602b      	str	r3, [r5, #0]
   1458e:	682b      	ldr	r3, [r5, #0]
   14590:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   14594:	602b      	str	r3, [r5, #0]
   14596:	682b      	ldr	r3, [r5, #0]
   14598:	0c1b      	lsrs	r3, r3, #16
   1459a:	041b      	lsls	r3, r3, #16
   1459c:	f043 0305 	orr.w	r3, r3, #5
   145a0:	e7a9      	b.n	144f6 <rpc_ip_event_handler+0x2e6>
   145a2:	286a      	cmp	r0, #106	; 0x6a
   145a4:	bf8e      	itee	hi
   145a6:	235f      	movhi	r3, #95	; 0x5f
   145a8:	4b4c      	ldrls	r3, [pc, #304]	; (146dc <rpc_ip_event_handler+0x4cc>)
   145aa:	5c1b      	ldrbls	r3, [r3, r0]
   145ac:	606b      	str	r3, [r5, #4]
   145ae:	682b      	ldr	r3, [r5, #0]
   145b0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   145b4:	602b      	str	r3, [r5, #0]
   145b6:	e03f      	b.n	14638 <rpc_ip_event_handler+0x428>
   145b8:	682b      	ldr	r3, [r5, #0]
   145ba:	b29b      	uxth	r3, r3
   145bc:	2b06      	cmp	r3, #6
   145be:	d13b      	bne.n	14638 <rpc_ip_event_handler+0x428>
   145c0:	6960      	ldr	r0, [r4, #20]
   145c2:	2800      	cmp	r0, #0
   145c4:	d16d      	bne.n	146a2 <rpc_ip_event_handler+0x492>
   145c6:	682b      	ldr	r3, [r5, #0]
   145c8:	0c1b      	lsrs	r3, r3, #16
   145ca:	041b      	lsls	r3, r3, #16
   145cc:	f043 0307 	orr.w	r3, r3, #7
   145d0:	e791      	b.n	144f6 <rpc_ip_event_handler+0x2e6>
   145d2:	682b      	ldr	r3, [r5, #0]
   145d4:	b29b      	uxth	r3, r3
   145d6:	2b07      	cmp	r3, #7
   145d8:	d12e      	bne.n	14638 <rpc_ip_event_handler+0x428>
   145da:	682b      	ldr	r3, [r5, #0]
   145dc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   145e0:	e7e8      	b.n	145b4 <rpc_ip_event_handler+0x3a4>
   145e2:	682b      	ldr	r3, [r5, #0]
   145e4:	b29b      	uxth	r3, r3
   145e6:	2b08      	cmp	r3, #8
   145e8:	d126      	bne.n	14638 <rpc_ip_event_handler+0x428>
   145ea:	6963      	ldr	r3, [r4, #20]
   145ec:	2b00      	cmp	r3, #0
   145ee:	d16d      	bne.n	146cc <rpc_ip_event_handler+0x4bc>
   145f0:	4b3b      	ldr	r3, [pc, #236]	; (146e0 <rpc_ip_event_handler+0x4d0>)
   145f2:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   145f6:	682b      	ldr	r3, [r5, #0]
   145f8:	0c1b      	lsrs	r3, r3, #16
   145fa:	041b      	lsls	r3, r3, #16
   145fc:	f043 0309 	orr.w	r3, r3, #9
   14600:	602b      	str	r3, [r5, #0]
   14602:	e032      	b.n	1466a <rpc_ip_event_handler+0x45a>
   14604:	2b04      	cmp	r3, #4
   14606:	d114      	bne.n	14632 <rpc_ip_event_handler+0x422>
   14608:	2010      	movs	r0, #16
   1460a:	f7fe fbb3 	bl	12d74 <nrf_modem_os_alloc>
   1460e:	2800      	cmp	r0, #0
   14610:	f43f af54 	beq.w	144bc <rpc_ip_event_handler+0x2ac>
   14614:	2302      	movs	r3, #2
   14616:	6043      	str	r3, [r0, #4]
   14618:	2310      	movs	r3, #16
   1461a:	7003      	strb	r3, [r0, #0]
   1461c:	7c22      	ldrb	r2, [r4, #16]
   1461e:	7c61      	ldrb	r1, [r4, #17]
   14620:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   14624:	8102      	strh	r2, [r0, #8]
   14626:	6962      	ldr	r2, [r4, #20]
   14628:	60c2      	str	r2, [r0, #12]
   1462a:	e739      	b.n	144a0 <rpc_ip_event_handler+0x290>
   1462c:	2300      	movs	r3, #0
   1462e:	4618      	mov	r0, r3
   14630:	e736      	b.n	144a0 <rpc_ip_event_handler+0x290>
   14632:	6820      	ldr	r0, [r4, #0]
   14634:	f002 f9e1 	bl	169fa <rpc_client_data_free>
   14638:	2000      	movs	r0, #0
   1463a:	b009      	add	sp, #36	; 0x24
   1463c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14640:	4b27      	ldr	r3, [pc, #156]	; (146e0 <rpc_ip_event_handler+0x4d0>)
   14642:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   14646:	6963      	ldr	r3, [r4, #20]
   14648:	b17b      	cbz	r3, 1466a <rpc_ip_event_handler+0x45a>
   1464a:	2b6b      	cmp	r3, #107	; 0x6b
   1464c:	d10f      	bne.n	1466e <rpc_ip_event_handler+0x45e>
   1464e:	6928      	ldr	r0, [r5, #16]
   14650:	220c      	movs	r2, #12
   14652:	2801      	cmp	r0, #1
   14654:	682b      	ldr	r3, [r5, #0]
   14656:	d104      	bne.n	14662 <rpc_ip_event_handler+0x452>
   14658:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   1465c:	602b      	str	r3, [r5, #0]
   1465e:	606a      	str	r2, [r5, #4]
   14660:	e7eb      	b.n	1463a <rpc_ip_event_handler+0x42a>
   14662:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   14666:	602b      	str	r3, [r5, #0]
   14668:	606a      	str	r2, [r5, #4]
   1466a:	2001      	movs	r0, #1
   1466c:	e7e5      	b.n	1463a <rpc_ip_event_handler+0x42a>
   1466e:	f023 0002 	bic.w	r0, r3, #2
   14672:	2801      	cmp	r0, #1
   14674:	d102      	bne.n	1467c <rpc_ip_event_handler+0x46c>
   14676:	230c      	movs	r3, #12
   14678:	606b      	str	r3, [r5, #4]
   1467a:	e7de      	b.n	1463a <rpc_ip_event_handler+0x42a>
   1467c:	2b6a      	cmp	r3, #106	; 0x6a
   1467e:	bf8e      	itee	hi
   14680:	235f      	movhi	r3, #95	; 0x5f
   14682:	4a16      	ldrls	r2, [pc, #88]	; (146dc <rpc_ip_event_handler+0x4cc>)
   14684:	5cd3      	ldrbls	r3, [r2, r3]
   14686:	606b      	str	r3, [r5, #4]
   14688:	682b      	ldr	r3, [r5, #0]
   1468a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   1468e:	e7b7      	b.n	14600 <rpc_ip_event_handler+0x3f0>
   14690:	682b      	ldr	r3, [r5, #0]
   14692:	025a      	lsls	r2, r3, #9
   14694:	d5d0      	bpl.n	14638 <rpc_ip_event_handler+0x428>
   14696:	6960      	ldr	r0, [r4, #20]
   14698:	b918      	cbnz	r0, 146a2 <rpc_ip_event_handler+0x492>
   1469a:	682b      	ldr	r3, [r5, #0]
   1469c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   146a0:	e729      	b.n	144f6 <rpc_ip_event_handler+0x2e6>
   146a2:	286a      	cmp	r0, #106	; 0x6a
   146a4:	d817      	bhi.n	146d6 <rpc_ip_event_handler+0x4c6>
   146a6:	4b0d      	ldr	r3, [pc, #52]	; (146dc <rpc_ip_event_handler+0x4cc>)
   146a8:	5c1b      	ldrb	r3, [r3, r0]
   146aa:	606b      	str	r3, [r5, #4]
   146ac:	e7c4      	b.n	14638 <rpc_ip_event_handler+0x428>
   146ae:	682b      	ldr	r3, [r5, #0]
   146b0:	01db      	lsls	r3, r3, #7
   146b2:	d5c1      	bpl.n	14638 <rpc_ip_event_handler+0x428>
   146b4:	6963      	ldr	r3, [r4, #20]
   146b6:	b94b      	cbnz	r3, 146cc <rpc_ip_event_handler+0x4bc>
   146b8:	6820      	ldr	r0, [r4, #0]
   146ba:	b118      	cbz	r0, 146c4 <rpc_ip_event_handler+0x4b4>
   146bc:	2001      	movs	r0, #1
   146be:	4b08      	ldr	r3, [pc, #32]	; (146e0 <rpc_ip_event_handler+0x4d0>)
   146c0:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   146c4:	682b      	ldr	r3, [r5, #0]
   146c6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   146ca:	e714      	b.n	144f6 <rpc_ip_event_handler+0x2e6>
   146cc:	2b6a      	cmp	r3, #106	; 0x6a
   146ce:	d802      	bhi.n	146d6 <rpc_ip_event_handler+0x4c6>
   146d0:	4a02      	ldr	r2, [pc, #8]	; (146dc <rpc_ip_event_handler+0x4cc>)
   146d2:	5cd3      	ldrb	r3, [r2, r3]
   146d4:	e7e9      	b.n	146aa <rpc_ip_event_handler+0x49a>
   146d6:	235f      	movs	r3, #95	; 0x5f
   146d8:	e7e7      	b.n	146aa <rpc_ip_event_handler+0x49a>
   146da:	bf00      	nop
   146dc:	00017583 	.word	0x00017583
   146e0:	2000cbe0 	.word	0x2000cbe0

000146e4 <hostname_free>:
   146e4:	b538      	push	{r3, r4, r5, lr}
   146e6:	4c07      	ldr	r4, [pc, #28]	; (14704 <hostname_free+0x20>)
   146e8:	4605      	mov	r5, r0
   146ea:	f854 0030 	ldr.w	r0, [r4, r0, lsl #3]
   146ee:	b138      	cbz	r0, 14700 <hostname_free+0x1c>
   146f0:	f7fe fb48 	bl	12d84 <nrf_modem_os_free>
   146f4:	2300      	movs	r3, #0
   146f6:	f844 3035 	str.w	r3, [r4, r5, lsl #3]
   146fa:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   146fe:	6063      	str	r3, [r4, #4]
   14700:	bd38      	pop	{r3, r4, r5, pc}
   14702:	bf00      	nop
   14704:	2000cc04 	.word	0x2000cc04

00014708 <secure_socket_attach_initiate>:
   14708:	f04f 33ff 	mov.w	r3, #4294967295
   1470c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   14710:	f8df 8094 	ldr.w	r8, [pc, #148]	; 147a8 <secure_socket_attach_initiate+0xa0>
   14714:	9301      	str	r3, [sp, #4]
   14716:	eb08 09c0 	add.w	r9, r8, r0, lsl #3
   1471a:	460d      	mov	r5, r1
   1471c:	4616      	mov	r6, r2
   1471e:	f8d9 3004 	ldr.w	r3, [r9, #4]
   14722:	f247 0281 	movw	r2, #28801	; 0x7081
   14726:	6989      	ldr	r1, [r1, #24]
   14728:	4607      	mov	r7, r0
   1472a:	f002 f968 	bl	169fe <ip_interface_request_create>
   1472e:	4604      	mov	r4, r0
   14730:	b398      	cbz	r0, 1479a <secure_socket_attach_initiate+0x92>
   14732:	f8d9 2004 	ldr.w	r2, [r9, #4]
   14736:	b122      	cbz	r2, 14742 <secure_socket_attach_initiate+0x3a>
   14738:	f858 1037 	ldr.w	r1, [r8, r7, lsl #3]
   1473c:	6800      	ldr	r0, [r0, #0]
   1473e:	f001 ff23 	bl	16588 <memcpy>
   14742:	2324      	movs	r3, #36	; 0x24
   14744:	4a17      	ldr	r2, [pc, #92]	; (147a4 <secure_socket_attach_initiate+0x9c>)
   14746:	fb03 2307 	mla	r3, r3, r7, r2
   1474a:	f104 0214 	add.w	r2, r4, #20
   1474e:	f103 0124 	add.w	r1, r3, #36	; 0x24
   14752:	f853 0b04 	ldr.w	r0, [r3], #4
   14756:	428b      	cmp	r3, r1
   14758:	f842 0b04 	str.w	r0, [r2], #4
   1475c:	d1f9      	bne.n	14752 <secure_socket_attach_initiate+0x4a>
   1475e:	68a3      	ldr	r3, [r4, #8]
   14760:	4622      	mov	r2, r4
   14762:	3324      	adds	r3, #36	; 0x24
   14764:	60a3      	str	r3, [r4, #8]
   14766:	682b      	ldr	r3, [r5, #0]
   14768:	f247 0181 	movw	r1, #28801	; 0x7081
   1476c:	0c1b      	lsrs	r3, r3, #16
   1476e:	041b      	lsls	r3, r3, #16
   14770:	f043 030a 	orr.w	r3, r3, #10
   14774:	602b      	str	r3, [r5, #0]
   14776:	2004      	movs	r0, #4
   14778:	f002 f938 	bl	169ec <rpc_client_request_send>
   1477c:	682b      	ldr	r3, [r5, #0]
   1477e:	00db      	lsls	r3, r3, #3
   14780:	d40d      	bmi.n	1479e <secure_socket_attach_initiate+0x96>
   14782:	f64f 72ff 	movw	r2, #65535	; 0xffff
   14786:	210b      	movs	r1, #11
   14788:	4638      	mov	r0, r7
   1478a:	ab01      	add	r3, sp, #4
   1478c:	f002 f94a 	bl	16a24 <ip_interface_wait>
   14790:	b100      	cbz	r0, 14794 <secure_socket_attach_initiate+0x8c>
   14792:	602e      	str	r6, [r5, #0]
   14794:	b003      	add	sp, #12
   14796:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1479a:	200c      	movs	r0, #12
   1479c:	e7fa      	b.n	14794 <secure_socket_attach_initiate+0x8c>
   1479e:	2077      	movs	r0, #119	; 0x77
   147a0:	e7f8      	b.n	14794 <secure_socket_attach_initiate+0x8c>
   147a2:	bf00      	nop
   147a4:	2000ccc8 	.word	0x2000ccc8
   147a8:	2000cc04 	.word	0x2000cc04

000147ac <tls_interface_init>:
   147ac:	2201      	movs	r2, #1
   147ae:	4b02      	ldr	r3, [pc, #8]	; (147b8 <tls_interface_init+0xc>)
   147b0:	2000      	movs	r0, #0
   147b2:	701a      	strb	r2, [r3, #0]
   147b4:	4770      	bx	lr
   147b6:	bf00      	nop
   147b8:	2000ccc7 	.word	0x2000ccc7

000147bc <tls_rpc_ip_event_handler>:
   147bc:	b570      	push	{r4, r5, r6, lr}
   147be:	460c      	mov	r4, r1
   147c0:	f248 0181 	movw	r1, #32897	; 0x8081
   147c4:	428b      	cmp	r3, r1
   147c6:	4606      	mov	r6, r0
   147c8:	d035      	beq.n	14836 <tls_rpc_ip_event_handler+0x7a>
   147ca:	f249 0182 	movw	r1, #36994	; 0x9082
   147ce:	428b      	cmp	r3, r1
   147d0:	d040      	beq.n	14854 <tls_rpc_ip_event_handler+0x98>
   147d2:	f248 0102 	movw	r1, #32770	; 0x8002
   147d6:	428b      	cmp	r3, r1
   147d8:	d161      	bne.n	1489e <tls_rpc_ip_event_handler+0xe2>
   147da:	2c00      	cmp	r4, #0
   147dc:	d05f      	beq.n	1489e <tls_rpc_ip_event_handler+0xe2>
   147de:	6963      	ldr	r3, [r4, #20]
   147e0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   147e4:	d002      	beq.n	147ec <tls_rpc_ip_event_handler+0x30>
   147e6:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   147ea:	d158      	bne.n	1489e <tls_rpc_ip_event_handler+0xe2>
   147ec:	6823      	ldr	r3, [r4, #0]
   147ee:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   147f2:	6023      	str	r3, [r4, #0]
   147f4:	6955      	ldr	r5, [r2, #20]
   147f6:	2d00      	cmp	r5, #0
   147f8:	d14d      	bne.n	14896 <tls_rpc_ip_event_handler+0xda>
   147fa:	6823      	ldr	r3, [r4, #0]
   147fc:	0c1b      	lsrs	r3, r3, #16
   147fe:	041b      	lsls	r3, r3, #16
   14800:	f043 0305 	orr.w	r3, r3, #5
   14804:	6023      	str	r3, [r4, #0]
   14806:	6823      	ldr	r3, [r4, #0]
   14808:	00db      	lsls	r3, r3, #3
   1480a:	d401      	bmi.n	14810 <tls_rpc_ip_event_handler+0x54>
   1480c:	2000      	movs	r0, #0
   1480e:	e020      	b.n	14852 <tls_rpc_ip_event_handler+0x96>
   14810:	2324      	movs	r3, #36	; 0x24
   14812:	4373      	muls	r3, r6
   14814:	4a23      	ldr	r2, [pc, #140]	; (148a4 <tls_rpc_ip_event_handler+0xe8>)
   14816:	5cd3      	ldrb	r3, [r2, r3]
   14818:	2b02      	cmp	r3, #2
   1481a:	d1f7      	bne.n	1480c <tls_rpc_ip_event_handler+0x50>
   1481c:	4621      	mov	r1, r4
   1481e:	4630      	mov	r0, r6
   14820:	f002 f910 	bl	16a44 <secure_client_socket>
   14824:	2800      	cmp	r0, #0
   14826:	d0f1      	beq.n	1480c <tls_rpc_ip_event_handler+0x50>
   14828:	2877      	cmp	r0, #119	; 0x77
   1482a:	d0ef      	beq.n	1480c <tls_rpc_ip_event_handler+0x50>
   1482c:	6060      	str	r0, [r4, #4]
   1482e:	6823      	ldr	r3, [r4, #0]
   14830:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   14834:	e02d      	b.n	14892 <tls_rpc_ip_event_handler+0xd6>
   14836:	2c00      	cmp	r4, #0
   14838:	d0e8      	beq.n	1480c <tls_rpc_ip_event_handler+0x50>
   1483a:	6823      	ldr	r3, [r4, #0]
   1483c:	b29b      	uxth	r3, r3
   1483e:	2b0a      	cmp	r3, #10
   14840:	d1e4      	bne.n	1480c <tls_rpc_ip_event_handler+0x50>
   14842:	6950      	ldr	r0, [r2, #20]
   14844:	bb40      	cbnz	r0, 14898 <tls_rpc_ip_event_handler+0xdc>
   14846:	6823      	ldr	r3, [r4, #0]
   14848:	0c1b      	lsrs	r3, r3, #16
   1484a:	041b      	lsls	r3, r3, #16
   1484c:	f043 030b 	orr.w	r3, r3, #11
   14850:	6023      	str	r3, [r4, #0]
   14852:	bd70      	pop	{r4, r5, r6, pc}
   14854:	2c00      	cmp	r4, #0
   14856:	d0d9      	beq.n	1480c <tls_rpc_ip_event_handler+0x50>
   14858:	6823      	ldr	r3, [r4, #0]
   1485a:	b29b      	uxth	r3, r3
   1485c:	2b0b      	cmp	r3, #11
   1485e:	d1d5      	bne.n	1480c <tls_rpc_ip_event_handler+0x50>
   14860:	6915      	ldr	r5, [r2, #16]
   14862:	b9c5      	cbnz	r5, 14896 <tls_rpc_ip_event_handler+0xda>
   14864:	6823      	ldr	r3, [r4, #0]
   14866:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   1486a:	6023      	str	r3, [r4, #0]
   1486c:	f7ff ff3a 	bl	146e4 <hostname_free>
   14870:	6823      	ldr	r3, [r4, #0]
   14872:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   14876:	6023      	str	r3, [r4, #0]
   14878:	6823      	ldr	r3, [r4, #0]
   1487a:	0c1b      	lsrs	r3, r3, #16
   1487c:	041b      	lsls	r3, r3, #16
   1487e:	f043 030c 	orr.w	r3, r3, #12
   14882:	6023      	str	r3, [r4, #0]
   14884:	6823      	ldr	r3, [r4, #0]
   14886:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1488a:	6023      	str	r3, [r4, #0]
   1488c:	6823      	ldr	r3, [r4, #0]
   1488e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   14892:	6023      	str	r3, [r4, #0]
   14894:	e7ba      	b.n	1480c <tls_rpc_ip_event_handler+0x50>
   14896:	4628      	mov	r0, r5
   14898:	f7ff fc7a 	bl	14190 <rpc_error_to_nrf_errno>
   1489c:	e7c6      	b.n	1482c <tls_rpc_ip_event_handler+0x70>
   1489e:	2001      	movs	r0, #1
   148a0:	e7d7      	b.n	14852 <tls_rpc_ip_event_handler+0x96>
   148a2:	bf00      	nop
   148a4:	2000ccc8 	.word	0x2000ccc8

000148a8 <at_cmd_send>:
   148a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   148aa:	4615      	mov	r5, r2
   148ac:	f06f 0258 	mvn.w	r2, #88	; 0x58
   148b0:	2300      	movs	r3, #0
   148b2:	7302      	strb	r2, [r0, #12]
   148b4:	2204      	movs	r2, #4
   148b6:	4c0d      	ldr	r4, [pc, #52]	; (148ec <at_cmd_send+0x44>)
   148b8:	7343      	strb	r3, [r0, #13]
   148ba:	7383      	strb	r3, [r0, #14]
   148bc:	73c3      	strb	r3, [r0, #15]
   148be:	7202      	strb	r2, [r0, #8]
   148c0:	7243      	strb	r3, [r0, #9]
   148c2:	7283      	strb	r3, [r0, #10]
   148c4:	72c3      	strb	r3, [r0, #11]
   148c6:	4602      	mov	r2, r0
   148c8:	b289      	uxth	r1, r1
   148ca:	2003      	movs	r0, #3
   148cc:	7023      	strb	r3, [r4, #0]
   148ce:	f002 f88d 	bl	169ec <rpc_client_request_send>
   148d2:	f04f 33ff 	mov.w	r3, #4294967295
   148d6:	9301      	str	r3, [sp, #4]
   148d8:	7823      	ldrb	r3, [r4, #0]
   148da:	42ab      	cmp	r3, r5
   148dc:	d101      	bne.n	148e2 <at_cmd_send+0x3a>
   148de:	b003      	add	sp, #12
   148e0:	bd30      	pop	{r4, r5, pc}
   148e2:	a901      	add	r1, sp, #4
   148e4:	2000      	movs	r0, #0
   148e6:	f7fe f953 	bl	12b90 <nrf_modem_os_timedwait>
   148ea:	e7f5      	b.n	148d8 <at_cmd_send+0x30>
   148ec:	2000cde8 	.word	0x2000cde8

000148f0 <nrf_modem_at_init>:
   148f0:	2201      	movs	r2, #1
   148f2:	b508      	push	{r3, lr}
   148f4:	4611      	mov	r1, r2
   148f6:	4808      	ldr	r0, [pc, #32]	; (14918 <nrf_modem_at_init+0x28>)
   148f8:	f7fe fa02 	bl	12d00 <nrf_modem_os_sem_init>
   148fc:	2000      	movs	r0, #0
   148fe:	f002 f86f 	bl	169e0 <rpc_client_request_alloc>
   14902:	b128      	cbz	r0, 14910 <nrf_modem_at_init+0x20>
   14904:	2201      	movs	r2, #1
   14906:	2105      	movs	r1, #5
   14908:	f7ff ffce 	bl	148a8 <at_cmd_send>
   1490c:	2000      	movs	r0, #0
   1490e:	bd08      	pop	{r3, pc}
   14910:	f06f 000b 	mvn.w	r0, #11
   14914:	e7fb      	b.n	1490e <nrf_modem_at_init+0x1e>
   14916:	bf00      	nop
   14918:	2000cc44 	.word	0x2000cc44

0001491c <rpc_at_event_handler>:
   1491c:	b570      	push	{r4, r5, r6, lr}
   1491e:	68c3      	ldr	r3, [r0, #12]
   14920:	4605      	mov	r5, r0
   14922:	2ba7      	cmp	r3, #167	; 0xa7
   14924:	d003      	beq.n	1492e <rpc_at_event_handler+0x12>
   14926:	6828      	ldr	r0, [r5, #0]
   14928:	f002 f867 	bl	169fa <rpc_client_data_free>
   1492c:	e008      	b.n	14940 <rpc_at_event_handler+0x24>
   1492e:	2903      	cmp	r1, #3
   14930:	d008      	beq.n	14944 <rpc_at_event_handler+0x28>
   14932:	2904      	cmp	r1, #4
   14934:	d019      	beq.n	1496a <rpc_at_event_handler+0x4e>
   14936:	2902      	cmp	r1, #2
   14938:	d102      	bne.n	14940 <rpc_at_event_handler+0x24>
   1493a:	2201      	movs	r2, #1
   1493c:	4b0e      	ldr	r3, [pc, #56]	; (14978 <rpc_at_event_handler+0x5c>)
   1493e:	701a      	strb	r2, [r3, #0]
   14940:	2000      	movs	r0, #0
   14942:	e00a      	b.n	1495a <rpc_at_event_handler+0x3e>
   14944:	4e0d      	ldr	r6, [pc, #52]	; (1497c <rpc_at_event_handler+0x60>)
   14946:	6833      	ldr	r3, [r6, #0]
   14948:	b143      	cbz	r3, 1495c <rpc_at_event_handler+0x40>
   1494a:	2400      	movs	r4, #0
   1494c:	6800      	ldr	r0, [r0, #0]
   1494e:	4798      	blx	r3
   14950:	6828      	ldr	r0, [r5, #0]
   14952:	6034      	str	r4, [r6, #0]
   14954:	f002 f851 	bl	169fa <rpc_client_data_free>
   14958:	b2e0      	uxtb	r0, r4
   1495a:	bd70      	pop	{r4, r5, r6, pc}
   1495c:	2202      	movs	r2, #2
   1495e:	4b08      	ldr	r3, [pc, #32]	; (14980 <rpc_at_event_handler+0x64>)
   14960:	2401      	movs	r4, #1
   14962:	6018      	str	r0, [r3, #0]
   14964:	4b04      	ldr	r3, [pc, #16]	; (14978 <rpc_at_event_handler+0x5c>)
   14966:	701a      	strb	r2, [r3, #0]
   14968:	e7f6      	b.n	14958 <rpc_at_event_handler+0x3c>
   1496a:	4b06      	ldr	r3, [pc, #24]	; (14984 <rpc_at_event_handler+0x68>)
   1496c:	681b      	ldr	r3, [r3, #0]
   1496e:	2b00      	cmp	r3, #0
   14970:	d0d9      	beq.n	14926 <rpc_at_event_handler+0xa>
   14972:	6800      	ldr	r0, [r0, #0]
   14974:	4798      	blx	r3
   14976:	e7d6      	b.n	14926 <rpc_at_event_handler+0xa>
   14978:	2000cde8 	.word	0x2000cde8
   1497c:	2000cc50 	.word	0x2000cc50
   14980:	2000cc4c 	.word	0x2000cc4c
   14984:	2000cc48 	.word	0x2000cc48

00014988 <rpc_dfu_event_handler>:
   14988:	b510      	push	{r4, lr}
   1498a:	4604      	mov	r4, r0
   1498c:	6800      	ldr	r0, [r0, #0]
   1498e:	b108      	cbz	r0, 14994 <rpc_dfu_event_handler+0xc>
   14990:	f002 f833 	bl	169fa <rpc_client_data_free>
   14994:	4b05      	ldr	r3, [pc, #20]	; (149ac <rpc_dfu_event_handler+0x24>)
   14996:	68e2      	ldr	r2, [r4, #12]
   14998:	429a      	cmp	r2, r3
   1499a:	bf05      	ittet	eq
   1499c:	2001      	moveq	r0, #1
   1499e:	4b04      	ldreq	r3, [pc, #16]	; (149b0 <rpc_dfu_event_handler+0x28>)
   149a0:	2000      	movne	r0, #0
   149a2:	7018      	strbeq	r0, [r3, #0]
   149a4:	bf04      	itt	eq
   149a6:	4b03      	ldreq	r3, [pc, #12]	; (149b4 <rpc_dfu_event_handler+0x2c>)
   149a8:	601c      	streq	r4, [r3, #0]
   149aa:	bd10      	pop	{r4, pc}
   149ac:	15abe11a 	.word	0x15abe11a
   149b0:	2000cde9 	.word	0x2000cde9
   149b4:	2000cc54 	.word	0x2000cc54

000149b8 <rpc_gnss_event_handler>:
   149b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   149bc:	6804      	ldr	r4, [r0, #0]
   149be:	4607      	mov	r7, r0
   149c0:	460d      	mov	r5, r1
   149c2:	2c00      	cmp	r4, #0
   149c4:	f000 8086 	beq.w	14ad4 <rpc_gnss_event_handler+0x11c>
   149c8:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   149cc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   149d0:	d142      	bne.n	14a58 <rpc_gnss_event_handler+0xa0>
   149d2:	4b5f      	ldr	r3, [pc, #380]	; (14b50 <rpc_gnss_event_handler+0x198>)
   149d4:	781a      	ldrb	r2, [r3, #0]
   149d6:	4698      	mov	r8, r3
   149d8:	2a01      	cmp	r2, #1
   149da:	d131      	bne.n	14a40 <rpc_gnss_event_handler+0x88>
   149dc:	4a5d      	ldr	r2, [pc, #372]	; (14b54 <rpc_gnss_event_handler+0x19c>)
   149de:	6821      	ldr	r1, [r4, #0]
   149e0:	8812      	ldrh	r2, [r2, #0]
   149e2:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   149e6:	d12b      	bne.n	14a40 <rpc_gnss_event_handler+0x88>
   149e8:	6862      	ldr	r2, [r4, #4]
   149ea:	bb6a      	cbnz	r2, 14a48 <rpc_gnss_event_handler+0x90>
   149ec:	4b5a      	ldr	r3, [pc, #360]	; (14b58 <rpc_gnss_event_handler+0x1a0>)
   149ee:	681e      	ldr	r6, [r3, #0]
   149f0:	b31e      	cbz	r6, 14a3a <rpc_gnss_event_handler+0x82>
   149f2:	f242 0309 	movw	r3, #8201	; 0x2009
   149f6:	429d      	cmp	r5, r3
   149f8:	d11f      	bne.n	14a3a <rpc_gnss_event_handler+0x82>
   149fa:	4630      	mov	r0, r6
   149fc:	8923      	ldrh	r3, [r4, #8]
   149fe:	2280      	movs	r2, #128	; 0x80
   14a00:	f840 3b04 	str.w	r3, [r0], #4
   14a04:	f104 010a 	add.w	r1, r4, #10
   14a08:	f001 fdbe 	bl	16588 <memcpy>
   14a0c:	2280      	movs	r2, #128	; 0x80
   14a0e:	f104 018a 	add.w	r1, r4, #138	; 0x8a
   14a12:	f106 0084 	add.w	r0, r6, #132	; 0x84
   14a16:	f001 fdb7 	bl	16588 <memcpy>
   14a1a:	f8d4 310a 	ldr.w	r3, [r4, #266]	; 0x10a
   14a1e:	f8c6 3104 	str.w	r3, [r6, #260]	; 0x104
   14a22:	f8d4 310e 	ldr.w	r3, [r4, #270]	; 0x10e
   14a26:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
   14a2a:	f8d4 3112 	ldr.w	r3, [r4, #274]	; 0x112
   14a2e:	f8c6 310c 	str.w	r3, [r6, #268]	; 0x10c
   14a32:	f8d4 3116 	ldr.w	r3, [r4, #278]	; 0x116
   14a36:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
   14a3a:	2300      	movs	r3, #0
   14a3c:	f888 3000 	strb.w	r3, [r8]
   14a40:	6838      	ldr	r0, [r7, #0]
   14a42:	f001 ffda 	bl	169fa <rpc_client_data_free>
   14a46:	e045      	b.n	14ad4 <rpc_gnss_event_handler+0x11c>
   14a48:	f647 71ff 	movw	r1, #32767	; 0x7fff
   14a4c:	428a      	cmp	r2, r1
   14a4e:	bf0c      	ite	eq
   14a50:	2203      	moveq	r2, #3
   14a52:	2202      	movne	r2, #2
   14a54:	701a      	strb	r2, [r3, #0]
   14a56:	e7f3      	b.n	14a40 <rpc_gnss_event_handler+0x88>
   14a58:	4e40      	ldr	r6, [pc, #256]	; (14b5c <rpc_gnss_event_handler+0x1a4>)
   14a5a:	6833      	ldr	r3, [r6, #0]
   14a5c:	2b00      	cmp	r3, #0
   14a5e:	d0ef      	beq.n	14a40 <rpc_gnss_event_handler+0x88>
   14a60:	f244 0204 	movw	r2, #16388	; 0x4004
   14a64:	4291      	cmp	r1, r2
   14a66:	d80b      	bhi.n	14a80 <rpc_gnss_event_handler+0xc8>
   14a68:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   14a6c:	d9e8      	bls.n	14a40 <rpc_gnss_event_handler+0x88>
   14a6e:	f5a1 4280 	sub.w	r2, r1, #16384	; 0x4000
   14a72:	3a02      	subs	r2, #2
   14a74:	2a02      	cmp	r2, #2
   14a76:	d80b      	bhi.n	14a90 <rpc_gnss_event_handler+0xd8>
   14a78:	e8df f002 	tbb	[pc, r2]
   14a7c:	4f45      	.short	0x4f45
   14a7e:	59          	.byte	0x59
   14a7f:	00          	.byte	0x00
   14a80:	f244 1301 	movw	r3, #16641	; 0x4101
   14a84:	4299      	cmp	r1, r3
   14a86:	d003      	beq.n	14a90 <rpc_gnss_event_handler+0xd8>
   14a88:	f244 2301 	movw	r3, #16897	; 0x4201
   14a8c:	4299      	cmp	r1, r3
   14a8e:	d1d7      	bne.n	14a40 <rpc_gnss_event_handler+0x88>
   14a90:	4f33      	ldr	r7, [pc, #204]	; (14b60 <rpc_gnss_event_handler+0x1a8>)
   14a92:	6838      	ldr	r0, [r7, #0]
   14a94:	b108      	cbz	r0, 14a9a <rpc_gnss_event_handler+0xe2>
   14a96:	f001 ffb0 	bl	169fa <rpc_client_data_free>
   14a9a:	f244 2301 	movw	r3, #16897	; 0x4201
   14a9e:	429d      	cmp	r5, r3
   14aa0:	4b30      	ldr	r3, [pc, #192]	; (14b64 <rpc_gnss_event_handler+0x1ac>)
   14aa2:	d11a      	bne.n	14ada <rpc_gnss_event_handler+0x122>
   14aa4:	2202      	movs	r2, #2
   14aa6:	603c      	str	r4, [r7, #0]
   14aa8:	f894 4051 	ldrb.w	r4, [r4, #81]	; 0x51
   14aac:	701a      	strb	r2, [r3, #0]
   14aae:	07e3      	lsls	r3, r4, #31
   14ab0:	d502      	bpl.n	14ab8 <rpc_gnss_event_handler+0x100>
   14ab2:	2002      	movs	r0, #2
   14ab4:	6833      	ldr	r3, [r6, #0]
   14ab6:	4798      	blx	r3
   14ab8:	4d2b      	ldr	r5, [pc, #172]	; (14b68 <rpc_gnss_event_handler+0x1b0>)
   14aba:	f014 0418 	ands.w	r4, r4, #24
   14abe:	6833      	ldr	r3, [r6, #0]
   14ac0:	782a      	ldrb	r2, [r5, #0]
   14ac2:	d01a      	beq.n	14afa <rpc_gnss_event_handler+0x142>
   14ac4:	b91a      	cbnz	r2, 14ace <rpc_gnss_event_handler+0x116>
   14ac6:	2005      	movs	r0, #5
   14ac8:	4798      	blx	r3
   14aca:	2301      	movs	r3, #1
   14acc:	702b      	strb	r3, [r5, #0]
   14ace:	2001      	movs	r0, #1
   14ad0:	6833      	ldr	r3, [r6, #0]
   14ad2:	4798      	blx	r3
   14ad4:	2000      	movs	r0, #0
   14ad6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14ada:	f244 1201 	movw	r2, #16641	; 0x4101
   14ade:	4295      	cmp	r5, r2
   14ae0:	bf0b      	itete	eq
   14ae2:	2201      	moveq	r2, #1
   14ae4:	2200      	movne	r2, #0
   14ae6:	603c      	streq	r4, [r7, #0]
   14ae8:	603c      	strne	r4, [r7, #0]
   14aea:	bf0b      	itete	eq
   14aec:	f894 4041 	ldrbeq.w	r4, [r4, #65]	; 0x41
   14af0:	f894 403d 	ldrbne.w	r4, [r4, #61]	; 0x3d
   14af4:	701a      	strbeq	r2, [r3, #0]
   14af6:	701a      	strbne	r2, [r3, #0]
   14af8:	e7d9      	b.n	14aae <rpc_gnss_event_handler+0xf6>
   14afa:	2a00      	cmp	r2, #0
   14afc:	d0e7      	beq.n	14ace <rpc_gnss_event_handler+0x116>
   14afe:	2006      	movs	r0, #6
   14b00:	4798      	blx	r3
   14b02:	702c      	strb	r4, [r5, #0]
   14b04:	e7e3      	b.n	14ace <rpc_gnss_event_handler+0x116>
   14b06:	4c19      	ldr	r4, [pc, #100]	; (14b6c <rpc_gnss_event_handler+0x1b4>)
   14b08:	6820      	ldr	r0, [r4, #0]
   14b0a:	b108      	cbz	r0, 14b10 <rpc_gnss_event_handler+0x158>
   14b0c:	f001 ff75 	bl	169fa <rpc_client_data_free>
   14b10:	683b      	ldr	r3, [r7, #0]
   14b12:	2003      	movs	r0, #3
   14b14:	6023      	str	r3, [r4, #0]
   14b16:	6833      	ldr	r3, [r6, #0]
   14b18:	e7db      	b.n	14ad2 <rpc_gnss_event_handler+0x11a>
   14b1a:	4c15      	ldr	r4, [pc, #84]	; (14b70 <rpc_gnss_event_handler+0x1b8>)
   14b1c:	6820      	ldr	r0, [r4, #0]
   14b1e:	b108      	cbz	r0, 14b24 <rpc_gnss_event_handler+0x16c>
   14b20:	f001 ff6b 	bl	169fa <rpc_client_data_free>
   14b24:	683b      	ldr	r3, [r7, #0]
   14b26:	2004      	movs	r0, #4
   14b28:	6023      	str	r3, [r4, #0]
   14b2a:	6833      	ldr	r3, [r6, #0]
   14b2c:	e7d1      	b.n	14ad2 <rpc_gnss_event_handler+0x11a>
   14b2e:	7822      	ldrb	r2, [r4, #0]
   14b30:	2a03      	cmp	r2, #3
   14b32:	d885      	bhi.n	14a40 <rpc_gnss_event_handler+0x88>
   14b34:	e8df f002 	tbb	[pc, r2]
   14b38:	09070502 	.word	0x09070502
   14b3c:	2007      	movs	r0, #7
   14b3e:	4798      	blx	r3
   14b40:	e77e      	b.n	14a40 <rpc_gnss_event_handler+0x88>
   14b42:	2008      	movs	r0, #8
   14b44:	e7fb      	b.n	14b3e <rpc_gnss_event_handler+0x186>
   14b46:	2009      	movs	r0, #9
   14b48:	e7f9      	b.n	14b3e <rpc_gnss_event_handler+0x186>
   14b4a:	200a      	movs	r0, #10
   14b4c:	e7f7      	b.n	14b3e <rpc_gnss_event_handler+0x186>
   14b4e:	bf00      	nop
   14b50:	2000cdec 	.word	0x2000cdec
   14b54:	2000ccbc 	.word	0x2000ccbc
   14b58:	2000cc68 	.word	0x2000cc68
   14b5c:	2000cc58 	.word	0x2000cc58
   14b60:	2000cc5c 	.word	0x2000cc5c
   14b64:	2000cdeb 	.word	0x2000cdeb
   14b68:	2000cdea 	.word	0x2000cdea
   14b6c:	2000cc64 	.word	0x2000cc64
   14b70:	2000cc60 	.word	0x2000cc60

00014b74 <full_dfu_ipc_irq_handler>:
   14b74:	2301      	movs	r3, #1
   14b76:	4a03      	ldr	r2, [pc, #12]	; (14b84 <full_dfu_ipc_irq_handler+0x10>)
   14b78:	6013      	str	r3, [r2, #0]
   14b7a:	07c2      	lsls	r2, r0, #31
   14b7c:	bf44      	itt	mi
   14b7e:	4a02      	ldrmi	r2, [pc, #8]	; (14b88 <full_dfu_ipc_irq_handler+0x14>)
   14b80:	7013      	strbmi	r3, [r2, #0]
   14b82:	4770      	bx	lr
   14b84:	2000cc6c 	.word	0x2000cc6c
   14b88:	2000cded 	.word	0x2000cded

00014b8c <modem_ipc_wait_for_event>:
   14b8c:	b538      	push	{r3, r4, r5, lr}
   14b8e:	2300      	movs	r3, #0
   14b90:	f44f 65fa 	mov.w	r5, #2000	; 0x7d0
   14b94:	4c0b      	ldr	r4, [pc, #44]	; (14bc4 <modem_ipc_wait_for_event+0x38>)
   14b96:	6023      	str	r3, [r4, #0]
   14b98:	6823      	ldr	r3, [r4, #0]
   14b9a:	b92b      	cbnz	r3, 14ba8 <modem_ipc_wait_for_event+0x1c>
   14b9c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   14ba0:	f001 fe77 	bl	16892 <nrf_modem_os_busywait>
   14ba4:	3d01      	subs	r5, #1
   14ba6:	d1f7      	bne.n	14b98 <modem_ipc_wait_for_event+0xc>
   14ba8:	6823      	ldr	r3, [r4, #0]
   14baa:	b913      	cbnz	r3, 14bb2 <modem_ipc_wait_for_event+0x26>
   14bac:	f06f 0073 	mvn.w	r0, #115	; 0x73
   14bb0:	e006      	b.n	14bc0 <modem_ipc_wait_for_event+0x34>
   14bb2:	4b05      	ldr	r3, [pc, #20]	; (14bc8 <modem_ipc_wait_for_event+0x3c>)
   14bb4:	781b      	ldrb	r3, [r3, #0]
   14bb6:	2b01      	cmp	r3, #1
   14bb8:	bf14      	ite	ne
   14bba:	2000      	movne	r0, #0
   14bbc:	f06f 0004 	mvneq.w	r0, #4
   14bc0:	bd38      	pop	{r3, r4, r5, pc}
   14bc2:	bf00      	nop
   14bc4:	2000cc6c 	.word	0x2000cc6c
   14bc8:	2000cded 	.word	0x2000cded

00014bcc <nrf_modem_full_dfu_setup>:
   14bcc:	2200      	movs	r2, #0
   14bce:	2300      	movs	r3, #0
   14bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
   14bd2:	4d2b      	ldr	r5, [pc, #172]	; (14c80 <nrf_modem_full_dfu_setup+0xb4>)
   14bd4:	4e2b      	ldr	r6, [pc, #172]	; (14c84 <nrf_modem_full_dfu_setup+0xb8>)
   14bd6:	e9c5 2302 	strd	r2, r3, [r5, #8]
   14bda:	e9c5 2304 	strd	r2, r3, [r5, #16]
   14bde:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   14be2:	4b29      	ldr	r3, [pc, #164]	; (14c88 <nrf_modem_full_dfu_setup+0xbc>)
   14be4:	2400      	movs	r4, #0
   14be6:	601a      	str	r2, [r3, #0]
   14be8:	f100 031c 	add.w	r3, r0, #28
   14bec:	6033      	str	r3, [r6, #0]
   14bee:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   14bf2:	6043      	str	r3, [r0, #4]
   14bf4:	231c      	movs	r3, #28
   14bf6:	7203      	strb	r3, [r0, #8]
   14bf8:	2320      	movs	r3, #32
   14bfa:	2701      	movs	r7, #1
   14bfc:	f06f 027f 	mvn.w	r2, #127	; 0x7f
   14c00:	7243      	strb	r3, [r0, #9]
   14c02:	4b22      	ldr	r3, [pc, #136]	; (14c8c <nrf_modem_full_dfu_setup+0xc0>)
   14c04:	7004      	strb	r4, [r0, #0]
   14c06:	7044      	strb	r4, [r0, #1]
   14c08:	70c2      	strb	r2, [r0, #3]
   14c0a:	7284      	strb	r4, [r0, #10]
   14c0c:	72c4      	strb	r4, [r0, #11]
   14c0e:	7087      	strb	r7, [r0, #2]
   14c10:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
   14c14:	702c      	strb	r4, [r5, #0]
   14c16:	f8c3 0610 	str.w	r0, [r3, #1552]	; 0x610
   14c1a:	f8c3 4614 	str.w	r4, [r3, #1556]	; 0x614
   14c1e:	4b1c      	ldr	r3, [pc, #112]	; (14c90 <nrf_modem_full_dfu_setup+0xc4>)
   14c20:	b093      	sub	sp, #76	; 0x4c
   14c22:	4622      	mov	r2, r4
   14c24:	4620      	mov	r0, r4
   14c26:	491b      	ldr	r1, [pc, #108]	; (14c94 <nrf_modem_full_dfu_setup+0xc8>)
   14c28:	701c      	strb	r4, [r3, #0]
   14c2a:	f7fe fd6b 	bl	13704 <nrfx_ipc_init>
   14c2e:	4621      	mov	r1, r4
   14c30:	2240      	movs	r2, #64	; 0x40
   14c32:	a801      	add	r0, sp, #4
   14c34:	f001 fcb3 	bl	1659e <memset>
   14c38:	2302      	movs	r3, #2
   14c3a:	9302      	str	r3, [sp, #8]
   14c3c:	2304      	movs	r3, #4
   14c3e:	930b      	str	r3, [sp, #44]	; 0x2c
   14c40:	2305      	movs	r3, #5
   14c42:	a801      	add	r0, sp, #4
   14c44:	9311      	str	r3, [sp, #68]	; 0x44
   14c46:	9709      	str	r7, [sp, #36]	; 0x24
   14c48:	f7fe fd74 	bl	13734 <nrfx_ipc_config_load>
   14c4c:	4b12      	ldr	r3, [pc, #72]	; (14c98 <nrf_modem_full_dfu_setup+0xcc>)
   14c4e:	9400      	str	r4, [sp, #0]
   14c50:	6836      	ldr	r6, [r6, #0]
   14c52:	601c      	str	r4, [r3, #0]
   14c54:	681b      	ldr	r3, [r3, #0]
   14c56:	9300      	str	r3, [sp, #0]
   14c58:	9b00      	ldr	r3, [sp, #0]
   14c5a:	f7ff ff97 	bl	14b8c <modem_ipc_wait_for_event>
   14c5e:	4604      	mov	r4, r0
   14c60:	b130      	cbz	r0, 14c70 <nrf_modem_full_dfu_setup+0xa4>
   14c62:	2303      	movs	r3, #3
   14c64:	702b      	strb	r3, [r5, #0]
   14c66:	f7fe fd85 	bl	13774 <nrfx_ipc_uninit>
   14c6a:	4620      	mov	r0, r4
   14c6c:	b013      	add	sp, #76	; 0x4c
   14c6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   14c70:	6832      	ldr	r2, [r6, #0]
   14c72:	4b0a      	ldr	r3, [pc, #40]	; (14c9c <nrf_modem_full_dfu_setup+0xd0>)
   14c74:	429a      	cmp	r2, r3
   14c76:	d0f8      	beq.n	14c6a <nrf_modem_full_dfu_setup+0x9e>
   14c78:	f06f 0404 	mvn.w	r4, #4
   14c7c:	e7f3      	b.n	14c66 <nrf_modem_full_dfu_setup+0x9a>
   14c7e:	bf00      	nop
   14c80:	2000c6e8 	.word	0x2000c6e8
   14c84:	2000cc70 	.word	0x2000cc70
   14c88:	2000cc74 	.word	0x2000cc74
   14c8c:	4002a000 	.word	0x4002a000
   14c90:	2000cded 	.word	0x2000cded
   14c94:	00014b75 	.word	0x00014b75
   14c98:	40005610 	.word	0x40005610
   14c9c:	a5000001 	.word	0xa5000001

00014ca0 <modem_off>:
   14ca0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   14ca2:	2501      	movs	r5, #1
   14ca4:	4c07      	ldr	r4, [pc, #28]	; (14cc4 <modem_off+0x24>)
   14ca6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   14caa:	6065      	str	r5, [r4, #4]
   14cac:	f001 fdf1 	bl	16892 <nrf_modem_os_busywait>
   14cb0:	2300      	movs	r3, #0
   14cb2:	6063      	str	r3, [r4, #4]
   14cb4:	9301      	str	r3, [sp, #4]
   14cb6:	6025      	str	r5, [r4, #0]
   14cb8:	6823      	ldr	r3, [r4, #0]
   14cba:	9301      	str	r3, [sp, #4]
   14cbc:	9b01      	ldr	r3, [sp, #4]
   14cbe:	b003      	add	sp, #12
   14cc0:	bd30      	pop	{r4, r5, pc}
   14cc2:	bf00      	nop
   14cc4:	40005610 	.word	0x40005610

00014cc8 <nrf_modem_init>:
   14cc8:	b570      	push	{r4, r5, r6, lr}
   14cca:	460d      	mov	r5, r1
   14ccc:	b300      	cbz	r0, 14d10 <nrf_modem_init+0x48>
   14cce:	4e15      	ldr	r6, [pc, #84]	; (14d24 <nrf_modem_init+0x5c>)
   14cd0:	7832      	ldrb	r2, [r6, #0]
   14cd2:	bb02      	cbnz	r2, 14d16 <nrf_modem_init+0x4e>
   14cd4:	2901      	cmp	r1, #1
   14cd6:	d113      	bne.n	14d00 <nrf_modem_init+0x38>
   14cd8:	68c1      	ldr	r1, [r0, #12]
   14cda:	6842      	ldr	r2, [r0, #4]
   14cdc:	440a      	add	r2, r1
   14cde:	6941      	ldr	r1, [r0, #20]
   14ce0:	440a      	add	r2, r1
   14ce2:	69c1      	ldr	r1, [r0, #28]
   14ce4:	440a      	add	r2, r1
   14ce6:	f242 011b 	movw	r1, #8219	; 0x201b
   14cea:	428a      	cmp	r2, r1
   14cec:	d916      	bls.n	14d1c <nrf_modem_init+0x54>
   14cee:	6800      	ldr	r0, [r0, #0]
   14cf0:	f7ff ff6c 	bl	14bcc <nrf_modem_full_dfu_setup>
   14cf4:	4604      	mov	r4, r0
   14cf6:	b130      	cbz	r0, 14d06 <nrf_modem_init+0x3e>
   14cf8:	f7ff ffd2 	bl	14ca0 <modem_off>
   14cfc:	4620      	mov	r0, r4
   14cfe:	bd70      	pop	{r4, r5, r6, pc}
   14d00:	f001 fedf 	bl	16ac2 <nrf_modem_platform_init>
   14d04:	e7f6      	b.n	14cf4 <nrf_modem_init+0x2c>
   14d06:	4b08      	ldr	r3, [pc, #32]	; (14d28 <nrf_modem_init+0x60>)
   14d08:	701d      	strb	r5, [r3, #0]
   14d0a:	2301      	movs	r3, #1
   14d0c:	7033      	strb	r3, [r6, #0]
   14d0e:	e7f5      	b.n	14cfc <nrf_modem_init+0x34>
   14d10:	f06f 040d 	mvn.w	r4, #13
   14d14:	e7f2      	b.n	14cfc <nrf_modem_init+0x34>
   14d16:	f04f 34ff 	mov.w	r4, #4294967295
   14d1a:	e7ef      	b.n	14cfc <nrf_modem_init+0x34>
   14d1c:	f06f 040b 	mvn.w	r4, #11
   14d20:	e7ec      	b.n	14cfc <nrf_modem_init+0x34>
   14d22:	bf00      	nop
   14d24:	2000cdee 	.word	0x2000cdee
   14d28:	2000cdef 	.word	0x2000cdef

00014d2c <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   14d2c:	4b0e      	ldr	r3, [pc, #56]	; (14d68 <z_sys_init_run_level+0x3c>)
{
   14d2e:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   14d30:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   14d34:	3001      	adds	r0, #1
   14d36:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   14d3a:	42a6      	cmp	r6, r4
   14d3c:	d800      	bhi.n	14d40 <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
   14d3e:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
   14d40:	e9d4 3500 	ldrd	r3, r5, [r4]
   14d44:	4628      	mov	r0, r5
   14d46:	4798      	blx	r3
		if (dev != NULL) {
   14d48:	b165      	cbz	r5, 14d64 <z_sys_init_run_level+0x38>
			if (rc != 0) {
   14d4a:	68eb      	ldr	r3, [r5, #12]
   14d4c:	b130      	cbz	r0, 14d5c <z_sys_init_run_level+0x30>
				if (rc < 0) {
   14d4e:	2800      	cmp	r0, #0
   14d50:	bfb8      	it	lt
   14d52:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
   14d54:	28ff      	cmp	r0, #255	; 0xff
   14d56:	bfa8      	it	ge
   14d58:	20ff      	movge	r0, #255	; 0xff
   14d5a:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   14d5c:	785a      	ldrb	r2, [r3, #1]
   14d5e:	f042 0201 	orr.w	r2, r2, #1
   14d62:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   14d64:	3408      	adds	r4, #8
   14d66:	e7e8      	b.n	14d3a <z_sys_init_run_level+0xe>
   14d68:	000173d4 	.word	0x000173d4

00014d6c <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
   14d6c:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
   14d6e:	4605      	mov	r5, r0
   14d70:	b910      	cbnz	r0, 14d78 <z_impl_device_get_binding+0xc>
		return NULL;
   14d72:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
   14d74:	4620      	mov	r0, r4
   14d76:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
   14d78:	7803      	ldrb	r3, [r0, #0]
   14d7a:	2b00      	cmp	r3, #0
   14d7c:	d0f9      	beq.n	14d72 <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
   14d7e:	4a0f      	ldr	r2, [pc, #60]	; (14dbc <z_impl_device_get_binding+0x50>)
   14d80:	4c0f      	ldr	r4, [pc, #60]	; (14dc0 <z_impl_device_get_binding+0x54>)
   14d82:	4616      	mov	r6, r2
   14d84:	4294      	cmp	r4, r2
   14d86:	d108      	bne.n	14d9a <z_impl_device_get_binding+0x2e>
	for (dev = __device_start; dev != __device_end; dev++) {
   14d88:	4c0d      	ldr	r4, [pc, #52]	; (14dc0 <z_impl_device_get_binding+0x54>)
   14d8a:	42b4      	cmp	r4, r6
   14d8c:	d0f1      	beq.n	14d72 <z_impl_device_get_binding+0x6>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
   14d8e:	4620      	mov	r0, r4
   14d90:	f001 feb2 	bl	16af8 <z_device_ready>
   14d94:	b950      	cbnz	r0, 14dac <z_impl_device_get_binding+0x40>
	for (dev = __device_start; dev != __device_end; dev++) {
   14d96:	3418      	adds	r4, #24
   14d98:	e7f7      	b.n	14d8a <z_impl_device_get_binding+0x1e>
		if (z_device_ready(dev) && (dev->name == name)) {
   14d9a:	4620      	mov	r0, r4
   14d9c:	f001 feac 	bl	16af8 <z_device_ready>
   14da0:	b110      	cbz	r0, 14da8 <z_impl_device_get_binding+0x3c>
   14da2:	6823      	ldr	r3, [r4, #0]
   14da4:	42ab      	cmp	r3, r5
   14da6:	d0e5      	beq.n	14d74 <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
   14da8:	3418      	adds	r4, #24
   14daa:	e7eb      	b.n	14d84 <z_impl_device_get_binding+0x18>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
   14dac:	4628      	mov	r0, r5
   14dae:	6821      	ldr	r1, [r4, #0]
   14db0:	f001 fbce 	bl	16550 <strcmp>
   14db4:	2800      	cmp	r0, #0
   14db6:	d1ee      	bne.n	14d96 <z_impl_device_get_binding+0x2a>
   14db8:	e7dc      	b.n	14d74 <z_impl_device_get_binding+0x8>
   14dba:	bf00      	nop
   14dbc:	00017048 	.word	0x00017048
   14dc0:	00016fe8 	.word	0x00016fe8

00014dc4 <init_idle_thread>:
	snprintk(tname, 8, "idle %02d", i);
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   14dc4:	2300      	movs	r3, #0
   14dc6:	2201      	movs	r2, #1
{
   14dc8:	b510      	push	{r4, lr}
   14dca:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   14dcc:	e9cd 2304 	strd	r2, r3, [sp, #16]
   14dd0:	220f      	movs	r2, #15
   14dd2:	9301      	str	r3, [sp, #4]
   14dd4:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   14dd8:	2318      	movs	r3, #24
   14dda:	4a0b      	ldr	r2, [pc, #44]	; (14e08 <init_idle_thread+0x44>)
	struct k_thread *thread = &z_idle_threads[i];
   14ddc:	4c0b      	ldr	r4, [pc, #44]	; (14e0c <init_idle_thread+0x48>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   14dde:	fb03 2300 	mla	r3, r3, r0, r2
	z_setup_new_thread(thread, stack,
   14de2:	f44f 72a0 	mov.w	r2, #320	; 0x140
   14de6:	490a      	ldr	r1, [pc, #40]	; (14e10 <init_idle_thread+0x4c>)
	struct k_thread *thread = &z_idle_threads[i];
   14de8:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
	z_setup_new_thread(thread, stack,
   14dec:	fb02 1100 	mla	r1, r2, r0, r1
   14df0:	9300      	str	r3, [sp, #0]
   14df2:	4620      	mov	r0, r4
   14df4:	4b07      	ldr	r3, [pc, #28]	; (14e14 <init_idle_thread+0x50>)
   14df6:	f000 f8b7 	bl	14f68 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   14dfa:	7b63      	ldrb	r3, [r4, #13]
   14dfc:	f023 0304 	bic.w	r3, r3, #4
   14e00:	7363      	strb	r3, [r4, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
   14e02:	b006      	add	sp, #24
   14e04:	bd10      	pop	{r4, pc}
   14e06:	bf00      	nop
   14e08:	2000cc78 	.word	0x2000cc78
   14e0c:	2000c700 	.word	0x2000c700
   14e10:	2000d5f8 	.word	0x2000d5f8
   14e14:	00015085 	.word	0x00015085

00014e18 <bg_thread_main>:
	z_sys_post_kernel = true;
   14e18:	2201      	movs	r2, #1
{
   14e1a:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   14e1c:	4b09      	ldr	r3, [pc, #36]	; (14e44 <bg_thread_main+0x2c>)
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   14e1e:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   14e20:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   14e22:	f7ff ff83 	bl	14d2c <z_sys_init_run_level>
	boot_banner();
   14e26:	f000 ffc7 	bl	15db8 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   14e2a:	2003      	movs	r0, #3
   14e2c:	f7ff ff7e 	bl	14d2c <z_sys_init_run_level>
	z_init_static_threads();
   14e30:	f000 f8ca 	bl	14fc8 <z_init_static_threads>
	main();
   14e34:	f7fb fbc4 	bl	105c0 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   14e38:	4a03      	ldr	r2, [pc, #12]	; (14e48 <bg_thread_main+0x30>)
   14e3a:	7b13      	ldrb	r3, [r2, #12]
   14e3c:	f023 0301 	bic.w	r3, r3, #1
   14e40:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   14e42:	bd08      	pop	{r3, pc}
   14e44:	2000cdf0 	.word	0x2000cdf0
   14e48:	2000c780 	.word	0x2000c780

00014e4c <z_bss_zero>:
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   14e4c:	4802      	ldr	r0, [pc, #8]	; (14e58 <z_bss_zero+0xc>)
   14e4e:	4a03      	ldr	r2, [pc, #12]	; (14e5c <z_bss_zero+0x10>)
   14e50:	2100      	movs	r1, #0
   14e52:	1a12      	subs	r2, r2, r0
   14e54:	f001 bba3 	b.w	1659e <memset>
   14e58:	2000c5b0 	.word	0x2000c5b0
   14e5c:	2000cdf4 	.word	0x2000cdf4

00014e60 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
   14e60:	b580      	push	{r7, lr}
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   14e62:	4b30      	ldr	r3, [pc, #192]	; (14f24 <z_cstart+0xc4>)
   14e64:	b0a6      	sub	sp, #152	; 0x98
	uint32_t msp =
   14e66:	f503 6800 	add.w	r8, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   14e6a:	f388 8808 	msr	MSP, r8
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   14e6e:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   14e72:	2400      	movs	r4, #0
   14e74:	23e0      	movs	r3, #224	; 0xe0
   14e76:	4d2c      	ldr	r5, [pc, #176]	; (14f28 <z_cstart+0xc8>)
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
   14e78:	4e2c      	ldr	r6, [pc, #176]	; (14f2c <z_cstart+0xcc>)
   14e7a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   14e7e:	77ec      	strb	r4, [r5, #31]
   14e80:	762c      	strb	r4, [r5, #24]
   14e82:	766c      	strb	r4, [r5, #25]
   14e84:	76ac      	strb	r4, [r5, #26]
   14e86:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   14e8a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   14e8c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 14f40 <z_cstart+0xe0>
   14e90:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   14e94:	626b      	str	r3, [r5, #36]	; 0x24
   14e96:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   14e9a:	f7fc fd25 	bl	118e8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   14e9e:	f7fc fb0b 	bl	114b8 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   14ea2:	f04f 33ff 	mov.w	r3, #4294967295
   14ea6:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   14ea8:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   14eaa:	f7fc febf 	bl	11c2c <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   14eae:	f7fc fd79 	bl	119a4 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   14eb2:	f240 1301 	movw	r3, #257	; 0x101
   14eb6:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   14eba:	ab06      	add	r3, sp, #24
   14ebc:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   14ebe:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   14ec2:	f001 fe18 	bl	16af6 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   14ec6:	4620      	mov	r0, r4
   14ec8:	f7ff ff30 	bl	14d2c <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   14ecc:	2001      	movs	r0, #1
   14ece:	f7ff ff2d 	bl	14d2c <z_sys_init_run_level>
	z_sched_init();
   14ed2:	f000 fc4b 	bl	1576c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   14ed6:	4b16      	ldr	r3, [pc, #88]	; (14f30 <z_cstart+0xd0>)
	_kernel.ready_q.cache = &z_main_thread;
   14ed8:	4d16      	ldr	r5, [pc, #88]	; (14f34 <z_cstart+0xd4>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   14eda:	9305      	str	r3, [sp, #20]
   14edc:	2301      	movs	r3, #1
   14ede:	4916      	ldr	r1, [pc, #88]	; (14f38 <z_cstart+0xd8>)
   14ee0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   14ee4:	e9cd 4303 	strd	r4, r3, [sp, #12]
   14ee8:	4628      	mov	r0, r5
   14eea:	464b      	mov	r3, r9
   14eec:	e9cd 4401 	strd	r4, r4, [sp, #4]
   14ef0:	9400      	str	r4, [sp, #0]
	_kernel.ready_q.cache = &z_main_thread;
   14ef2:	61f5      	str	r5, [r6, #28]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   14ef4:	f000 f838 	bl	14f68 <z_setup_new_thread>
   14ef8:	4607      	mov	r7, r0
   14efa:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   14efc:	4628      	mov	r0, r5
   14efe:	f022 0204 	bic.w	r2, r2, #4
   14f02:	736a      	strb	r2, [r5, #13]
   14f04:	f001 ff09 	bl	16d1a <z_ready_thread>
		init_idle_thread(i);
   14f08:	4620      	mov	r0, r4
   14f0a:	f7ff ff5b 	bl	14dc4 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   14f0e:	4b0b      	ldr	r3, [pc, #44]	; (14f3c <z_cstart+0xdc>)
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   14f10:	464a      	mov	r2, r9
   14f12:	4639      	mov	r1, r7
   14f14:	4628      	mov	r0, r5
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   14f16:	60f3      	str	r3, [r6, #12]
		_kernel.cpus[i].id = i;
   14f18:	7534      	strb	r4, [r6, #20]
		_kernel.cpus[i].irq_stack =
   14f1a:	f8c6 8004 	str.w	r8, [r6, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   14f1e:	f7fc fbc5 	bl	116ac <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   14f22:	bf00      	nop
   14f24:	2000d738 	.word	0x2000d738
   14f28:	e000ed00 	.word	0xe000ed00
   14f2c:	2000cc78 	.word	0x2000cc78
   14f30:	000175ee 	.word	0x000175ee
   14f34:	2000c780 	.word	0x2000c780
   14f38:	2000d1f8 	.word	0x2000d1f8
   14f3c:	2000c700 	.word	0x2000c700
   14f40:	00014e19 	.word	0x00014e19

00014f44 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(const struct device *unused)
{
   14f44:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	STRUCT_SECTION_FOREACH(k_heap, h) {
   14f46:	4c06      	ldr	r4, [pc, #24]	; (14f60 <statics_init+0x1c>)
   14f48:	4d06      	ldr	r5, [pc, #24]	; (14f64 <statics_init+0x20>)
   14f4a:	42ac      	cmp	r4, r5
   14f4c:	d301      	bcc.n	14f52 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   14f4e:	2000      	movs	r0, #0
   14f50:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   14f52:	4620      	mov	r0, r4
   14f54:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   14f58:	f001 fdf3 	bl	16b42 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   14f5c:	3414      	adds	r4, #20
   14f5e:	e7f4      	b.n	14f4a <statics_init+0x6>
   14f60:	2000c598 	.word	0x2000c598
   14f64:	2000c5ac 	.word	0x2000c5ac

00014f68 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   14f68:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   14f6c:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   14f6e:	f100 0558 	add.w	r5, r0, #88	; 0x58
   14f72:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   14f74:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   14f76:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   14f7a:	2500      	movs	r5, #0
{
   14f7c:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   14f7e:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   14f80:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   14f82:	e9c0 5506 	strd	r5, r5, [r0, #24]
   14f86:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   14f88:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   14f8a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   14f8c:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   14f90:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   14f94:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   14f96:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   14f98:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   14f9a:	9202      	str	r2, [sp, #8]
   14f9c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   14f9e:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   14fa2:	9201      	str	r2, [sp, #4]
   14fa4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   14fa6:	9200      	str	r2, [sp, #0]
   14fa8:	4642      	mov	r2, r8
   14faa:	f7fc fb63 	bl	11674 <arch_new_thread>
	if (!_current) {
   14fae:	4b05      	ldr	r3, [pc, #20]	; (14fc4 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   14fb0:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   14fb2:	689b      	ldr	r3, [r3, #8]
   14fb4:	b103      	cbz	r3, 14fb8 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   14fb6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   14fb8:	4640      	mov	r0, r8
   14fba:	6723      	str	r3, [r4, #112]	; 0x70
   14fbc:	b004      	add	sp, #16
   14fbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14fc2:	bf00      	nop
   14fc4:	2000cc78 	.word	0x2000cc78

00014fc8 <z_init_static_threads>:
{
   14fc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   14fcc:	4e2a      	ldr	r6, [pc, #168]	; (15078 <z_init_static_threads+0xb0>)
   14fce:	4d2b      	ldr	r5, [pc, #172]	; (1507c <z_init_static_threads+0xb4>)
   14fd0:	46b0      	mov	r8, r6
{
   14fd2:	b086      	sub	sp, #24
	_FOREACH_STATIC_THREAD(thread_data) {
   14fd4:	42b5      	cmp	r5, r6
   14fd6:	f105 0430 	add.w	r4, r5, #48	; 0x30
   14fda:	d310      	bcc.n	14ffe <z_init_static_threads+0x36>
	k_sched_lock();
   14fdc:	f000 f9d0 	bl	15380 <k_sched_lock>
		} else {
			return (t * to_hz + off) / from_hz;
   14fe0:	f44f 4900 	mov.w	r9, #32768	; 0x8000
   14fe4:	f240 36e7 	movw	r6, #999	; 0x3e7
   14fe8:	2700      	movs	r7, #0
	_FOREACH_STATIC_THREAD(thread_data) {
   14fea:	4c24      	ldr	r4, [pc, #144]	; (1507c <z_init_static_threads+0xb4>)

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   14fec:	f8df a090 	ldr.w	sl, [pc, #144]	; 15080 <z_init_static_threads+0xb8>
   14ff0:	4544      	cmp	r4, r8
   14ff2:	d321      	bcc.n	15038 <z_init_static_threads+0x70>
}
   14ff4:	b006      	add	sp, #24
   14ff6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	k_sched_unlock();
   14ffa:	f000 bb9b 	b.w	15734 <k_sched_unlock>
		z_setup_new_thread(
   14ffe:	f854 3c04 	ldr.w	r3, [r4, #-4]
   15002:	9305      	str	r3, [sp, #20]
   15004:	f854 3c10 	ldr.w	r3, [r4, #-16]
   15008:	9304      	str	r3, [sp, #16]
   1500a:	f854 3c14 	ldr.w	r3, [r4, #-20]
   1500e:	9303      	str	r3, [sp, #12]
   15010:	f854 3c18 	ldr.w	r3, [r4, #-24]
   15014:	9302      	str	r3, [sp, #8]
   15016:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1501a:	9301      	str	r3, [sp, #4]
   1501c:	f854 3c20 	ldr.w	r3, [r4, #-32]
   15020:	9300      	str	r3, [sp, #0]
   15022:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   15026:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   1502a:	f7ff ff9d 	bl	14f68 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   1502e:	f854 3c30 	ldr.w	r3, [r4, #-48]
   15032:	655d      	str	r5, [r3, #84]	; 0x54
   15034:	4625      	mov	r5, r4
   15036:	e7cd      	b.n	14fd4 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   15038:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1503a:	1c5a      	adds	r2, r3, #1
   1503c:	d00d      	beq.n	1505a <z_init_static_threads+0x92>
   1503e:	4630      	mov	r0, r6
   15040:	4639      	mov	r1, r7
					    K_MSEC(thread_data->init_delay));
   15042:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   15046:	fbc9 0103 	smlal	r0, r1, r9, r3
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   1504a:	42b9      	cmp	r1, r7
   1504c:	bf08      	it	eq
   1504e:	42b0      	cmpeq	r0, r6
			schedule_new_thread(thread_data->init_thread,
   15050:	6825      	ldr	r5, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   15052:	d104      	bne.n	1505e <z_init_static_threads+0x96>
	z_sched_start(thread);
   15054:	4628      	mov	r0, r5
   15056:	f000 fa7f 	bl	15558 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   1505a:	3430      	adds	r4, #48	; 0x30
   1505c:	e7c8      	b.n	14ff0 <z_init_static_threads+0x28>
   1505e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   15062:	2300      	movs	r3, #0
   15064:	f7fb f8ea 	bl	1023c <__aeabi_uldivmod>
   15068:	4602      	mov	r2, r0
   1506a:	460b      	mov	r3, r1
   1506c:	f105 0018 	add.w	r0, r5, #24
   15070:	4651      	mov	r1, sl
   15072:	f000 fcf1 	bl	15a58 <z_add_timeout>
   15076:	e7f0      	b.n	1505a <z_init_static_threads+0x92>
   15078:	2000c598 	.word	0x2000c598
   1507c:	2000c598 	.word	0x2000c598
   15080:	00016d3b 	.word	0x00016d3b

00015084 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   15084:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   15086:	4c09      	ldr	r4, [pc, #36]	; (150ac <idle+0x28>)
	__asm__ volatile(
   15088:	f04f 0220 	mov.w	r2, #32
   1508c:	f3ef 8311 	mrs	r3, BASEPRI
   15090:	f382 8812 	msr	BASEPRI_MAX, r2
   15094:	f3bf 8f6f 	isb	sy
   15098:	f001 fef1 	bl	16e7e <z_get_next_timeout_expiry>
   1509c:	61a0      	str	r0, [r4, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
   1509e:	f7fc f97f 	bl	113a0 <pm_system_suspend>
   150a2:	2800      	cmp	r0, #0
   150a4:	d1f0      	bne.n	15088 <idle+0x4>
	arch_cpu_idle();
   150a6:	f7fc fa0d 	bl	114c4 <arch_cpu_idle>
}
   150aa:	e7ed      	b.n	15088 <idle+0x4>
   150ac:	2000cc78 	.word	0x2000cc78

000150b0 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   150b0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   150b4:	4604      	mov	r4, r0
   150b6:	4616      	mov	r6, r2
   150b8:	461f      	mov	r7, r3
   150ba:	f04f 0320 	mov.w	r3, #32
   150be:	f3ef 8811 	mrs	r8, BASEPRI
   150c2:	f383 8812 	msr	BASEPRI_MAX, r3
   150c6:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   150ca:	68c3      	ldr	r3, [r0, #12]
   150cc:	4a35      	ldr	r2, [pc, #212]	; (151a4 <z_impl_k_mutex_lock+0xf4>)
   150ce:	b16b      	cbz	r3, 150ec <z_impl_k_mutex_lock+0x3c>
   150d0:	6880      	ldr	r0, [r0, #8]
   150d2:	6891      	ldr	r1, [r2, #8]
   150d4:	4288      	cmp	r0, r1
   150d6:	d019      	beq.n	1510c <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   150d8:	ea56 0307 	orrs.w	r3, r6, r7
   150dc:	d118      	bne.n	15110 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   150de:	f388 8811 	msr	BASEPRI, r8
   150e2:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   150e6:	f06f 000f 	mvn.w	r0, #15
   150ea:	e00c      	b.n	15106 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   150ec:	6891      	ldr	r1, [r2, #8]
   150ee:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   150f2:	3301      	adds	r3, #1
   150f4:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   150f6:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   150f8:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   150fa:	60a3      	str	r3, [r4, #8]
   150fc:	f388 8811 	msr	BASEPRI, r8
   15100:	f3bf 8f6f 	isb	sy
		return 0;
   15104:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   15106:	b002      	add	sp, #8
   15108:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   1510c:	6921      	ldr	r1, [r4, #16]
   1510e:	e7f0      	b.n	150f2 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   15110:	f991 100e 	ldrsb.w	r1, [r1, #14]
   15114:	f990 300e 	ldrsb.w	r3, [r0, #14]
	thread->base.thread_state &= ~states;
}

static inline bool z_is_under_prio_ceiling(int prio)
{
	return prio >= CONFIG_PRIORITY_CEILING;
   15118:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   1511c:	4299      	cmp	r1, r3
   1511e:	bfa8      	it	ge
   15120:	4619      	movge	r1, r3
   15122:	4291      	cmp	r1, r2
   15124:	bfb8      	it	lt
   15126:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   15128:	428b      	cmp	r3, r1
   1512a:	dd2f      	ble.n	1518c <z_impl_k_mutex_lock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   1512c:	f000 fa84 	bl	15638 <z_set_prio>
   15130:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   15132:	4622      	mov	r2, r4
   15134:	4641      	mov	r1, r8
   15136:	e9cd 6700 	strd	r6, r7, [sp]
   1513a:	481b      	ldr	r0, [pc, #108]	; (151a8 <z_impl_k_mutex_lock+0xf8>)
   1513c:	f000 fa68 	bl	15610 <z_pend_curr>
	if (got_mutex == 0) {
   15140:	2800      	cmp	r0, #0
   15142:	d0e0      	beq.n	15106 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   15144:	f04f 0320 	mov.w	r3, #32
   15148:	f3ef 8611 	mrs	r6, BASEPRI
   1514c:	f383 8812 	msr	BASEPRI_MAX, r3
   15150:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   15154:	6823      	ldr	r3, [r4, #0]
   15156:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15158:	429c      	cmp	r4, r3
   1515a:	d00a      	beq.n	15172 <z_impl_k_mutex_lock+0xc2>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   1515c:	b14b      	cbz	r3, 15172 <z_impl_k_mutex_lock+0xc2>
   1515e:	f993 300e 	ldrsb.w	r3, [r3, #14]
   15162:	4299      	cmp	r1, r3
   15164:	bfa8      	it	ge
   15166:	4619      	movge	r1, r3
   15168:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   1516c:	4299      	cmp	r1, r3
   1516e:	bfb8      	it	lt
   15170:	4619      	movlt	r1, r3
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   15172:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   15174:	f990 300e 	ldrsb.w	r3, [r0, #14]
   15178:	4299      	cmp	r1, r3
   1517a:	d109      	bne.n	15190 <z_impl_k_mutex_lock+0xe0>
	if (resched) {
   1517c:	b16d      	cbz	r5, 1519a <z_impl_k_mutex_lock+0xea>
		z_reschedule(&lock, key);
   1517e:	4631      	mov	r1, r6
   15180:	4809      	ldr	r0, [pc, #36]	; (151a8 <z_impl_k_mutex_lock+0xf8>)
   15182:	f000 f8eb 	bl	1535c <z_reschedule>
	return -EAGAIN;
   15186:	f06f 000a 	mvn.w	r0, #10
   1518a:	e7bc      	b.n	15106 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   1518c:	2500      	movs	r5, #0
   1518e:	e7d0      	b.n	15132 <z_impl_k_mutex_lock+0x82>
		return z_set_prio(mutex->owner, new_prio);
   15190:	f000 fa52 	bl	15638 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   15194:	2800      	cmp	r0, #0
   15196:	d1f2      	bne.n	1517e <z_impl_k_mutex_lock+0xce>
   15198:	e7f0      	b.n	1517c <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   1519a:	f386 8811 	msr	BASEPRI, r6
   1519e:	f3bf 8f6f 	isb	sy
   151a2:	e7f0      	b.n	15186 <z_impl_k_mutex_lock+0xd6>
   151a4:	2000cc78 	.word	0x2000cc78
   151a8:	2000cdf1 	.word	0x2000cdf1

000151ac <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   151ac:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   151ae:	6883      	ldr	r3, [r0, #8]
{
   151b0:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   151b2:	2b00      	cmp	r3, #0
   151b4:	d036      	beq.n	15224 <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   151b6:	4a1e      	ldr	r2, [pc, #120]	; (15230 <z_impl_k_mutex_unlock+0x84>)
   151b8:	6892      	ldr	r2, [r2, #8]
   151ba:	4293      	cmp	r3, r2
   151bc:	d135      	bne.n	1522a <z_impl_k_mutex_unlock+0x7e>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
   151be:	7bda      	ldrb	r2, [r3, #15]
   151c0:	3a01      	subs	r2, #1
   151c2:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   151c4:	68c3      	ldr	r3, [r0, #12]
   151c6:	2b01      	cmp	r3, #1
   151c8:	d905      	bls.n	151d6 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   151ca:	3b01      	subs	r3, #1
   151cc:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
   151ce:	f000 fab1 	bl	15734 <k_sched_unlock>

	return 0;
   151d2:	2000      	movs	r0, #0
}
   151d4:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   151d6:	f04f 0320 	mov.w	r3, #32
   151da:	f3ef 8511 	mrs	r5, BASEPRI
   151de:	f383 8812 	msr	BASEPRI_MAX, r3
   151e2:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   151e6:	6901      	ldr	r1, [r0, #16]
   151e8:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   151ea:	f990 300e 	ldrsb.w	r3, [r0, #14]
   151ee:	4299      	cmp	r1, r3
   151f0:	d001      	beq.n	151f6 <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   151f2:	f000 fa21 	bl	15638 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   151f6:	4620      	mov	r0, r4
   151f8:	f001 fe03 	bl	16e02 <z_unpend_first_thread>
	mutex->owner = new_owner;
   151fc:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   151fe:	b158      	cbz	r0, 15218 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   15200:	f990 200e 	ldrsb.w	r2, [r0, #14]
   15204:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   15206:	2200      	movs	r2, #0
   15208:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   1520a:	f001 fd86 	bl	16d1a <z_ready_thread>
		z_reschedule(&lock, key);
   1520e:	4629      	mov	r1, r5
   15210:	4808      	ldr	r0, [pc, #32]	; (15234 <z_impl_k_mutex_unlock+0x88>)
   15212:	f000 f8a3 	bl	1535c <z_reschedule>
   15216:	e7da      	b.n	151ce <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   15218:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   1521a:	f385 8811 	msr	BASEPRI, r5
   1521e:	f3bf 8f6f 	isb	sy
   15222:	e7d4      	b.n	151ce <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   15224:	f06f 0015 	mvn.w	r0, #21
   15228:	e7d4      	b.n	151d4 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   1522a:	f04f 30ff 	mov.w	r0, #4294967295
   1522e:	e7d1      	b.n	151d4 <z_impl_k_mutex_unlock+0x28>
   15230:	2000cc78 	.word	0x2000cc78
   15234:	2000cdf1 	.word	0x2000cdf1

00015238 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   15238:	b538      	push	{r3, r4, r5, lr}
   1523a:	4604      	mov	r4, r0
	__asm__ volatile(
   1523c:	f04f 0320 	mov.w	r3, #32
   15240:	f3ef 8511 	mrs	r5, BASEPRI
   15244:	f383 8812 	msr	BASEPRI_MAX, r3
   15248:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   1524c:	f001 fdd9 	bl	16e02 <z_unpend_first_thread>

	if (thread != NULL) {
   15250:	b148      	cbz	r0, 15266 <z_impl_k_sem_give+0x2e>
   15252:	2200      	movs	r2, #0
   15254:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   15256:	f001 fd60 	bl	16d1a <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   1525a:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   1525c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   15260:	4804      	ldr	r0, [pc, #16]	; (15274 <z_impl_k_sem_give+0x3c>)
   15262:	f000 b87b 	b.w	1535c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   15266:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   1526a:	429a      	cmp	r2, r3
   1526c:	bf18      	it	ne
   1526e:	3301      	addne	r3, #1
   15270:	60a3      	str	r3, [r4, #8]
		handle_poll_events(sem);
   15272:	e7f2      	b.n	1525a <z_impl_k_sem_give+0x22>
   15274:	2000cdf1 	.word	0x2000cdf1

00015278 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   15278:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1527a:	4614      	mov	r4, r2
   1527c:	461d      	mov	r5, r3
   1527e:	f04f 0320 	mov.w	r3, #32
   15282:	f3ef 8111 	mrs	r1, BASEPRI
   15286:	f383 8812 	msr	BASEPRI_MAX, r3
   1528a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   1528e:	6883      	ldr	r3, [r0, #8]
   15290:	b143      	cbz	r3, 152a4 <z_impl_k_sem_take+0x2c>
		sem->count--;
   15292:	3b01      	subs	r3, #1
   15294:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   15296:	f381 8811 	msr	BASEPRI, r1
   1529a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   1529e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   152a0:	b003      	add	sp, #12
   152a2:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   152a4:	ea54 0305 	orrs.w	r3, r4, r5
   152a8:	d106      	bne.n	152b8 <z_impl_k_sem_take+0x40>
   152aa:	f381 8811 	msr	BASEPRI, r1
   152ae:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   152b2:	f06f 000f 	mvn.w	r0, #15
   152b6:	e7f3      	b.n	152a0 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   152b8:	4602      	mov	r2, r0
   152ba:	e9cd 4500 	strd	r4, r5, [sp]
   152be:	4802      	ldr	r0, [pc, #8]	; (152c8 <z_impl_k_sem_take+0x50>)
   152c0:	f000 f9a6 	bl	15610 <z_pend_curr>
	return ret;
   152c4:	e7ec      	b.n	152a0 <z_impl_k_sem_take+0x28>
   152c6:	bf00      	nop
   152c8:	2000cdf1 	.word	0x2000cdf1

000152cc <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   152cc:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   152ce:	4c08      	ldr	r4, [pc, #32]	; (152f0 <z_reset_time_slice+0x24>)
   152d0:	6823      	ldr	r3, [r4, #0]
   152d2:	b15b      	cbz	r3, 152ec <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   152d4:	f7fd fbcc 	bl	12a70 <sys_clock_elapsed>
   152d8:	4603      	mov	r3, r0
   152da:	6820      	ldr	r0, [r4, #0]
   152dc:	4a05      	ldr	r2, [pc, #20]	; (152f4 <z_reset_time_slice+0x28>)
   152de:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
   152e0:	2100      	movs	r1, #0
	}
}
   152e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
   152e6:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   152e8:	f001 bdd9 	b.w	16e9e <z_set_timeout_expiry>
}
   152ec:	bd10      	pop	{r4, pc}
   152ee:	bf00      	nop
   152f0:	2000cca8 	.word	0x2000cca8
   152f4:	2000cc78 	.word	0x2000cc78

000152f8 <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
   152f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   152fa:	4604      	mov	r4, r0
   152fc:	460d      	mov	r5, r1
	__asm__ volatile(
   152fe:	f04f 0320 	mov.w	r3, #32
   15302:	f3ef 8611 	mrs	r6, BASEPRI
   15306:	f383 8812 	msr	BASEPRI_MAX, r3
   1530a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   1530e:	2200      	movs	r2, #0
			return (uint32_t)((t * to_hz + off) / from_hz);
   15310:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   15314:	f240 30e7 	movw	r0, #999	; 0x3e7
   15318:	2100      	movs	r1, #0
   1531a:	4b0d      	ldr	r3, [pc, #52]	; (15350 <k_sched_time_slice_set+0x58>)
   1531c:	fbe7 0104 	umlal	r0, r1, r7, r4
   15320:	611a      	str	r2, [r3, #16]
   15322:	2300      	movs	r3, #0
   15324:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   15328:	f7fa ff88 	bl	1023c <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
   1532c:	2c00      	cmp	r4, #0
   1532e:	4b09      	ldr	r3, [pc, #36]	; (15354 <k_sched_time_slice_set+0x5c>)
   15330:	dc09      	bgt.n	15346 <k_sched_time_slice_set+0x4e>
			/* It's not possible to reliably set a 1-tick
			 * timeout if ticks aren't regular.
			 */
			slice_time = MAX(2, slice_time);
   15332:	6018      	str	r0, [r3, #0]
		}
		slice_max_prio = prio;
   15334:	4b08      	ldr	r3, [pc, #32]	; (15358 <k_sched_time_slice_set+0x60>)
   15336:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   15338:	f7ff ffc8 	bl	152cc <z_reset_time_slice>
	__asm__ volatile(
   1533c:	f386 8811 	msr	BASEPRI, r6
   15340:	f3bf 8f6f 	isb	sy
	}
}
   15344:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			slice_time = MAX(2, slice_time);
   15346:	2802      	cmp	r0, #2
   15348:	bfb8      	it	lt
   1534a:	2002      	movlt	r0, #2
   1534c:	e7f1      	b.n	15332 <k_sched_time_slice_set+0x3a>
   1534e:	bf00      	nop
   15350:	2000cc78 	.word	0x2000cc78
   15354:	2000cca8 	.word	0x2000cca8
   15358:	2000cca4 	.word	0x2000cca4

0001535c <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1535c:	b949      	cbnz	r1, 15372 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1535e:	f3ef 8005 	mrs	r0, IPSR
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
   15362:	b930      	cbnz	r0, 15372 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   15364:	4b05      	ldr	r3, [pc, #20]	; (1537c <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   15366:	69da      	ldr	r2, [r3, #28]
   15368:	689b      	ldr	r3, [r3, #8]
   1536a:	429a      	cmp	r2, r3
   1536c:	d001      	beq.n	15372 <z_reschedule+0x16>
	ret = arch_swap(key);
   1536e:	f7fc b92b 	b.w	115c8 <arch_swap>
   15372:	f381 8811 	msr	BASEPRI, r1
   15376:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   1537a:	4770      	bx	lr
   1537c:	2000cc78 	.word	0x2000cc78

00015380 <k_sched_lock>:
	__asm__ volatile(
   15380:	f04f 0320 	mov.w	r3, #32
   15384:	f3ef 8111 	mrs	r1, BASEPRI
   15388:	f383 8812 	msr	BASEPRI_MAX, r3
   1538c:	f3bf 8f6f 	isb	sy
   15390:	4b04      	ldr	r3, [pc, #16]	; (153a4 <k_sched_lock+0x24>)
   15392:	689a      	ldr	r2, [r3, #8]
   15394:	7bd3      	ldrb	r3, [r2, #15]
   15396:	3b01      	subs	r3, #1
   15398:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   1539a:	f381 8811 	msr	BASEPRI, r1
   1539e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
   153a2:	4770      	bx	lr
   153a4:	2000cc78 	.word	0x2000cc78

000153a8 <update_cache>:
{
   153a8:	b538      	push	{r3, r4, r5, lr}
   153aa:	4602      	mov	r2, r0
	return _priq_run_best(curr_cpu_runq());
   153ac:	480c      	ldr	r0, [pc, #48]	; (153e0 <update_cache+0x38>)
   153ae:	f001 fcaa 	bl	16d06 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   153b2:	4d0c      	ldr	r5, [pc, #48]	; (153e4 <update_cache+0x3c>)
   153b4:	4604      	mov	r4, r0
   153b6:	b900      	cbnz	r0, 153ba <update_cache+0x12>
   153b8:	68ec      	ldr	r4, [r5, #12]
	if (preempt_ok != 0) {
   153ba:	68ab      	ldr	r3, [r5, #8]
   153bc:	b94a      	cbnz	r2, 153d2 <update_cache+0x2a>
	if (z_is_thread_prevented_from_running(_current)) {
   153be:	7b5a      	ldrb	r2, [r3, #13]
   153c0:	06d2      	lsls	r2, r2, #27
   153c2:	d106      	bne.n	153d2 <update_cache+0x2a>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   153c4:	69a2      	ldr	r2, [r4, #24]
   153c6:	b922      	cbnz	r2, 153d2 <update_cache+0x2a>
	if (is_preempt(_current) || is_metairq(thread)) {
   153c8:	89da      	ldrh	r2, [r3, #14]
   153ca:	2a7f      	cmp	r2, #127	; 0x7f
   153cc:	d901      	bls.n	153d2 <update_cache+0x2a>
		_kernel.ready_q.cache = _current;
   153ce:	61eb      	str	r3, [r5, #28]
}
   153d0:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
   153d2:	429c      	cmp	r4, r3
   153d4:	d001      	beq.n	153da <update_cache+0x32>
			z_reset_time_slice();
   153d6:	f7ff ff79 	bl	152cc <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   153da:	61ec      	str	r4, [r5, #28]
}
   153dc:	e7f8      	b.n	153d0 <update_cache+0x28>
   153de:	bf00      	nop
   153e0:	2000cc98 	.word	0x2000cc98
   153e4:	2000cc78 	.word	0x2000cc78

000153e8 <move_thread_to_end_of_prio_q>:
{
   153e8:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   153ea:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   153ee:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   153f0:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   153f2:	7b43      	ldrb	r3, [r0, #13]
   153f4:	da04      	bge.n	15400 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   153f6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   153fa:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   153fc:	f001 fc37 	bl	16c6e <sys_dlist_remove>
	return list->head == list;
   15400:	4a17      	ldr	r2, [pc, #92]	; (15460 <move_thread_to_end_of_prio_q+0x78>)
	thread->base.thread_state |= _THREAD_QUEUED;
   15402:	7b4b      	ldrb	r3, [r1, #13]
   15404:	4610      	mov	r0, r2
   15406:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1540a:	734b      	strb	r3, [r1, #13]
   1540c:	f850 3f20 	ldr.w	r3, [r0, #32]!
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   15410:	6a55      	ldr	r5, [r2, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15412:	4283      	cmp	r3, r0
   15414:	bf08      	it	eq
   15416:	2300      	moveq	r3, #0
   15418:	2b00      	cmp	r3, #0
   1541a:	bf38      	it	cc
   1541c:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1541e:	b1cb      	cbz	r3, 15454 <move_thread_to_end_of_prio_q+0x6c>
	int32_t b1 = thread_1->base.prio;
   15420:	f991 600e 	ldrsb.w	r6, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   15424:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   15428:	42a6      	cmp	r6, r4
   1542a:	d00f      	beq.n	1544c <move_thread_to_end_of_prio_q+0x64>
		return b2 - b1;
   1542c:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   1542e:	2c00      	cmp	r4, #0
   15430:	dd0c      	ble.n	1544c <move_thread_to_end_of_prio_q+0x64>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   15432:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   15434:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   15438:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   1543a:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   1543c:	6890      	ldr	r0, [r2, #8]
}
   1543e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   15442:	1a43      	subs	r3, r0, r1
   15444:	4258      	negs	r0, r3
   15446:	4158      	adcs	r0, r3
   15448:	f7ff bfae 	b.w	153a8 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   1544c:	42ab      	cmp	r3, r5
   1544e:	d001      	beq.n	15454 <move_thread_to_end_of_prio_q+0x6c>
   15450:	681b      	ldr	r3, [r3, #0]
   15452:	e7e4      	b.n	1541e <move_thread_to_end_of_prio_q+0x36>
	node->prev = tail;
   15454:	e9c1 0500 	strd	r0, r5, [r1]
	tail->next = node;
   15458:	6029      	str	r1, [r5, #0]
	list->tail = node;
   1545a:	6251      	str	r1, [r2, #36]	; 0x24
}
   1545c:	e7ee      	b.n	1543c <move_thread_to_end_of_prio_q+0x54>
   1545e:	bf00      	nop
   15460:	2000cc78 	.word	0x2000cc78

00015464 <z_time_slice>:
{
   15464:	4601      	mov	r1, r0
   15466:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
   15468:	f04f 0320 	mov.w	r3, #32
   1546c:	f3ef 8411 	mrs	r4, BASEPRI
   15470:	f383 8812 	msr	BASEPRI_MAX, r3
   15474:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
   15478:	4b16      	ldr	r3, [pc, #88]	; (154d4 <z_time_slice+0x70>)
   1547a:	4a17      	ldr	r2, [pc, #92]	; (154d8 <z_time_slice+0x74>)
   1547c:	6898      	ldr	r0, [r3, #8]
   1547e:	6815      	ldr	r5, [r2, #0]
   15480:	42a8      	cmp	r0, r5
   15482:	461d      	mov	r5, r3
   15484:	d106      	bne.n	15494 <z_time_slice+0x30>
			z_reset_time_slice();
   15486:	f7ff ff21 	bl	152cc <z_reset_time_slice>
	__asm__ volatile(
   1548a:	f384 8811 	msr	BASEPRI, r4
   1548e:	f3bf 8f6f 	isb	sy
}
   15492:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
   15494:	2600      	movs	r6, #0
   15496:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
   15498:	4a10      	ldr	r2, [pc, #64]	; (154dc <z_time_slice+0x78>)
   1549a:	6812      	ldr	r2, [r2, #0]
   1549c:	b1ba      	cbz	r2, 154ce <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   1549e:	89c2      	ldrh	r2, [r0, #14]
   154a0:	2a7f      	cmp	r2, #127	; 0x7f
   154a2:	d814      	bhi.n	154ce <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
   154a4:	7b42      	ldrb	r2, [r0, #13]
   154a6:	06d2      	lsls	r2, r2, #27
   154a8:	d111      	bne.n	154ce <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   154aa:	4a0d      	ldr	r2, [pc, #52]	; (154e0 <z_time_slice+0x7c>)
   154ac:	f990 600e 	ldrsb.w	r6, [r0, #14]
   154b0:	6812      	ldr	r2, [r2, #0]
   154b2:	4296      	cmp	r6, r2
   154b4:	db0b      	blt.n	154ce <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
   154b6:	4a0b      	ldr	r2, [pc, #44]	; (154e4 <z_time_slice+0x80>)
   154b8:	4290      	cmp	r0, r2
   154ba:	d008      	beq.n	154ce <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
   154bc:	691a      	ldr	r2, [r3, #16]
   154be:	428a      	cmp	r2, r1
   154c0:	dc02      	bgt.n	154c8 <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
   154c2:	f7ff ff91 	bl	153e8 <move_thread_to_end_of_prio_q>
   154c6:	e7de      	b.n	15486 <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
   154c8:	1a52      	subs	r2, r2, r1
   154ca:	611a      	str	r2, [r3, #16]
   154cc:	e7dd      	b.n	1548a <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
   154ce:	2300      	movs	r3, #0
   154d0:	612b      	str	r3, [r5, #16]
   154d2:	e7da      	b.n	1548a <z_time_slice+0x26>
   154d4:	2000cc78 	.word	0x2000cc78
   154d8:	2000cca0 	.word	0x2000cca0
   154dc:	2000cca8 	.word	0x2000cca8
   154e0:	2000cca4 	.word	0x2000cca4
   154e4:	2000c700 	.word	0x2000c700

000154e8 <ready_thread>:
{
   154e8:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   154ea:	f990 300d 	ldrsb.w	r3, [r0, #13]
   154ee:	7b42      	ldrb	r2, [r0, #13]
   154f0:	2b00      	cmp	r3, #0
   154f2:	db2d      	blt.n	15550 <ready_thread+0x68>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   154f4:	06d3      	lsls	r3, r2, #27
   154f6:	d12b      	bne.n	15550 <ready_thread+0x68>
	return !sys_dnode_is_linked(&to->node);
   154f8:	6983      	ldr	r3, [r0, #24]
   154fa:	bb4b      	cbnz	r3, 15550 <ready_thread+0x68>
	return list->head == list;
   154fc:	4915      	ldr	r1, [pc, #84]	; (15554 <ready_thread+0x6c>)
	thread->base.thread_state |= _THREAD_QUEUED;
   154fe:	f062 027f 	orn	r2, r2, #127	; 0x7f
   15502:	7342      	strb	r2, [r0, #13]
   15504:	460a      	mov	r2, r1
   15506:	f852 4f20 	ldr.w	r4, [r2, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1550a:	6a4d      	ldr	r5, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1550c:	4294      	cmp	r4, r2
   1550e:	bf18      	it	ne
   15510:	4623      	movne	r3, r4
   15512:	2b00      	cmp	r3, #0
   15514:	bf38      	it	cc
   15516:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   15518:	b1ab      	cbz	r3, 15546 <ready_thread+0x5e>
	int32_t b1 = thread_1->base.prio;
   1551a:	f990 600e 	ldrsb.w	r6, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   1551e:	f993 400e 	ldrsb.w	r4, [r3, #14]
	if (b1 != b2) {
   15522:	42a6      	cmp	r6, r4
   15524:	d00b      	beq.n	1553e <ready_thread+0x56>
		return b2 - b1;
   15526:	1ba4      	subs	r4, r4, r6
		if (z_sched_prio_cmp(thread, t) > 0) {
   15528:	2c00      	cmp	r4, #0
   1552a:	dd08      	ble.n	1553e <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
   1552c:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1552e:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   15532:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   15534:	6058      	str	r0, [r3, #4]
		update_cache(0);
   15536:	2000      	movs	r0, #0
}
   15538:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   1553a:	f7ff bf35 	b.w	153a8 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   1553e:	42ab      	cmp	r3, r5
   15540:	d001      	beq.n	15546 <ready_thread+0x5e>
   15542:	681b      	ldr	r3, [r3, #0]
   15544:	e7e8      	b.n	15518 <ready_thread+0x30>
	node->prev = tail;
   15546:	e9c0 2500 	strd	r2, r5, [r0]
	tail->next = node;
   1554a:	6028      	str	r0, [r5, #0]
	list->tail = node;
   1554c:	6248      	str	r0, [r1, #36]	; 0x24
}
   1554e:	e7f2      	b.n	15536 <ready_thread+0x4e>
}
   15550:	bc70      	pop	{r4, r5, r6}
   15552:	4770      	bx	lr
   15554:	2000cc78 	.word	0x2000cc78

00015558 <z_sched_start>:
{
   15558:	b510      	push	{r4, lr}
	__asm__ volatile(
   1555a:	f04f 0220 	mov.w	r2, #32
   1555e:	f3ef 8411 	mrs	r4, BASEPRI
   15562:	f382 8812 	msr	BASEPRI_MAX, r2
   15566:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   1556a:	7b42      	ldrb	r2, [r0, #13]
   1556c:	0751      	lsls	r1, r2, #29
   1556e:	d404      	bmi.n	1557a <z_sched_start+0x22>
	__asm__ volatile(
   15570:	f384 8811 	msr	BASEPRI, r4
   15574:	f3bf 8f6f 	isb	sy
}
   15578:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1557a:	f022 0204 	bic.w	r2, r2, #4
   1557e:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   15580:	f7ff ffb2 	bl	154e8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   15584:	4621      	mov	r1, r4
}
   15586:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   1558a:	4801      	ldr	r0, [pc, #4]	; (15590 <z_sched_start+0x38>)
   1558c:	f7ff bee6 	b.w	1535c <z_reschedule>
   15590:	2000cdf1 	.word	0x2000cdf1

00015594 <unready_thread>:
{
   15594:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   15596:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   1559a:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   1559c:	2a00      	cmp	r2, #0
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   1559e:	7b43      	ldrb	r3, [r0, #13]
   155a0:	da04      	bge.n	155ac <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   155a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   155a6:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   155a8:	f001 fb61 	bl	16c6e <sys_dlist_remove>
	update_cache(thread == _current);
   155ac:	4b04      	ldr	r3, [pc, #16]	; (155c0 <unready_thread+0x2c>)
   155ae:	6898      	ldr	r0, [r3, #8]
   155b0:	1a43      	subs	r3, r0, r1
   155b2:	4258      	negs	r0, r3
   155b4:	4158      	adcs	r0, r3
}
   155b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   155ba:	f7ff bef5 	b.w	153a8 <update_cache>
   155be:	bf00      	nop
   155c0:	2000cc78 	.word	0x2000cc78

000155c4 <pend>:
{
   155c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   155c8:	4606      	mov	r6, r0
   155ca:	4614      	mov	r4, r2
   155cc:	461d      	mov	r5, r3
	__asm__ volatile(
   155ce:	f04f 0320 	mov.w	r3, #32
   155d2:	f3ef 8711 	mrs	r7, BASEPRI
   155d6:	f383 8812 	msr	BASEPRI_MAX, r3
   155da:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   155de:	f001 fbce 	bl	16d7e <add_to_waitq_locked>
	__asm__ volatile(
   155e2:	f387 8811 	msr	BASEPRI, r7
   155e6:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   155ea:	1c6b      	adds	r3, r5, #1
   155ec:	bf08      	it	eq
   155ee:	f1b4 3fff 	cmpeq.w	r4, #4294967295
   155f2:	d008      	beq.n	15606 <pend+0x42>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   155f4:	4622      	mov	r2, r4
   155f6:	462b      	mov	r3, r5
   155f8:	f106 0018 	add.w	r0, r6, #24
   155fc:	4903      	ldr	r1, [pc, #12]	; (1560c <pend+0x48>)
}
   155fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   15602:	f000 ba29 	b.w	15a58 <z_add_timeout>
   15606:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1560a:	bf00      	nop
   1560c:	00016d3b 	.word	0x00016d3b

00015610 <z_pend_curr>:
{
   15610:	b510      	push	{r4, lr}
   15612:	460c      	mov	r4, r1
	pending_current = _current;
   15614:	4b06      	ldr	r3, [pc, #24]	; (15630 <z_pend_curr+0x20>)
{
   15616:	4611      	mov	r1, r2
	pending_current = _current;
   15618:	6898      	ldr	r0, [r3, #8]
   1561a:	4b06      	ldr	r3, [pc, #24]	; (15634 <z_pend_curr+0x24>)
   1561c:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   1561e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   15622:	f7ff ffcf 	bl	155c4 <pend>
   15626:	4620      	mov	r0, r4
}
   15628:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1562c:	f7fb bfcc 	b.w	115c8 <arch_swap>
   15630:	2000cc78 	.word	0x2000cc78
   15634:	2000cca0 	.word	0x2000cca0

00015638 <z_set_prio>:
{
   15638:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1563a:	4604      	mov	r4, r0
	__asm__ volatile(
   1563c:	f04f 0320 	mov.w	r3, #32
   15640:	f3ef 8611 	mrs	r6, BASEPRI
   15644:	f383 8812 	msr	BASEPRI_MAX, r3
   15648:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   1564c:	7b43      	ldrb	r3, [r0, #13]
	return (state & (_THREAD_PENDING | _THREAD_PRESTART | _THREAD_DEAD |
   1564e:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   15650:	06da      	lsls	r2, r3, #27
   15652:	d138      	bne.n	156c6 <z_set_prio+0x8e>
	return !sys_dnode_is_linked(&to->node);
   15654:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   15656:	2d00      	cmp	r5, #0
   15658:	d135      	bne.n	156c6 <z_set_prio+0x8e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   1565a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1565e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   15660:	f001 fb05 	bl	16c6e <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   15664:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   15666:	7381      	strb	r1, [r0, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
   15668:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1566c:	7343      	strb	r3, [r0, #13]
	return list->head == list;
   1566e:	4817      	ldr	r0, [pc, #92]	; (156cc <z_set_prio+0x94>)
   15670:	4603      	mov	r3, r0
   15672:	f853 7f20 	ldr.w	r7, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15676:	429f      	cmp	r7, r3
   15678:	bf18      	it	ne
   1567a:	463d      	movne	r5, r7
   1567c:	2d00      	cmp	r5, #0
   1567e:	461a      	mov	r2, r3
   15680:	462b      	mov	r3, r5
   15682:	bf38      	it	cc
   15684:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   15686:	6a47      	ldr	r7, [r0, #36]	; 0x24
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   15688:	b1c3      	cbz	r3, 156bc <z_set_prio+0x84>
	int32_t b2 = thread_2->base.prio;
   1568a:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   1568e:	42a9      	cmp	r1, r5
   15690:	d010      	beq.n	156b4 <z_set_prio+0x7c>
		return b2 - b1;
   15692:	1a6d      	subs	r5, r5, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   15694:	2d00      	cmp	r5, #0
   15696:	dd0d      	ble.n	156b4 <z_set_prio+0x7c>
	sys_dnode_t *const prev = successor->prev;
   15698:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1569a:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   1569e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   156a0:	605c      	str	r4, [r3, #4]
			update_cache(1);
   156a2:	2001      	movs	r0, #1
   156a4:	f7ff fe80 	bl	153a8 <update_cache>
   156a8:	2001      	movs	r0, #1
	__asm__ volatile(
   156aa:	f386 8811 	msr	BASEPRI, r6
   156ae:	f3bf 8f6f 	isb	sy
}
   156b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   156b4:	42bb      	cmp	r3, r7
   156b6:	d001      	beq.n	156bc <z_set_prio+0x84>
   156b8:	681b      	ldr	r3, [r3, #0]
   156ba:	e7e5      	b.n	15688 <z_set_prio+0x50>
	node->prev = tail;
   156bc:	e9c4 2700 	strd	r2, r7, [r4]
	tail->next = node;
   156c0:	603c      	str	r4, [r7, #0]
	list->tail = node;
   156c2:	6244      	str	r4, [r0, #36]	; 0x24
}
   156c4:	e7ed      	b.n	156a2 <z_set_prio+0x6a>
			thread->base.prio = prio;
   156c6:	2000      	movs	r0, #0
   156c8:	73a1      	strb	r1, [r4, #14]
   156ca:	e7ee      	b.n	156aa <z_set_prio+0x72>
   156cc:	2000cc78 	.word	0x2000cc78

000156d0 <z_impl_k_thread_suspend>:
{
   156d0:	b570      	push	{r4, r5, r6, lr}
   156d2:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   156d4:	3018      	adds	r0, #24
   156d6:	f001 fbbc 	bl	16e52 <z_abort_timeout>
	__asm__ volatile(
   156da:	f04f 0320 	mov.w	r3, #32
   156de:	f3ef 8611 	mrs	r6, BASEPRI
   156e2:	f383 8812 	msr	BASEPRI_MAX, r3
   156e6:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   156ea:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
   156ee:	7b63      	ldrb	r3, [r4, #13]
   156f0:	2a00      	cmp	r2, #0
   156f2:	da05      	bge.n	15700 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   156f4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   156f8:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   156fa:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   156fc:	f001 fab7 	bl	16c6e <sys_dlist_remove>
		update_cache(thread == _current);
   15700:	4d0b      	ldr	r5, [pc, #44]	; (15730 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   15702:	7b63      	ldrb	r3, [r4, #13]
   15704:	68a8      	ldr	r0, [r5, #8]
   15706:	f043 0310 	orr.w	r3, r3, #16
   1570a:	7363      	strb	r3, [r4, #13]
   1570c:	1b03      	subs	r3, r0, r4
   1570e:	4258      	negs	r0, r3
   15710:	4158      	adcs	r0, r3
   15712:	f7ff fe49 	bl	153a8 <update_cache>
	__asm__ volatile(
   15716:	f386 8811 	msr	BASEPRI, r6
   1571a:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   1571e:	68ab      	ldr	r3, [r5, #8]
   15720:	42a3      	cmp	r3, r4
   15722:	d103      	bne.n	1572c <z_impl_k_thread_suspend+0x5c>
}
   15724:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   15728:	f001 bae3 	b.w	16cf2 <z_reschedule_unlocked>
}
   1572c:	bd70      	pop	{r4, r5, r6, pc}
   1572e:	bf00      	nop
   15730:	2000cc78 	.word	0x2000cc78

00015734 <k_sched_unlock>:
{
   15734:	b510      	push	{r4, lr}
	__asm__ volatile(
   15736:	f04f 0320 	mov.w	r3, #32
   1573a:	f3ef 8411 	mrs	r4, BASEPRI
   1573e:	f383 8812 	msr	BASEPRI_MAX, r3
   15742:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   15746:	4b08      	ldr	r3, [pc, #32]	; (15768 <k_sched_unlock+0x34>)
		update_cache(0);
   15748:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   1574a:	689a      	ldr	r2, [r3, #8]
   1574c:	7bd3      	ldrb	r3, [r2, #15]
   1574e:	3301      	adds	r3, #1
   15750:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   15752:	f7ff fe29 	bl	153a8 <update_cache>
	__asm__ volatile(
   15756:	f384 8811 	msr	BASEPRI, r4
   1575a:	f3bf 8f6f 	isb	sy
}
   1575e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   15762:	f001 bac6 	b.w	16cf2 <z_reschedule_unlocked>
   15766:	bf00      	nop
   15768:	2000cc78 	.word	0x2000cc78

0001576c <z_sched_init>:
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   1576c:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   1576e:	4b04      	ldr	r3, [pc, #16]	; (15780 <z_sched_init+0x14>)
   15770:	4608      	mov	r0, r1
   15772:	f103 0220 	add.w	r2, r3, #32
	list->tail = (sys_dnode_t *)list;
   15776:	e9c3 2208 	strd	r2, r2, [r3, #32]
   1577a:	f7ff bdbd 	b.w	152f8 <k_sched_time_slice_set>
   1577e:	bf00      	nop
   15780:	2000cc78 	.word	0x2000cc78

00015784 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   15784:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   15786:	f04f 0320 	mov.w	r3, #32
   1578a:	f3ef 8411 	mrs	r4, BASEPRI
   1578e:	f383 8812 	msr	BASEPRI_MAX, r3
   15792:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   15796:	491b      	ldr	r1, [pc, #108]	; (15804 <z_impl_k_yield+0x80>)
   15798:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   1579a:	7b43      	ldrb	r3, [r0, #13]
   1579c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   157a0:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   157a2:	f001 fa64 	bl	16c6e <sys_dlist_remove>
	return list->head == list;
   157a6:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   157a8:	688a      	ldr	r2, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   157aa:	7b53      	ldrb	r3, [r2, #13]
   157ac:	f063 037f 	orn	r3, r3, #127	; 0x7f
   157b0:	7353      	strb	r3, [r2, #13]
   157b2:	f850 3f20 	ldr.w	r3, [r0, #32]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   157b6:	6a4e      	ldr	r6, [r1, #36]	; 0x24
	return sys_dlist_is_empty(list) ? NULL : list->head;
   157b8:	4283      	cmp	r3, r0
   157ba:	bf08      	it	eq
   157bc:	2300      	moveq	r3, #0
   157be:	2b00      	cmp	r3, #0
   157c0:	bf38      	it	cc
   157c2:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   157c4:	b1cb      	cbz	r3, 157fa <z_impl_k_yield+0x76>
	int32_t b1 = thread_1->base.prio;
   157c6:	f992 700e 	ldrsb.w	r7, [r2, #14]
	int32_t b2 = thread_2->base.prio;
   157ca:	f993 500e 	ldrsb.w	r5, [r3, #14]
	if (b1 != b2) {
   157ce:	42af      	cmp	r7, r5
   157d0:	d00f      	beq.n	157f2 <z_impl_k_yield+0x6e>
		return b2 - b1;
   157d2:	1bed      	subs	r5, r5, r7
		if (z_sched_prio_cmp(thread, t) > 0) {
   157d4:	2d00      	cmp	r5, #0
   157d6:	dd0c      	ble.n	157f2 <z_impl_k_yield+0x6e>
	sys_dnode_t *const prev = successor->prev;
   157d8:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   157da:	e9c2 3100 	strd	r3, r1, [r2]
	prev->next = node;
   157de:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   157e0:	605a      	str	r2, [r3, #4]
	update_cache(1);
   157e2:	2001      	movs	r0, #1
   157e4:	f7ff fde0 	bl	153a8 <update_cache>
   157e8:	4620      	mov	r0, r4
	z_swap(&sched_spinlock, key);
}
   157ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   157ee:	f7fb beeb 	b.w	115c8 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   157f2:	42b3      	cmp	r3, r6
   157f4:	d001      	beq.n	157fa <z_impl_k_yield+0x76>
   157f6:	681b      	ldr	r3, [r3, #0]
   157f8:	e7e4      	b.n	157c4 <z_impl_k_yield+0x40>
	node->prev = tail;
   157fa:	e9c2 0600 	strd	r0, r6, [r2]
	tail->next = node;
   157fe:	6032      	str	r2, [r6, #0]
	list->tail = node;
   15800:	624a      	str	r2, [r1, #36]	; 0x24
}
   15802:	e7ee      	b.n	157e2 <z_impl_k_yield+0x5e>
   15804:	2000cc78 	.word	0x2000cc78

00015808 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
   15808:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1580c:	4604      	mov	r4, r0
   1580e:	460d      	mov	r5, r1
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   15810:	ea54 0105 	orrs.w	r1, r4, r5
   15814:	d104      	bne.n	15820 <z_tick_sleep+0x18>
	z_impl_k_yield();
   15816:	f7ff ffb5 	bl	15784 <z_impl_k_yield>
		k_yield();
		return 0;
   1581a:	2000      	movs	r0, #0
		return ticks;
	}
#endif

	return 0;
}
   1581c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (Z_TICK_ABS(ticks) <= 0) {
   15820:	f06f 0101 	mvn.w	r1, #1
   15824:	1a0a      	subs	r2, r1, r0
   15826:	f04f 31ff 	mov.w	r1, #4294967295
   1582a:	eb61 0305 	sbc.w	r3, r1, r5
   1582e:	2a01      	cmp	r2, #1
   15830:	f173 0300 	sbcs.w	r3, r3, #0
   15834:	da2a      	bge.n	1588c <z_tick_sleep+0x84>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   15836:	f001 fb4c 	bl	16ed2 <sys_clock_tick_get_32>
   1583a:	1906      	adds	r6, r0, r4
   1583c:	f04f 0320 	mov.w	r3, #32
   15840:	f3ef 8811 	mrs	r8, BASEPRI
   15844:	f383 8812 	msr	BASEPRI_MAX, r3
   15848:	f3bf 8f6f 	isb	sy
	pending_current = _current;
   1584c:	4f11      	ldr	r7, [pc, #68]	; (15894 <z_tick_sleep+0x8c>)
   1584e:	4b12      	ldr	r3, [pc, #72]	; (15898 <z_tick_sleep+0x90>)
   15850:	68b8      	ldr	r0, [r7, #8]
   15852:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
   15854:	f7ff fe9e 	bl	15594 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   15858:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   1585a:	4910      	ldr	r1, [pc, #64]	; (1589c <z_tick_sleep+0x94>)
   1585c:	4622      	mov	r2, r4
   1585e:	462b      	mov	r3, r5
   15860:	3018      	adds	r0, #24
   15862:	f000 f8f9 	bl	15a58 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   15866:	68ba      	ldr	r2, [r7, #8]
   15868:	4640      	mov	r0, r8
   1586a:	7b53      	ldrb	r3, [r2, #13]
   1586c:	f043 0310 	orr.w	r3, r3, #16
   15870:	7353      	strb	r3, [r2, #13]
   15872:	f7fb fea9 	bl	115c8 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   15876:	f001 fb2c 	bl	16ed2 <sys_clock_tick_get_32>
   1587a:	1a30      	subs	r0, r6, r0
   1587c:	eb66 0106 	sbc.w	r1, r6, r6
	if (ticks > 0) {
   15880:	2801      	cmp	r0, #1
   15882:	f171 0300 	sbcs.w	r3, r1, #0
		return ticks;
   15886:	bfb8      	it	lt
   15888:	2000      	movlt	r0, #0
   1588a:	e7c7      	b.n	1581c <z_tick_sleep+0x14>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   1588c:	f06f 0601 	mvn.w	r6, #1
   15890:	1a36      	subs	r6, r6, r0
   15892:	e7d3      	b.n	1583c <z_tick_sleep+0x34>
   15894:	2000cc78 	.word	0x2000cc78
   15898:	2000cca0 	.word	0x2000cca0
   1589c:	00016d3b 	.word	0x00016d3b

000158a0 <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
   158a0:	b508      	push	{r3, lr}
   158a2:	460b      	mov	r3, r1
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   158a4:	3301      	adds	r3, #1
   158a6:	bf08      	it	eq
   158a8:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   158ac:	d106      	bne.n	158bc <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
   158ae:	4b08      	ldr	r3, [pc, #32]	; (158d0 <z_impl_k_sleep+0x30>)
   158b0:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   158b2:	f7ff ff0d 	bl	156d0 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
   158b6:	f04f 30ff 	mov.w	r0, #4294967295
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   158ba:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
   158bc:	f7ff ffa4 	bl	15808 <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
   158c0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   158c4:	fb80 2303 	smull	r2, r3, r0, r3
   158c8:	0bd0      	lsrs	r0, r2, #15
   158ca:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
   158ce:	e7f4      	b.n	158ba <z_impl_k_sleep+0x1a>
   158d0:	2000cc78 	.word	0x2000cc78

000158d4 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   158d4:	4b01      	ldr	r3, [pc, #4]	; (158dc <z_impl_z_current_get+0x8>)
   158d6:	6898      	ldr	r0, [r3, #8]
   158d8:	4770      	bx	lr
   158da:	bf00      	nop
   158dc:	2000cc78 	.word	0x2000cc78

000158e0 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   158e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   158e4:	4604      	mov	r4, r0
   158e6:	f04f 0320 	mov.w	r3, #32
   158ea:	f3ef 8611 	mrs	r6, BASEPRI
   158ee:	f383 8812 	msr	BASEPRI_MAX, r3
   158f2:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   158f6:	7b43      	ldrb	r3, [r0, #13]
   158f8:	071a      	lsls	r2, r3, #28
   158fa:	d505      	bpl.n	15908 <z_thread_abort+0x28>
	__asm__ volatile(
   158fc:	f386 8811 	msr	BASEPRI, r6
   15900:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   15904:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		thread->base.thread_state &= ~_THREAD_ABORTING;
   15908:	f023 0220 	bic.w	r2, r3, #32
   1590c:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   15910:	09d2      	lsrs	r2, r2, #7
   15912:	d120      	bne.n	15956 <z_thread_abort+0x76>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   15914:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   15916:	68a3      	ldr	r3, [r4, #8]
   15918:	b113      	cbz	r3, 15920 <z_thread_abort+0x40>
			unpend_thread_no_timeout(thread);
   1591a:	4620      	mov	r0, r4
   1591c:	f001 f9af 	bl	16c7e <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   15920:	f104 0018 	add.w	r0, r4, #24
   15924:	f001 fa95 	bl	16e52 <z_abort_timeout>
   15928:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   1592c:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   15930:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15932:	42bd      	cmp	r5, r7
   15934:	d000      	beq.n	15938 <z_thread_abort+0x58>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   15936:	b9b5      	cbnz	r5, 15966 <z_thread_abort+0x86>
		update_cache(1);
   15938:	2001      	movs	r0, #1
   1593a:	f7ff fd35 	bl	153a8 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   1593e:	4b10      	ldr	r3, [pc, #64]	; (15980 <z_thread_abort+0xa0>)
   15940:	689b      	ldr	r3, [r3, #8]
   15942:	42a3      	cmp	r3, r4
   15944:	d1da      	bne.n	158fc <z_thread_abort+0x1c>
   15946:	f3ef 8305 	mrs	r3, IPSR
   1594a:	2b00      	cmp	r3, #0
   1594c:	d1d6      	bne.n	158fc <z_thread_abort+0x1c>
   1594e:	4630      	mov	r0, r6
   15950:	f7fb fe3a 	bl	115c8 <arch_swap>
	return ret;
   15954:	e7d2      	b.n	158fc <z_thread_abort+0x1c>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   15956:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   1595a:	f043 0308 	orr.w	r3, r3, #8
   1595e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   15960:	f001 f985 	bl	16c6e <sys_dlist_remove>
}
   15964:	e7d7      	b.n	15916 <z_thread_abort+0x36>
		unpend_thread_no_timeout(thread);
   15966:	4628      	mov	r0, r5
   15968:	f001 f989 	bl	16c7e <unpend_thread_no_timeout>
   1596c:	f105 0018 	add.w	r0, r5, #24
   15970:	f001 fa6f 	bl	16e52 <z_abort_timeout>
		ready_thread(thread);
   15974:	4628      	mov	r0, r5
   15976:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   1597a:	f7ff fdb5 	bl	154e8 <ready_thread>
   1597e:	e7d7      	b.n	15930 <z_thread_abort+0x50>
   15980:	2000cc78 	.word	0x2000cc78

00015984 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   15984:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
   15986:	4806      	ldr	r0, [pc, #24]	; (159a0 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
   15988:	4a06      	ldr	r2, [pc, #24]	; (159a4 <z_data_copy+0x20>)
   1598a:	4907      	ldr	r1, [pc, #28]	; (159a8 <z_data_copy+0x24>)
   1598c:	1a12      	subs	r2, r2, r0
   1598e:	f000 fdfb 	bl	16588 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   15992:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
   15996:	4a05      	ldr	r2, [pc, #20]	; (159ac <z_data_copy+0x28>)
   15998:	4905      	ldr	r1, [pc, #20]	; (159b0 <z_data_copy+0x2c>)
   1599a:	4806      	ldr	r0, [pc, #24]	; (159b4 <z_data_copy+0x30>)
   1599c:	f000 bdf4 	b.w	16588 <memcpy>
   159a0:	2000c500 	.word	0x2000c500
   159a4:	2000c5ac 	.word	0x2000c5ac
   159a8:	00017648 	.word	0x00017648
   159ac:	00000000 	.word	0x00000000
   159b0:	00017630 	.word	0x00017630
   159b4:	2000c500 	.word	0x2000c500

000159b8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   159b8:	4b03      	ldr	r3, [pc, #12]	; (159c8 <elapsed+0x10>)
   159ba:	681b      	ldr	r3, [r3, #0]
   159bc:	b90b      	cbnz	r3, 159c2 <elapsed+0xa>
   159be:	f7fd b857 	b.w	12a70 <sys_clock_elapsed>
}
   159c2:	2000      	movs	r0, #0
   159c4:	4770      	bx	lr
   159c6:	bf00      	nop
   159c8:	2000ccac 	.word	0x2000ccac

000159cc <remove_timeout>:
{
   159cc:	b530      	push	{r4, r5, lr}
   159ce:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   159d0:	b168      	cbz	r0, 159ee <remove_timeout+0x22>
   159d2:	4a0a      	ldr	r2, [pc, #40]	; (159fc <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
   159d4:	6852      	ldr	r2, [r2, #4]
   159d6:	4290      	cmp	r0, r2
   159d8:	d009      	beq.n	159ee <remove_timeout+0x22>
	if (next(t) != NULL) {
   159da:	b143      	cbz	r3, 159ee <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   159dc:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   159e0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   159e4:	1912      	adds	r2, r2, r4
   159e6:	eb45 0101 	adc.w	r1, r5, r1
   159ea:	e9c3 2104 	strd	r2, r1, [r3, #16]
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
   159ee:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
   159f0:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   159f2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   159f4:	2300      	movs	r3, #0
	node->prev = NULL;
   159f6:	e9c0 3300 	strd	r3, r3, [r0]
}
   159fa:	bd30      	pop	{r4, r5, pc}
   159fc:	2000c580 	.word	0x2000c580

00015a00 <next_timeout>:

static int32_t next_timeout(void)
{
   15a00:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   15a02:	4b13      	ldr	r3, [pc, #76]	; (15a50 <next_timeout+0x50>)
   15a04:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15a06:	429c      	cmp	r4, r3
   15a08:	bf08      	it	eq
   15a0a:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   15a0c:	f7ff ffd4 	bl	159b8 <elapsed>
   15a10:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
   15a12:	b1bc      	cbz	r4, 15a44 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   15a14:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
   15a18:	1b40      	subs	r0, r0, r5
   15a1a:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
   15a1e:	2801      	cmp	r0, #1
   15a20:	f171 0300 	sbcs.w	r3, r1, #0
   15a24:	db11      	blt.n	15a4a <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
   15a26:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
   15a2a:	2300      	movs	r3, #0
   15a2c:	4282      	cmp	r2, r0
   15a2e:	eb73 0401 	sbcs.w	r4, r3, r1
   15a32:	da00      	bge.n	15a36 <next_timeout+0x36>
   15a34:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   15a36:	4b07      	ldr	r3, [pc, #28]	; (15a54 <next_timeout+0x54>)
   15a38:	691b      	ldr	r3, [r3, #16]
   15a3a:	b113      	cbz	r3, 15a42 <next_timeout+0x42>
   15a3c:	4298      	cmp	r0, r3
   15a3e:	bfa8      	it	ge
   15a40:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   15a42:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
   15a44:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   15a48:	e7f5      	b.n	15a36 <next_timeout+0x36>
   15a4a:	2000      	movs	r0, #0
   15a4c:	e7f3      	b.n	15a36 <next_timeout+0x36>
   15a4e:	bf00      	nop
   15a50:	2000c580 	.word	0x2000c580
   15a54:	2000cc78 	.word	0x2000cc78

00015a58 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   15a58:	f1b3 3fff 	cmp.w	r3, #4294967295
   15a5c:	bf08      	it	eq
   15a5e:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
   15a62:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15a66:	4604      	mov	r4, r0
   15a68:	4692      	mov	sl, r2
   15a6a:	469b      	mov	fp, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   15a6c:	d073      	beq.n	15b56 <z_add_timeout+0xfe>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   15a6e:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   15a70:	f04f 0320 	mov.w	r3, #32
   15a74:	f3ef 8511 	mrs	r5, BASEPRI
   15a78:	f383 8812 	msr	BASEPRI_MAX, r3
   15a7c:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
   15a80:	f06f 0301 	mvn.w	r3, #1
   15a84:	f04f 32ff 	mov.w	r2, #4294967295
   15a88:	ebb3 080a 	subs.w	r8, r3, sl
   15a8c:	eb62 090b 	sbc.w	r9, r2, fp
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   15a90:	f1b8 0f00 	cmp.w	r8, #0
   15a94:	f179 0100 	sbcs.w	r1, r9, #0
   15a98:	db1c      	blt.n	15ad4 <z_add_timeout+0x7c>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   15a9a:	4830      	ldr	r0, [pc, #192]	; (15b5c <z_add_timeout+0x104>)
   15a9c:	e9d0 1000 	ldrd	r1, r0, [r0]
   15aa0:	1a5b      	subs	r3, r3, r1
   15aa2:	eb62 0200 	sbc.w	r2, r2, r0

			to->dticks = MAX(1, ticks);
   15aa6:	ebb3 060a 	subs.w	r6, r3, sl
   15aaa:	eb62 070b 	sbc.w	r7, r2, fp
   15aae:	2e01      	cmp	r6, #1
   15ab0:	f177 0300 	sbcs.w	r3, r7, #0
   15ab4:	bfbc      	itt	lt
   15ab6:	2601      	movlt	r6, #1
   15ab8:	2700      	movlt	r7, #0
   15aba:	e9c4 6704 	strd	r6, r7, [r4, #16]
	return list->head == list;
   15abe:	4a28      	ldr	r2, [pc, #160]	; (15b60 <z_add_timeout+0x108>)
   15ac0:	e9d2 3c00 	ldrd	r3, ip, [r2]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15ac4:	4293      	cmp	r3, r2
   15ac6:	d11e      	bne.n	15b06 <z_add_timeout+0xae>
	node->prev = tail;
   15ac8:	e9c4 2c00 	strd	r2, ip, [r4]
	tail->next = node;
   15acc:	f8cc 4000 	str.w	r4, [ip]
	list->tail = node;
   15ad0:	6054      	str	r4, [r2, #4]
}
   15ad2:	e02d      	b.n	15b30 <z_add_timeout+0xd8>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
   15ad4:	f7ff ff70 	bl	159b8 <elapsed>
   15ad8:	f11a 0301 	adds.w	r3, sl, #1
   15adc:	9300      	str	r3, [sp, #0]
   15ade:	f14b 0300 	adc.w	r3, fp, #0
   15ae2:	9301      	str	r3, [sp, #4]
   15ae4:	e9dd 2300 	ldrd	r2, r3, [sp]
   15ae8:	1812      	adds	r2, r2, r0
   15aea:	eb43 73e0 	adc.w	r3, r3, r0, asr #31
   15aee:	e9c4 2304 	strd	r2, r3, [r4, #16]
   15af2:	e7e4      	b.n	15abe <z_add_timeout+0x66>
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
				sys_dlist_insert(&t->node, &to->node);
				break;
			}
			to->dticks -= t->dticks;
   15af4:	ebb6 0008 	subs.w	r0, r6, r8
   15af8:	eb67 0109 	sbc.w	r1, r7, r9
	return (node == list->tail) ? NULL : node->next;
   15afc:	4563      	cmp	r3, ip
   15afe:	e9c4 0104 	strd	r0, r1, [r4, #16]
   15b02:	d0e1      	beq.n	15ac8 <z_add_timeout+0x70>
   15b04:	681b      	ldr	r3, [r3, #0]
		for (t = first(); t != NULL; t = next(t)) {
   15b06:	2b00      	cmp	r3, #0
   15b08:	d0de      	beq.n	15ac8 <z_add_timeout+0x70>
			if (t->dticks > to->dticks) {
   15b0a:	e9d3 8904 	ldrd	r8, r9, [r3, #16]
   15b0e:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
   15b12:	4546      	cmp	r6, r8
   15b14:	eb77 0109 	sbcs.w	r1, r7, r9
   15b18:	daec      	bge.n	15af4 <z_add_timeout+0x9c>
				t->dticks -= to->dticks;
   15b1a:	ebb8 0006 	subs.w	r0, r8, r6
   15b1e:	eb69 0107 	sbc.w	r1, r9, r7
   15b22:	e9c3 0104 	strd	r0, r1, [r3, #16]
	sys_dnode_t *const prev = successor->prev;
   15b26:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   15b28:	e9c4 3100 	strd	r3, r1, [r4]
	prev->next = node;
   15b2c:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   15b2e:	605c      	str	r4, [r3, #4]
	return list->head == list;
   15b30:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15b32:	4293      	cmp	r3, r2
   15b34:	d00b      	beq.n	15b4e <z_add_timeout+0xf6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   15b36:	429c      	cmp	r4, r3
   15b38:	d109      	bne.n	15b4e <z_add_timeout+0xf6>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
   15b3a:	f7ff ff61 	bl	15a00 <next_timeout>

			if (next_time == 0 ||
   15b3e:	b118      	cbz	r0, 15b48 <z_add_timeout+0xf0>
			    _current_cpu->slice_ticks != next_time) {
   15b40:	4b08      	ldr	r3, [pc, #32]	; (15b64 <z_add_timeout+0x10c>)
			if (next_time == 0 ||
   15b42:	691b      	ldr	r3, [r3, #16]
   15b44:	4283      	cmp	r3, r0
   15b46:	d002      	beq.n	15b4e <z_add_timeout+0xf6>
				sys_clock_set_timeout(next_time, false);
   15b48:	2100      	movs	r1, #0
   15b4a:	f7fc ff61 	bl	12a10 <sys_clock_set_timeout>
	__asm__ volatile(
   15b4e:	f385 8811 	msr	BASEPRI, r5
   15b52:	f3bf 8f6f 	isb	sy
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
   15b56:	b003      	add	sp, #12
   15b58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15b5c:	2000c800 	.word	0x2000c800
   15b60:	2000c580 	.word	0x2000c580
   15b64:	2000cc78 	.word	0x2000cc78

00015b68 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
   15b68:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15b6c:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   15b6e:	f7ff fc79 	bl	15464 <z_time_slice>
	__asm__ volatile(
   15b72:	f04f 0320 	mov.w	r3, #32
   15b76:	f3ef 8411 	mrs	r4, BASEPRI
   15b7a:	f383 8812 	msr	BASEPRI_MAX, r3
   15b7e:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   15b82:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 15c34 <sys_clock_announce+0xcc>
   15b86:	4d2a      	ldr	r5, [pc, #168]	; (15c30 <sys_clock_announce+0xc8>)
   15b88:	4651      	mov	r1, sl
	return list->head == list;
   15b8a:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 15c38 <sys_clock_announce+0xd0>
   15b8e:	602e      	str	r6, [r5, #0]
   15b90:	f8d5 c000 	ldr.w	ip, [r5]
   15b94:	f8db 0000 	ldr.w	r0, [fp]
   15b98:	4662      	mov	r2, ip
   15b9a:	e9da 8900 	ldrd	r8, r9, [sl]
   15b9e:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15ba0:	4558      	cmp	r0, fp
   15ba2:	e9cd 2300 	strd	r2, r3, [sp]
   15ba6:	d00d      	beq.n	15bc4 <sys_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   15ba8:	b160      	cbz	r0, 15bc4 <sys_clock_announce+0x5c>
   15baa:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
   15bae:	45b4      	cmp	ip, r6
   15bb0:	41bb      	sbcs	r3, r7
   15bb2:	da1d      	bge.n	15bf0 <sys_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   15bb4:	9b00      	ldr	r3, [sp, #0]
   15bb6:	ebb6 0c03 	subs.w	ip, r6, r3
   15bba:	9b01      	ldr	r3, [sp, #4]
   15bbc:	eb67 0603 	sbc.w	r6, r7, r3
   15bc0:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   15bc4:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
   15bc6:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
   15bc8:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
   15bca:	eb13 0208 	adds.w	r2, r3, r8
   15bce:	9b01      	ldr	r3, [sp, #4]
   15bd0:	eb43 0309 	adc.w	r3, r3, r9
   15bd4:	e9c1 2300 	strd	r2, r3, [r1]

	sys_clock_set_timeout(next_timeout(), false);
   15bd8:	f7ff ff12 	bl	15a00 <next_timeout>
   15bdc:	4631      	mov	r1, r6
   15bde:	f7fc ff17 	bl	12a10 <sys_clock_set_timeout>
	__asm__ volatile(
   15be2:	f384 8811 	msr	BASEPRI, r4
   15be6:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   15bea:	b003      	add	sp, #12
   15bec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
   15bf0:	2200      	movs	r2, #0
   15bf2:	2300      	movs	r3, #0
		curr_tick += dt;
   15bf4:	eb18 0806 	adds.w	r8, r8, r6
   15bf8:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
   15bfc:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
   15c00:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
   15c04:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
   15c08:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
   15c0a:	f7ff fedf 	bl	159cc <remove_timeout>
   15c0e:	f384 8811 	msr	BASEPRI, r4
   15c12:	f3bf 8f6f 	isb	sy
		t->fn(t);
   15c16:	6883      	ldr	r3, [r0, #8]
   15c18:	4798      	blx	r3
	__asm__ volatile(
   15c1a:	f04f 0320 	mov.w	r3, #32
   15c1e:	f3ef 8411 	mrs	r4, BASEPRI
   15c22:	f383 8812 	msr	BASEPRI_MAX, r3
   15c26:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
   15c2a:	4902      	ldr	r1, [pc, #8]	; (15c34 <sys_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   15c2c:	e7b0      	b.n	15b90 <sys_clock_announce+0x28>
   15c2e:	bf00      	nop
   15c30:	2000ccac 	.word	0x2000ccac
   15c34:	2000c800 	.word	0x2000c800
   15c38:	2000c580 	.word	0x2000c580

00015c3c <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   15c3c:	b510      	push	{r4, lr}
   15c3e:	f04f 0320 	mov.w	r3, #32
   15c42:	f3ef 8411 	mrs	r4, BASEPRI
   15c46:	f383 8812 	msr	BASEPRI_MAX, r3
   15c4a:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
   15c4e:	f7fc ff0f 	bl	12a70 <sys_clock_elapsed>
   15c52:	4b06      	ldr	r3, [pc, #24]	; (15c6c <sys_clock_tick_get+0x30>)
   15c54:	e9d3 2300 	ldrd	r2, r3, [r3]
   15c58:	1812      	adds	r2, r2, r0
   15c5a:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   15c5e:	f384 8811 	msr	BASEPRI, r4
   15c62:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   15c66:	4610      	mov	r0, r2
   15c68:	4619      	mov	r1, r3
   15c6a:	bd10      	pop	{r4, pc}
   15c6c:	2000c800 	.word	0x2000c800

00015c70 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   15c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15c72:	4604      	mov	r4, r0
	__asm__ volatile(
   15c74:	f04f 0320 	mov.w	r3, #32
   15c78:	f3ef 8511 	mrs	r5, BASEPRI
   15c7c:	f383 8812 	msr	BASEPRI_MAX, r3
   15c80:	f3bf 8f6f 	isb	sy

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   15c84:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
   15c88:	1c56      	adds	r6, r2, #1
   15c8a:	f143 0700 	adc.w	r7, r3, #0
   15c8e:	2f00      	cmp	r7, #0
   15c90:	bf08      	it	eq
   15c92:	2e02      	cmpeq	r6, #2
   15c94:	d302      	bcc.n	15c9c <z_timer_expiration_handler+0x2c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   15c96:	4917      	ldr	r1, [pc, #92]	; (15cf4 <z_timer_expiration_handler+0x84>)
   15c98:	f7ff fede 	bl	15a58 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   15c9c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   15c9e:	3301      	adds	r3, #1
   15ca0:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   15ca2:	6a23      	ldr	r3, [r4, #32]
   15ca4:	b173      	cbz	r3, 15cc4 <z_timer_expiration_handler+0x54>
	__asm__ volatile(
   15ca6:	f385 8811 	msr	BASEPRI, r5
   15caa:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
   15cae:	4620      	mov	r0, r4
   15cb0:	6a23      	ldr	r3, [r4, #32]
   15cb2:	4798      	blx	r3
	__asm__ volatile(
   15cb4:	f04f 0320 	mov.w	r3, #32
   15cb8:	f3ef 8511 	mrs	r5, BASEPRI
   15cbc:	f383 8812 	msr	BASEPRI_MAX, r3
   15cc0:	f3bf 8f6f 	isb	sy
	return list->head == list;
   15cc4:	f854 6f18 	ldr.w	r6, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   15cc8:	42a6      	cmp	r6, r4
   15cca:	d000      	beq.n	15cce <z_timer_expiration_handler+0x5e>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   15ccc:	b926      	cbnz	r6, 15cd8 <z_timer_expiration_handler+0x68>
	__asm__ volatile(
   15cce:	f385 8811 	msr	BASEPRI, r5
   15cd2:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   15cd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	z_unpend_thread_no_timeout(thread);
   15cd8:	4630      	mov	r0, r6
   15cda:	f000 ffda 	bl	16c92 <z_unpend_thread_no_timeout>
   15cde:	2300      	movs	r3, #0
   15ce0:	67b3      	str	r3, [r6, #120]	; 0x78
   15ce2:	f385 8811 	msr	BASEPRI, r5
   15ce6:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   15cea:	4630      	mov	r0, r6
}
   15cec:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   15cf0:	f001 b813 	b.w	16d1a <z_ready_thread>
   15cf4:	00015c71 	.word	0x00015c71

00015cf8 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   15cf8:	e92d 4f73 	stmdb	sp!, {r0, r1, r4, r5, r6, r8, r9, sl, fp, lr}
   15cfc:	4619      	mov	r1, r3
   15cfe:	4606      	mov	r6, r0
   15d00:	4610      	mov	r0, r2
   15d02:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   15d06:	1c4c      	adds	r4, r1, #1
   15d08:	bf08      	it	eq
   15d0a:	f1b0 3fff 	cmpeq.w	r0, #4294967295
   15d0e:	4680      	mov	r8, r0
   15d10:	4689      	mov	r9, r1
   15d12:	d04c      	beq.n	15dae <z_impl_k_timer_start+0xb6>
   15d14:	461d      	mov	r5, r3
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   15d16:	1c6b      	adds	r3, r5, #1
   15d18:	bf08      	it	eq
   15d1a:	f1b2 3fff 	cmpeq.w	r2, #4294967295
   15d1e:	4614      	mov	r4, r2
   15d20:	d019      	beq.n	15d56 <z_impl_k_timer_start+0x5e>
   15d22:	ea54 0305 	orrs.w	r3, r4, r5
   15d26:	d016      	beq.n	15d56 <z_impl_k_timer_start+0x5e>
	    Z_TICK_ABS(period.ticks) < 0) {
   15d28:	f06f 0301 	mvn.w	r3, #1
   15d2c:	ebb3 0a02 	subs.w	sl, r3, r2
   15d30:	f04f 33ff 	mov.w	r3, #4294967295
   15d34:	eb63 0b05 	sbc.w	fp, r3, r5
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
   15d38:	f1ba 0f00 	cmp.w	sl, #0
   15d3c:	f17b 0300 	sbcs.w	r3, fp, #0
   15d40:	da09      	bge.n	15d56 <z_impl_k_timer_start+0x5e>
		period.ticks = MAX(period.ticks - 1, 1);
   15d42:	f112 34ff 	adds.w	r4, r2, #4294967295
   15d46:	f145 35ff 	adc.w	r5, r5, #4294967295
   15d4a:	2c01      	cmp	r4, #1
   15d4c:	f175 0300 	sbcs.w	r3, r5, #0
   15d50:	bfbc      	itt	lt
   15d52:	2401      	movlt	r4, #1
   15d54:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
   15d56:	f06f 0301 	mvn.w	r3, #1
   15d5a:	1a1b      	subs	r3, r3, r0
   15d5c:	9300      	str	r3, [sp, #0]
   15d5e:	f04f 33ff 	mov.w	r3, #4294967295
   15d62:	eb63 0301 	sbc.w	r3, r3, r1
   15d66:	9301      	str	r3, [sp, #4]
   15d68:	e9dd 2300 	ldrd	r2, r3, [sp]
   15d6c:	2a00      	cmp	r2, #0
   15d6e:	f173 0300 	sbcs.w	r3, r3, #0
   15d72:	da0c      	bge.n	15d8e <z_impl_k_timer_start+0x96>
		duration.ticks = MAX(duration.ticks - 1, 0);
   15d74:	f110 38ff 	adds.w	r8, r0, #4294967295
   15d78:	f141 39ff 	adc.w	r9, r1, #4294967295
   15d7c:	f1b8 0f00 	cmp.w	r8, #0
   15d80:	f179 0300 	sbcs.w	r3, r9, #0
   15d84:	bfbc      	itt	lt
   15d86:	f04f 0800 	movlt.w	r8, #0
   15d8a:	f04f 0900 	movlt.w	r9, #0
	}

	(void)z_abort_timeout(&timer->timeout);
   15d8e:	4630      	mov	r0, r6
   15d90:	f001 f85f 	bl	16e52 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   15d94:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   15d96:	4642      	mov	r2, r8
	timer->status = 0U;
   15d98:	6333      	str	r3, [r6, #48]	; 0x30
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   15d9a:	4630      	mov	r0, r6
   15d9c:	464b      	mov	r3, r9
   15d9e:	4905      	ldr	r1, [pc, #20]	; (15db4 <z_impl_k_timer_start+0xbc>)
	timer->period = period;
   15da0:	e9c6 450a 	strd	r4, r5, [r6, #40]	; 0x28
		     duration);
}
   15da4:	b002      	add	sp, #8
   15da6:	e8bd 4f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   15daa:	f7ff be55 	b.w	15a58 <z_add_timeout>
}
   15dae:	b002      	add	sp, #8
   15db0:	e8bd 8f70 	ldmia.w	sp!, {r4, r5, r6, r8, r9, sl, fp, pc}
   15db4:	00015c71 	.word	0x00015c71

00015db8 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   15db8:	4a02      	ldr	r2, [pc, #8]	; (15dc4 <boot_banner+0xc>)
   15dba:	4903      	ldr	r1, [pc, #12]	; (15dc8 <boot_banner+0x10>)
   15dbc:	4803      	ldr	r0, [pc, #12]	; (15dcc <boot_banner+0x14>)
   15dbe:	f000 b862 	b.w	15e86 <printk>
   15dc2:	bf00      	nop
   15dc4:	0001757d 	.word	0x0001757d
   15dc8:	000175f3 	.word	0x000175f3
   15dcc:	00017602 	.word	0x00017602

00015dd0 <z_impl_gpio_pin_configure>:
{
   15dd0:	b4f0      	push	{r4, r5, r6, r7}
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   15dd2:	04d4      	lsls	r4, r2, #19
{
   15dd4:	4613      	mov	r3, r2
	const struct gpio_driver_api *api =
   15dd6:	6887      	ldr	r7, [r0, #8]
	struct gpio_driver_data *data =
   15dd8:	6906      	ldr	r6, [r0, #16]
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   15dda:	d506      	bpl.n	15dea <z_impl_gpio_pin_configure+0x1a>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   15ddc:	f412 6f40 	tst.w	r2, #3072	; 0xc00
   15de0:	d003      	beq.n	15dea <z_impl_gpio_pin_configure+0x1a>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   15de2:	07da      	lsls	r2, r3, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   15de4:	bf48      	it	mi
   15de6:	f483 6340 	eormi.w	r3, r3, #3072	; 0xc00
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   15dea:	2501      	movs	r5, #1
   15dec:	6834      	ldr	r4, [r6, #0]
   15dee:	408d      	lsls	r5, r1
   15df0:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   15df4:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   15df6:	bf4c      	ite	mi
   15df8:	432c      	orrmi	r4, r5
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   15dfa:	43ac      	bicpl	r4, r5
	return api->pin_configure(port, pin, flags);
   15dfc:	683b      	ldr	r3, [r7, #0]
   15dfe:	6034      	str	r4, [r6, #0]
}
   15e00:	bcf0      	pop	{r4, r5, r6, r7}
	return api->pin_configure(port, pin, flags);
   15e02:	4718      	bx	r3

00015e04 <gpio_pin_get>:
{
   15e04:	b537      	push	{r0, r1, r2, r4, r5, lr}
   15e06:	460c      	mov	r4, r1
	const struct gpio_driver_data *const data =
   15e08:	6905      	ldr	r5, [r0, #16]
	return api->port_get_raw(port, value);
   15e0a:	6883      	ldr	r3, [r0, #8]
   15e0c:	a901      	add	r1, sp, #4
   15e0e:	685b      	ldr	r3, [r3, #4]
   15e10:	4798      	blx	r3
	if (ret == 0) {
   15e12:	b948      	cbnz	r0, 15e28 <gpio_pin_get+0x24>
		*value ^= data->invert;
   15e14:	9b01      	ldr	r3, [sp, #4]
   15e16:	682a      	ldr	r2, [r5, #0]
   15e18:	405a      	eors	r2, r3
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
   15e1a:	2301      	movs	r3, #1
   15e1c:	fa03 f104 	lsl.w	r1, r3, r4
   15e20:	420a      	tst	r2, r1
   15e22:	bf14      	ite	ne
   15e24:	4618      	movne	r0, r3
   15e26:	2000      	moveq	r0, #0
}
   15e28:	b003      	add	sp, #12
   15e2a:	bd30      	pop	{r4, r5, pc}

00015e2c <gpio_pin_interrupt_configure_dt.constprop.0>:
static inline int gpio_pin_interrupt_configure_dt(const struct gpio_dt_spec *spec,
   15e2c:	4603      	mov	r3, r0
   15e2e:	b410      	push	{r4}
	return gpio_pin_interrupt_configure(spec->port, spec->pin, flags);
   15e30:	6800      	ldr	r0, [r0, #0]
   15e32:	7919      	ldrb	r1, [r3, #4]
	return api->pin_interrupt_configure(port, pin, mode, trig);
   15e34:	6883      	ldr	r3, [r0, #8]
   15e36:	f44f 32a0 	mov.w	r2, #81920	; 0x14000
   15e3a:	699c      	ldr	r4, [r3, #24]
   15e3c:	f44f 23c0 	mov.w	r3, #393216	; 0x60000
   15e40:	46a4      	mov	ip, r4
}
   15e42:	bc10      	pop	{r4}
	return api->pin_interrupt_configure(port, pin, mode, trig);
   15e44:	4760      	bx	ip

00015e46 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   15e46:	4603      	mov	r3, r0
   15e48:	b158      	cbz	r0, 15e62 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   15e4a:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   15e4c:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   15e50:	2a01      	cmp	r2, #1
   15e52:	d003      	beq.n	15e5c <sys_notify_validate+0x16>
   15e54:	2a03      	cmp	r2, #3
   15e56:	d104      	bne.n	15e62 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   15e58:	6802      	ldr	r2, [r0, #0]
   15e5a:	b112      	cbz	r2, 15e62 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   15e5c:	2000      	movs	r0, #0
   15e5e:	6098      	str	r0, [r3, #8]
   15e60:	4770      	bx	lr
		return -EINVAL;
   15e62:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   15e66:	4770      	bx	lr

00015e68 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   15e68:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   15e6a:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   15e6c:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   15e70:	2a03      	cmp	r2, #3
   15e72:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   15e76:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   15e78:	bf14      	ite	ne
   15e7a:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   15e7c:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   15e7e:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   15e80:	4770      	bx	lr

00015e82 <arch_printk_char_out>:
}
   15e82:	2000      	movs	r0, #0
   15e84:	4770      	bx	lr

00015e86 <printk>:
 *
 * @return N/A
 */

void printk(const char *fmt, ...)
{
   15e86:	b40f      	push	{r0, r1, r2, r3}
   15e88:	b507      	push	{r0, r1, r2, lr}
   15e8a:	a904      	add	r1, sp, #16
   15e8c:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   15e90:	9101      	str	r1, [sp, #4]

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
   15e92:	f7fa fd29 	bl	108e8 <vprintk>
	}
	va_end(ap);
}
   15e96:	b003      	add	sp, #12
   15e98:	f85d eb04 	ldr.w	lr, [sp], #4
   15e9c:	b004      	add	sp, #16
   15e9e:	4770      	bx	lr

00015ea0 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   15ea0:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   15ea2:	f013 0307 	ands.w	r3, r3, #7
   15ea6:	d105      	bne.n	15eb4 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   15ea8:	6803      	ldr	r3, [r0, #0]
   15eaa:	2b00      	cmp	r3, #0
		evt = EVT_START;
   15eac:	bf0c      	ite	eq
   15eae:	2000      	moveq	r0, #0
   15eb0:	2003      	movne	r0, #3
   15eb2:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   15eb4:	2b02      	cmp	r3, #2
   15eb6:	d105      	bne.n	15ec4 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   15eb8:	8b43      	ldrh	r3, [r0, #26]
   15eba:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   15ebc:	bf14      	ite	ne
   15ebe:	2000      	movne	r0, #0
   15ec0:	2004      	moveq	r0, #4
   15ec2:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   15ec4:	2b01      	cmp	r3, #1
   15ec6:	d105      	bne.n	15ed4 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   15ec8:	6803      	ldr	r3, [r0, #0]
   15eca:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   15ecc:	bf0c      	ite	eq
   15ece:	2000      	moveq	r0, #0
   15ed0:	2005      	movne	r0, #5
   15ed2:	4770      	bx	lr
	int evt = EVT_NOP;
   15ed4:	2000      	movs	r0, #0
}
   15ed6:	4770      	bx	lr

00015ed8 <notify_one>:
{
   15ed8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15edc:	460d      	mov	r5, r1
   15ede:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   15ee0:	4619      	mov	r1, r3
   15ee2:	1d28      	adds	r0, r5, #4
{
   15ee4:	4690      	mov	r8, r2
   15ee6:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   15ee8:	f7ff ffbe 	bl	15e68 <sys_notify_finalize>
	if (cb) {
   15eec:	4604      	mov	r4, r0
   15eee:	b138      	cbz	r0, 15f00 <notify_one+0x28>
		cb(mgr, cli, state, res);
   15ef0:	4633      	mov	r3, r6
   15ef2:	4642      	mov	r2, r8
   15ef4:	4629      	mov	r1, r5
   15ef6:	4638      	mov	r0, r7
   15ef8:	46a4      	mov	ip, r4
}
   15efa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   15efe:	4760      	bx	ip
}
   15f00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00015f04 <transition_complete>:
{
   15f04:	b410      	push	{r4}
	__asm__ volatile(
   15f06:	f04f 0420 	mov.w	r4, #32
   15f0a:	f3ef 8211 	mrs	r2, BASEPRI
   15f0e:	f384 8812 	msr	BASEPRI_MAX, r4
   15f12:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   15f16:	6141      	str	r1, [r0, #20]
}
   15f18:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   15f1a:	2101      	movs	r1, #1
   15f1c:	f7fa bcf2 	b.w	10904 <process_event>

00015f20 <validate_args>:
{
   15f20:	b510      	push	{r4, lr}
   15f22:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   15f24:	b140      	cbz	r0, 15f38 <validate_args+0x18>
   15f26:	b139      	cbz	r1, 15f38 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   15f28:	1d08      	adds	r0, r1, #4
   15f2a:	f7ff ff8c 	bl	15e46 <sys_notify_validate>
	if ((rv == 0)
   15f2e:	b928      	cbnz	r0, 15f3c <validate_args+0x1c>
	    && ((cli->notify.flags
   15f30:	68a3      	ldr	r3, [r4, #8]
   15f32:	f033 0303 	bics.w	r3, r3, #3
   15f36:	d001      	beq.n	15f3c <validate_args+0x1c>
		rv = -EINVAL;
   15f38:	f06f 0015 	mvn.w	r0, #21
}
   15f3c:	bd10      	pop	{r4, pc}

00015f3e <onoff_manager_init>:
{
   15f3e:	b538      	push	{r3, r4, r5, lr}
   15f40:	460c      	mov	r4, r1
	if ((mgr == NULL)
   15f42:	4605      	mov	r5, r0
   15f44:	b158      	cbz	r0, 15f5e <onoff_manager_init+0x20>
	    || (transitions == NULL)
   15f46:	b151      	cbz	r1, 15f5e <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   15f48:	680b      	ldr	r3, [r1, #0]
   15f4a:	b143      	cbz	r3, 15f5e <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   15f4c:	684b      	ldr	r3, [r1, #4]
   15f4e:	b133      	cbz	r3, 15f5e <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   15f50:	221c      	movs	r2, #28
   15f52:	2100      	movs	r1, #0
   15f54:	f000 fb23 	bl	1659e <memset>
	return 0;
   15f58:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   15f5a:	612c      	str	r4, [r5, #16]
}
   15f5c:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   15f5e:	f06f 0015 	mvn.w	r0, #21
   15f62:	e7fb      	b.n	15f5c <onoff_manager_init+0x1e>

00015f64 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   15f64:	b570      	push	{r4, r5, r6, lr}
   15f66:	4604      	mov	r4, r0
   15f68:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   15f6a:	f7ff ffd9 	bl	15f20 <validate_args>

	if (rv < 0) {
   15f6e:	1e05      	subs	r5, r0, #0
   15f70:	db31      	blt.n	15fd6 <onoff_request+0x72>
   15f72:	f04f 0320 	mov.w	r3, #32
   15f76:	f3ef 8111 	mrs	r1, BASEPRI
   15f7a:	f383 8812 	msr	BASEPRI_MAX, r3
   15f7e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   15f82:	f64f 75ff 	movw	r5, #65535	; 0xffff
   15f86:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   15f88:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   15f8a:	42ab      	cmp	r3, r5
   15f8c:	f000 0207 	and.w	r2, r0, #7
   15f90:	d02e      	beq.n	15ff0 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   15f92:	2a02      	cmp	r2, #2
   15f94:	d10e      	bne.n	15fb4 <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   15f96:	3301      	adds	r3, #1
   15f98:	8363      	strh	r3, [r4, #26]
	rv = state;
   15f9a:	4615      	mov	r5, r2
		notify = true;
   15f9c:	2301      	movs	r3, #1
	__asm__ volatile(
   15f9e:	f381 8811 	msr	BASEPRI, r1
   15fa2:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   15fa6:	b1b3      	cbz	r3, 15fd6 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   15fa8:	2300      	movs	r3, #0
   15faa:	4631      	mov	r1, r6
   15fac:	4620      	mov	r0, r4
   15fae:	f7ff ff93 	bl	15ed8 <notify_one>
   15fb2:	e010      	b.n	15fd6 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   15fb4:	0783      	lsls	r3, r0, #30
   15fb6:	d001      	beq.n	15fbc <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   15fb8:	2a06      	cmp	r2, #6
   15fba:	d10e      	bne.n	15fda <onoff_request+0x76>
	parent->next = child;
   15fbc:	2300      	movs	r3, #0
   15fbe:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   15fc0:	6863      	ldr	r3, [r4, #4]
   15fc2:	b993      	cbnz	r3, 15fea <onoff_request+0x86>
	list->head = node;
   15fc4:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   15fc8:	4615      	mov	r5, r2
   15fca:	b962      	cbnz	r2, 15fe6 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   15fcc:	460a      	mov	r2, r1
   15fce:	4620      	mov	r0, r4
   15fd0:	2102      	movs	r1, #2
   15fd2:	f7fa fc97 	bl	10904 <process_event>
		}
	}

	return rv;
}
   15fd6:	4628      	mov	r0, r5
   15fd8:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   15fda:	2a05      	cmp	r2, #5
   15fdc:	bf0c      	ite	eq
   15fde:	f06f 0585 	mvneq.w	r5, #133	; 0x85
   15fe2:	f06f 0504 	mvnne.w	r5, #4
   15fe6:	2300      	movs	r3, #0
   15fe8:	e7d9      	b.n	15f9e <onoff_request+0x3a>
	parent->next = child;
   15fea:	601e      	str	r6, [r3, #0]
	list->tail = node;
   15fec:	6066      	str	r6, [r4, #4]
}
   15fee:	e7eb      	b.n	15fc8 <onoff_request+0x64>
		rv = -EAGAIN;
   15ff0:	f06f 050a 	mvn.w	r5, #10
   15ff4:	e7f7      	b.n	15fe6 <onoff_request+0x82>

00015ff6 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   15ff6:	4604      	mov	r4, r0
   15ff8:	b508      	push	{r3, lr}
   15ffa:	4608      	mov	r0, r1
   15ffc:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   15ffe:	461a      	mov	r2, r3
   16000:	47a0      	blx	r4
	return z_impl_z_current_get();
   16002:	f7ff fc67 	bl	158d4 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   16006:	f7fb fcbb 	bl	11980 <z_impl_k_thread_abort>

0001600a <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   1600a:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   1600e:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   16010:	0840      	lsrs	r0, r0, #1
   16012:	4770      	bx	lr

00016014 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   16014:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16016:	4603      	mov	r3, r0
   16018:	460c      	mov	r4, r1
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   1601a:	f7ff fff6 	bl	1600a <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   1601e:	fab0 f080 	clz	r0, r0
   16022:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   16026:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   1602a:	f8dc 6010 	ldr.w	r6, [ip, #16]
   1602e:	00ca      	lsls	r2, r1, #3
   16030:	1d17      	adds	r7, r2, #4
   16032:	b28d      	uxth	r5, r1
   16034:	3206      	adds	r2, #6
   16036:	b956      	cbnz	r6, 1604e <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   16038:	2101      	movs	r1, #1
   1603a:	fa01 f000 	lsl.w	r0, r1, r0
   1603e:	68d9      	ldr	r1, [r3, #12]
   16040:	4301      	orrs	r1, r0
   16042:	60d9      	str	r1, [r3, #12]
		b->next = c;
   16044:	f8cc 4010 	str.w	r4, [ip, #16]
		((uint16_t *)cmem)[f] = val;
   16048:	53dd      	strh	r5, [r3, r7]
   1604a:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   1604c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   1604e:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   16050:	3104      	adds	r1, #4
   16052:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   16054:	53d8      	strh	r0, [r3, r7]
   16056:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   1605a:	529e      	strh	r6, [r3, r2]
   1605c:	80c5      	strh	r5, [r0, #6]
   1605e:	525d      	strh	r5, [r3, r1]
   16060:	e7f4      	b.n	1604c <free_list_add+0x38>

00016062 <free_list_remove_bidx>:
{
   16062:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   16064:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   16068:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   1606a:	4299      	cmp	r1, r3
   1606c:	f102 0104 	add.w	r1, r2, #4
   16070:	d10a      	bne.n	16088 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   16072:	2301      	movs	r3, #1
   16074:	fa03 f202 	lsl.w	r2, r3, r2
   16078:	68c3      	ldr	r3, [r0, #12]
   1607a:	ea23 0302 	bic.w	r3, r3, r2
   1607e:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   16080:	2300      	movs	r3, #0
   16082:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   16086:	bd10      	pop	{r4, pc}
   16088:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   1608a:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   1608e:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   16092:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   16096:	80cb      	strh	r3, [r1, #6]
   16098:	8082      	strh	r2, [r0, #4]
}
   1609a:	e7f4      	b.n	16086 <free_list_remove_bidx+0x24>

0001609c <free_list_remove>:
{
   1609c:	b510      	push	{r4, lr}
   1609e:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   160a0:	f7ff ffb3 	bl	1600a <chunk_size>
}
   160a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return 31 - __builtin_clz(usable_sz);
   160a8:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   160ac:	4618      	mov	r0, r3
   160ae:	f1c2 021f 	rsb	r2, r2, #31
   160b2:	f7ff bfd6 	b.w	16062 <free_list_remove_bidx>

000160b6 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   160b6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   160ba:	fab1 f581 	clz	r5, r1
   160be:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   160c2:	eb00 0789 	add.w	r7, r0, r9, lsl #2
   160c6:	693a      	ldr	r2, [r7, #16]
{
   160c8:	4603      	mov	r3, r0
   160ca:	460e      	mov	r6, r1
	if (b->next) {
   160cc:	b1ca      	cbz	r2, 16102 <alloc_chunk+0x4c>
   160ce:	f04f 0803 	mov.w	r8, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   160d2:	693c      	ldr	r4, [r7, #16]
			if (chunk_size(h, c) >= sz) {
   160d4:	4618      	mov	r0, r3
   160d6:	4621      	mov	r1, r4
   160d8:	f7ff ff97 	bl	1600a <chunk_size>
   160dc:	42b0      	cmp	r0, r6
   160de:	d307      	bcc.n	160f0 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   160e0:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   160e2:	4621      	mov	r1, r4
   160e4:	4618      	mov	r0, r3
   160e6:	f7ff ffbc 	bl	16062 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   160ea:	4620      	mov	r0, r4
   160ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   160f0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   160f4:	88e1      	ldrh	r1, [r4, #6]
		} while (--i && b->next != first);
   160f6:	f1b8 0801 	subs.w	r8, r8, #1
			b->next = next_free_chunk(h, c);
   160fa:	6139      	str	r1, [r7, #16]
		} while (--i && b->next != first);
   160fc:	d001      	beq.n	16102 <alloc_chunk+0x4c>
   160fe:	428a      	cmp	r2, r1
   16100:	d1e7      	bne.n	160d2 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   16102:	f04f 34ff 	mov.w	r4, #4294967295
   16106:	68d9      	ldr	r1, [r3, #12]
   16108:	f1c5 0520 	rsb	r5, r5, #32
   1610c:	40ac      	lsls	r4, r5
	if (bmask != 0U) {
   1610e:	400c      	ands	r4, r1
   16110:	d0eb      	beq.n	160ea <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   16112:	fa94 f2a4 	rbit	r2, r4
   16116:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   1611a:	1d11      	adds	r1, r2, #4
   1611c:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
   16120:	e7df      	b.n	160e2 <alloc_chunk+0x2c>

00016122 <merge_chunks>:
{
   16122:	b538      	push	{r3, r4, r5, lr}
   16124:	4603      	mov	r3, r0
   16126:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   16128:	f7ff ff6f 	bl	1600a <chunk_size>
   1612c:	4611      	mov	r1, r2
   1612e:	4604      	mov	r4, r0
   16130:	4618      	mov	r0, r3
   16132:	f7ff ff6a 	bl	1600a <chunk_size>
   16136:	4404      	add	r4, r0
		((uint16_t *)cmem)[f] = val;
   16138:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   1613c:	0061      	lsls	r1, r4, #1
		((uint16_t *)cmem)[f] = val;
   1613e:	8069      	strh	r1, [r5, #2]
	return c + chunk_size(h, c);
   16140:	4618      	mov	r0, r3
   16142:	4611      	mov	r1, r2
   16144:	f7ff ff61 	bl	1600a <chunk_size>
	void *cmem = &buf[c];
   16148:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   1614a:	f823 4032 	strh.w	r4, [r3, r2, lsl #3]
}
   1614e:	bd38      	pop	{r3, r4, r5, pc}

00016150 <split_chunks>:
{
   16150:	b538      	push	{r3, r4, r5, lr}
   16152:	4603      	mov	r3, r0
   16154:	460c      	mov	r4, r1
	chunksz_t sz0 = chunk_size(h, lc);
   16156:	f7ff ff58 	bl	1600a <chunk_size>
	chunksz_t lsz = rc - lc;
   1615a:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   1615c:	1aa5      	subs	r5, r4, r2
   1615e:	4405      	add	r5, r0
   16160:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   16164:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   16166:	8060      	strh	r0, [r4, #2]
   16168:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   1616c:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   1616e:	8044      	strh	r4, [r0, #2]
   16170:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   16174:	4618      	mov	r0, r3
   16176:	4611      	mov	r1, r2
   16178:	f7ff ff47 	bl	1600a <chunk_size>
	void *cmem = &buf[c];
   1617c:	4402      	add	r2, r0
		((uint16_t *)cmem)[f] = val;
   1617e:	f823 5032 	strh.w	r5, [r3, r2, lsl #3]
}
   16182:	bd38      	pop	{r3, r4, r5, pc}

00016184 <free_chunk>:
{
   16184:	b538      	push	{r3, r4, r5, lr}
   16186:	4605      	mov	r5, r0
   16188:	460c      	mov	r4, r1
	return c + chunk_size(h, c);
   1618a:	f7ff ff3e 	bl	1600a <chunk_size>
   1618e:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   16190:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   16194:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   16196:	07da      	lsls	r2, r3, #31
   16198:	d40a      	bmi.n	161b0 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   1619a:	4628      	mov	r0, r5
   1619c:	f7ff ff7e 	bl	1609c <free_list_remove>
	return c + chunk_size(h, c);
   161a0:	4621      	mov	r1, r4
   161a2:	4628      	mov	r0, r5
   161a4:	f7ff ff31 	bl	1600a <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   161a8:	1822      	adds	r2, r4, r0
   161aa:	4628      	mov	r0, r5
   161ac:	f7ff ffb9 	bl	16122 <merge_chunks>
		return ((uint16_t *)cmem)[f];
   161b0:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   161b4:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   161b6:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   161ba:	789b      	ldrb	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   161bc:	07db      	lsls	r3, r3, #31
   161be:	d40c      	bmi.n	161da <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   161c0:	4628      	mov	r0, r5
   161c2:	f7ff ff6b 	bl	1609c <free_list_remove>
		return ((uint16_t *)cmem)[f];
   161c6:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   161ca:	4622      	mov	r2, r4
   161cc:	1a61      	subs	r1, r4, r1
   161ce:	4628      	mov	r0, r5
   161d0:	f7ff ffa7 	bl	16122 <merge_chunks>
   161d4:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   161d8:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   161da:	4621      	mov	r1, r4
   161dc:	4628      	mov	r0, r5
}
   161de:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   161e2:	f7ff bf17 	b.w	16014 <free_list_add>

000161e6 <sys_heap_free>:
	if (mem == NULL) {
   161e6:	b161      	cbz	r1, 16202 <sys_heap_free+0x1c>
	struct z_heap *h = heap->heap;
   161e8:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   161ea:	3904      	subs	r1, #4
   161ec:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   161ee:	f021 0307 	bic.w	r3, r1, #7
   161f2:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   161f4:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   161f6:	08c9      	lsrs	r1, r1, #3
   161f8:	f022 0201 	bic.w	r2, r2, #1
   161fc:	805a      	strh	r2, [r3, #2]
   161fe:	f7ff bfc1 	b.w	16184 <free_chunk>
}
   16202:	4770      	bx	lr

00016204 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   16204:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   16206:	6805      	ldr	r5, [r0, #0]

	if (bytes == 0U || size_too_big(h, bytes)) {
   16208:	b909      	cbnz	r1, 1620e <sys_heap_alloc+0xa>
		return NULL;
   1620a:	2000      	movs	r0, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return chunk_mem(h, c);
}
   1620c:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   1620e:	68ab      	ldr	r3, [r5, #8]
   16210:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   16214:	d9f9      	bls.n	1620a <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   16216:	310b      	adds	r1, #11
   16218:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   1621a:	4621      	mov	r1, r4
   1621c:	4628      	mov	r0, r5
   1621e:	f7ff ff4a 	bl	160b6 <alloc_chunk>
	if (c == 0U) {
   16222:	4606      	mov	r6, r0
   16224:	2800      	cmp	r0, #0
   16226:	d0f0      	beq.n	1620a <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   16228:	4601      	mov	r1, r0
   1622a:	4628      	mov	r0, r5
   1622c:	f7ff feed 	bl	1600a <chunk_size>
   16230:	42a0      	cmp	r0, r4
   16232:	d908      	bls.n	16246 <sys_heap_alloc+0x42>
		split_chunks(h, c, c + chunk_sz);
   16234:	4434      	add	r4, r6
   16236:	4628      	mov	r0, r5
   16238:	4622      	mov	r2, r4
   1623a:	f7ff ff89 	bl	16150 <split_chunks>
		free_list_add(h, c + chunk_sz);
   1623e:	4621      	mov	r1, r4
   16240:	4628      	mov	r0, r5
   16242:	f7ff fee7 	bl	16014 <free_list_add>
	void *cmem = &buf[c];
   16246:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   1624a:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   1624c:	8853      	ldrh	r3, [r2, #2]
   1624e:	3004      	adds	r0, #4
   16250:	f043 0301 	orr.w	r3, r3, #1
   16254:	8053      	strh	r3, [r2, #2]
	return chunk_mem(h, c);
   16256:	e7d9      	b.n	1620c <sys_heap_alloc+0x8>

00016258 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   16258:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1625c:	4614      	mov	r4, r2
	 * We allow for one bit of rewind in addition to the alignment
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
   1625e:	424a      	negs	r2, r1
   16260:	ea02 0701 	and.w	r7, r2, r1
	if (align != rew) {
   16264:	ea31 0202 	bics.w	r2, r1, r2
{
   16268:	4603      	mov	r3, r0
	if (align != rew) {
   1626a:	d00a      	beq.n	16282 <sys_heap_aligned_alloc+0x2a>
		return false;
   1626c:	2f04      	cmp	r7, #4
   1626e:	463a      	mov	r2, r7
   16270:	bf28      	it	cs
   16272:	2204      	movcs	r2, #4
   16274:	46b9      	mov	r9, r7
		align -= rew;
   16276:	1bcf      	subs	r7, r1, r7
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   16278:	b974      	cbnz	r4, 16298 <sys_heap_aligned_alloc+0x40>
		return NULL;
   1627a:	2500      	movs	r5, #0
	set_chunk_used(h, c, true);
#ifdef CONFIG_SYS_HEAP_RUNTIME_STATS
	h->allocated_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
	return mem;
}
   1627c:	4628      	mov	r0, r5
   1627e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   16282:	2904      	cmp	r1, #4
   16284:	d804      	bhi.n	16290 <sys_heap_aligned_alloc+0x38>
			return sys_heap_alloc(heap, bytes);
   16286:	4621      	mov	r1, r4
}
   16288:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   1628c:	f7ff bfba 	b.w	16204 <sys_heap_alloc>
		rew = 0;
   16290:	f04f 0900 	mov.w	r9, #0
		gap = chunk_header_bytes(h);
   16294:	2204      	movs	r2, #4
   16296:	e7ef      	b.n	16278 <sys_heap_aligned_alloc+0x20>
	struct z_heap *h = heap->heap;
   16298:	681e      	ldr	r6, [r3, #0]
	if (bytes == 0 || size_too_big(h, bytes)) {
   1629a:	68b3      	ldr	r3, [r6, #8]
   1629c:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   162a0:	d9eb      	bls.n	1627a <sys_heap_aligned_alloc+0x22>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   162a2:	f104 010b 	add.w	r1, r4, #11
   162a6:	4439      	add	r1, r7
   162a8:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   162aa:	4630      	mov	r0, r6
   162ac:	08c9      	lsrs	r1, r1, #3
   162ae:	f7ff ff02 	bl	160b6 <alloc_chunk>
	if (c0 == 0) {
   162b2:	4680      	mov	r8, r0
   162b4:	2800      	cmp	r0, #0
   162b6:	d0e0      	beq.n	1627a <sys_heap_aligned_alloc+0x22>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   162b8:	f109 0504 	add.w	r5, r9, #4
   162bc:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   162c0:	1e7b      	subs	r3, r7, #1
   162c2:	4435      	add	r5, r6
   162c4:	441d      	add	r5, r3
   162c6:	427f      	negs	r7, r7
   162c8:	403d      	ands	r5, r7
   162ca:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   162ce:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   162d0:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   162d2:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   162d4:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   162d6:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   162da:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   162dc:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   162e0:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   162e4:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   162e8:	d208      	bcs.n	162fc <sys_heap_aligned_alloc+0xa4>
		split_chunks(h, c0, c);
   162ea:	4601      	mov	r1, r0
   162ec:	463a      	mov	r2, r7
   162ee:	4630      	mov	r0, r6
   162f0:	f7ff ff2e 	bl	16150 <split_chunks>
		free_list_add(h, c0);
   162f4:	4641      	mov	r1, r8
   162f6:	4630      	mov	r0, r6
   162f8:	f7ff fe8c 	bl	16014 <free_list_add>
	return c + chunk_size(h, c);
   162fc:	4639      	mov	r1, r7
   162fe:	4630      	mov	r0, r6
   16300:	f7ff fe83 	bl	1600a <chunk_size>
   16304:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   16306:	4284      	cmp	r4, r0
   16308:	d207      	bcs.n	1631a <sys_heap_aligned_alloc+0xc2>
		split_chunks(h, c, c_end);
   1630a:	4630      	mov	r0, r6
   1630c:	4622      	mov	r2, r4
   1630e:	f7ff ff1f 	bl	16150 <split_chunks>
		free_list_add(h, c_end);
   16312:	4621      	mov	r1, r4
   16314:	4630      	mov	r0, r6
   16316:	f7ff fe7d 	bl	16014 <free_list_add>
	void *cmem = &buf[c];
   1631a:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   1631e:	8873      	ldrh	r3, [r6, #2]
   16320:	f043 0301 	orr.w	r3, r3, #1
   16324:	8073      	strh	r3, [r6, #2]
   16326:	e7a9      	b.n	1627c <sys_heap_aligned_alloc+0x24>

00016328 <sys_heap_init>:
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   16328:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   1632a:	1dcb      	adds	r3, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   1632c:	440a      	add	r2, r1
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   1632e:	f023 0307 	bic.w	r3, r3, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   16332:	f022 0207 	bic.w	r2, r2, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   16336:	1ad2      	subs	r2, r2, r3
{
   16338:	b4f0      	push	{r4, r5, r6, r7}
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   1633a:	08d4      	lsrs	r4, r2, #3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   1633c:	6003      	str	r3, [r0, #0]
	return 31 - __builtin_clz(usable_sz);
   1633e:	fab4 f084 	clz	r0, r4
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   16342:	2500      	movs	r5, #0
	h->free_bytes = 0;
	h->allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   16344:	f1c0 0024 	rsb	r0, r0, #36	; 0x24
   16348:	0080      	lsls	r0, r0, #2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   1634a:	1dc1      	adds	r1, r0, #7
	h->end_chunk = heap_sz;
   1634c:	609c      	str	r4, [r3, #8]
	h->avail_buckets = 0;
   1634e:	60dd      	str	r5, [r3, #12]
   16350:	08c9      	lsrs	r1, r1, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   16352:	f103 0610 	add.w	r6, r3, #16
   16356:	4418      	add	r0, r3
   16358:	4286      	cmp	r6, r0
   1635a:	d118      	bne.n	1638e <sys_heap_init+0x66>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   1635c:	0048      	lsls	r0, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   1635e:	f040 0001 	orr.w	r0, r0, #1
   16362:	8058      	strh	r0, [r3, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   16364:	1a60      	subs	r0, r4, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   16366:	0047      	lsls	r7, r0, #1
		((uint16_t *)cmem)[f] = val;
   16368:	eb03 06c1 	add.w	r6, r3, r1, lsl #3
   1636c:	801d      	strh	r5, [r3, #0]
   1636e:	8077      	strh	r7, [r6, #2]
   16370:	189e      	adds	r6, r3, r2
   16372:	f823 1031 	strh.w	r1, [r3, r1, lsl #3]
	void *cmem = &buf[c];
   16376:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		((uint16_t *)cmem)[f] = val;
   1637a:	8075      	strh	r5, [r6, #2]
   1637c:	5298      	strh	r0, [r3, r2]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   1637e:	8862      	ldrh	r2, [r4, #2]
	/* the end marker chunk */
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
   16380:	4618      	mov	r0, r3
   16382:	f042 0201 	orr.w	r2, r2, #1
   16386:	8062      	strh	r2, [r4, #2]
}
   16388:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   1638a:	f7ff be43 	b.w	16014 <free_list_add>
		h->buckets[i].next = 0;
   1638e:	f846 5b04 	str.w	r5, [r6], #4
	for (int i = 0; i < nb_buckets; i++) {
   16392:	e7e1      	b.n	16358 <sys_heap_init+0x30>

00016394 <encode_uint>:
{
   16394:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16398:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
   1639a:	78d3      	ldrb	r3, [r2, #3]
{
   1639c:	4614      	mov	r4, r2
	switch (specifier) {
   1639e:	2b6f      	cmp	r3, #111	; 0x6f
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   163a0:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
{
   163a4:	4606      	mov	r6, r0
   163a6:	460f      	mov	r7, r1
   163a8:	9201      	str	r2, [sp, #4]
	switch (specifier) {
   163aa:	d02d      	beq.n	16408 <encode_uint+0x74>
   163ac:	d828      	bhi.n	16400 <encode_uint+0x6c>
		return 16;
   163ae:	2b58      	cmp	r3, #88	; 0x58
   163b0:	bf14      	ite	ne
   163b2:	250a      	movne	r5, #10
   163b4:	2510      	moveq	r5, #16
		unsigned int lsv = (unsigned int)(value % radix);
   163b6:	46aa      	mov	sl, r5
   163b8:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
   163bc:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
   163c0:	4652      	mov	r2, sl
   163c2:	465b      	mov	r3, fp
   163c4:	4630      	mov	r0, r6
   163c6:	4639      	mov	r1, r7
   163c8:	f7f9 ff38 	bl	1023c <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   163cc:	2a09      	cmp	r2, #9
   163ce:	b2d3      	uxtb	r3, r2
   163d0:	d81f      	bhi.n	16412 <encode_uint+0x7e>
   163d2:	3330      	adds	r3, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   163d4:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
   163d6:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
   163d8:	bf08      	it	eq
   163da:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
   163dc:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
   163e0:	d301      	bcc.n	163e6 <encode_uint+0x52>
   163e2:	45c8      	cmp	r8, r9
   163e4:	d812      	bhi.n	1640c <encode_uint+0x78>
	if (conv->flag_hash) {
   163e6:	7823      	ldrb	r3, [r4, #0]
   163e8:	069b      	lsls	r3, r3, #26
   163ea:	d505      	bpl.n	163f8 <encode_uint+0x64>
		if (radix == 8) {
   163ec:	2d08      	cmp	r5, #8
   163ee:	d116      	bne.n	1641e <encode_uint+0x8a>
			conv->altform_0 = true;
   163f0:	78a3      	ldrb	r3, [r4, #2]
   163f2:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   163f6:	70a3      	strb	r3, [r4, #2]
}
   163f8:	4640      	mov	r0, r8
   163fa:	b003      	add	sp, #12
   163fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   16400:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   16404:	2b70      	cmp	r3, #112	; 0x70
   16406:	e7d3      	b.n	163b0 <encode_uint+0x1c>
	switch (specifier) {
   16408:	2508      	movs	r5, #8
   1640a:	e7d4      	b.n	163b6 <encode_uint+0x22>
		value /= radix;
   1640c:	4606      	mov	r6, r0
   1640e:	460f      	mov	r7, r1
   16410:	e7d6      	b.n	163c0 <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   16412:	9a01      	ldr	r2, [sp, #4]
   16414:	2a19      	cmp	r2, #25
   16416:	bf94      	ite	ls
   16418:	3337      	addls	r3, #55	; 0x37
   1641a:	3357      	addhi	r3, #87	; 0x57
   1641c:	e7da      	b.n	163d4 <encode_uint+0x40>
		} else if (radix == 16) {
   1641e:	2d10      	cmp	r5, #16
   16420:	d1ea      	bne.n	163f8 <encode_uint+0x64>
			conv->altform_0c = true;
   16422:	78a3      	ldrb	r3, [r4, #2]
   16424:	f043 0310 	orr.w	r3, r3, #16
   16428:	e7e5      	b.n	163f6 <encode_uint+0x62>

0001642a <outs>:
{
   1642a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1642e:	4607      	mov	r7, r0
   16430:	4688      	mov	r8, r1
   16432:	4615      	mov	r5, r2
   16434:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   16436:	4614      	mov	r4, r2
   16438:	42b4      	cmp	r4, r6
   1643a:	eba4 0005 	sub.w	r0, r4, r5
   1643e:	d302      	bcc.n	16446 <outs+0x1c>
   16440:	b93e      	cbnz	r6, 16452 <outs+0x28>
   16442:	7823      	ldrb	r3, [r4, #0]
   16444:	b12b      	cbz	r3, 16452 <outs+0x28>
		int rc = out((int)*sp++, ctx);
   16446:	4641      	mov	r1, r8
   16448:	f814 0b01 	ldrb.w	r0, [r4], #1
   1644c:	47b8      	blx	r7
		if (rc < 0) {
   1644e:	2800      	cmp	r0, #0
   16450:	daf2      	bge.n	16438 <outs+0xe>
}
   16452:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00016456 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   16456:	4770      	bx	lr

00016458 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
   16458:	b084      	sub	sp, #16
   1645a:	ab04      	add	r3, sp, #16
   1645c:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
   16460:	f89d 3004 	ldrb.w	r3, [sp, #4]
   16464:	2b06      	cmp	r3, #6
   16466:	d108      	bne.n	1647a <pm_power_state_set+0x22>
#endif
}

NRF_STATIC_INLINE void nrf_regulators_system_off(NRF_REGULATORS_Type * p_reg)
{
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   16468:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   1646c:	2201      	movs	r2, #1
   1646e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   16472:	f3bf 8f4f 	dsb	sy
    __DSB();

    /* Solution for simulated System OFF in debug mode */
    while (true)
    {
        __WFE();
   16476:	bf20      	wfe
    while (true)
   16478:	e7fd      	b.n	16476 <pm_power_state_set+0x1e>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
   1647a:	b004      	add	sp, #16
   1647c:	4770      	bx	lr

0001647e <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
   1647e:	b084      	sub	sp, #16
   16480:	ab04      	add	r3, sp, #16
   16482:	e903 0007 	stmdb	r3, {r0, r1, r2}
   16486:	2300      	movs	r3, #0
   16488:	f383 8811 	msr	BASEPRI, r3
   1648c:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   16490:	b004      	add	sp, #16
   16492:	4770      	bx	lr

00016494 <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
   16494:	2200      	movs	r2, #0
   16496:	e9c0 2200 	strd	r2, r2, [r0]
   1649a:	6082      	str	r2, [r0, #8]
}
   1649c:	4770      	bx	lr

0001649e <spm_request_random_number>:
	spm_request_system_reboot();
}
#endif /* CONFIG_SPM_SERVICE_REBOOT */

#ifdef CONFIG_SPM_SERVICE_RNG
NRF_NSE(int, spm_request_random_number, uint8_t *output, size_t len,
   1649e:	b510      	push	{r4, lr}
   164a0:	b40f      	push	{r0, r1, r2, r3}
   164a2:	f7fa fff5 	bl	11490 <before_nse>
   164a6:	bc0f      	pop	{r0, r1, r2, r3}
   164a8:	f7f9 fd9e 	bl	ffe8 <spm_request_random_number_nse>
   164ac:	b40f      	push	{r0, r1, r2, r3}
   164ae:	f7fa fff9 	bl	114a4 <after_nse>
   164b2:	bc0f      	pop	{r0, r1, r2, r3}
   164b4:	bd10      	pop	{r4, pc}

000164b6 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   164b6:	f000 bb29 	b.w	16b0c <z_fatal_error>

000164ba <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   164ba:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   164bc:	6800      	ldr	r0, [r0, #0]
   164be:	f000 bb25 	b.w	16b0c <z_fatal_error>

000164c2 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   164c2:	2100      	movs	r1, #0
   164c4:	2001      	movs	r0, #1
   164c6:	f7ff bff6 	b.w	164b6 <z_arm_fatal_error>

000164ca <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   164ca:	b508      	push	{r3, lr}
	handler();
   164cc:	f7fb f854 	bl	11578 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   164d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   164d4:	f7fb b91e 	b.w	11714 <z_arm_exc_exit>

000164d8 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   164d8:	6e43      	ldr	r3, [r0, #100]	; 0x64
   164da:	f383 880b 	msr	PSPLIM, r3
}
   164de:	4770      	bx	lr

000164e0 <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   164e0:	4770      	bx	lr

000164e2 <z_arm_restore_fp_context>:
   164e2:	4770      	bx	lr

000164e4 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   164e4:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   164e8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   164ec:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   164ee:	bf08      	it	eq
   164f0:	f06f 0015 	mvneq.w	r0, #21
   164f4:	4770      	bx	lr

000164f6 <mpu_configure_region>:
{
   164f6:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p_attr->rbar = attr->rbar &
   164f8:	890a      	ldrh	r2, [r1, #8]
   164fa:	7a8e      	ldrb	r6, [r1, #10]
	region_conf.base = new_region->start;
   164fc:	680b      	ldr	r3, [r1, #0]
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   164fe:	684d      	ldr	r5, [r1, #4]
   16500:	f002 021f 	and.w	r2, r2, #31
   16504:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
	region_conf.base = new_region->start;
   16508:	9300      	str	r3, [sp, #0]
   1650a:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   1650e:	f023 031f 	bic.w	r3, r3, #31
   16512:	1e6a      	subs	r2, r5, #1
   16514:	4413      	add	r3, r2
   16516:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
   1651a:	280f      	cmp	r0, #15
   1651c:	9303      	str	r3, [sp, #12]
   1651e:	d804      	bhi.n	1652a <mpu_configure_region+0x34>
	region_init(index, region_conf);
   16520:	4669      	mov	r1, sp
   16522:	f7fb fa5b 	bl	119dc <region_init>
}
   16526:	b004      	add	sp, #16
   16528:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   1652a:	f06f 0015 	mvn.w	r0, #21
	return region_allocate_and_init(index,
   1652e:	e7fa      	b.n	16526 <mpu_configure_region+0x30>

00016530 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   16530:	4603      	mov	r3, r0
	size_t n = 0;
   16532:	2000      	movs	r0, #0

	while (*s != '\0') {
   16534:	5c1a      	ldrb	r2, [r3, r0]
   16536:	b902      	cbnz	r2, 1653a <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   16538:	4770      	bx	lr
		n++;
   1653a:	3001      	adds	r0, #1
   1653c:	e7fa      	b.n	16534 <strlen+0x4>

0001653e <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   1653e:	4603      	mov	r3, r0
	size_t n = 0;
   16540:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   16542:	5c1a      	ldrb	r2, [r3, r0]
   16544:	b10a      	cbz	r2, 1654a <strnlen+0xc>
   16546:	4288      	cmp	r0, r1
   16548:	d100      	bne.n	1654c <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   1654a:	4770      	bx	lr
		n++;
   1654c:	3001      	adds	r0, #1
   1654e:	e7f8      	b.n	16542 <strnlen+0x4>

00016550 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   16550:	1e43      	subs	r3, r0, #1
   16552:	3901      	subs	r1, #1
   16554:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   16558:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   1655c:	4282      	cmp	r2, r0
   1655e:	d101      	bne.n	16564 <strcmp+0x14>
   16560:	2a00      	cmp	r2, #0
   16562:	d1f7      	bne.n	16554 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   16564:	1a10      	subs	r0, r2, r0
   16566:	4770      	bx	lr

00016568 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   16568:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   1656a:	b15a      	cbz	r2, 16584 <memcmp+0x1c>
   1656c:	3901      	subs	r1, #1
   1656e:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   16570:	f810 2b01 	ldrb.w	r2, [r0], #1
   16574:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   16578:	42a0      	cmp	r0, r4
   1657a:	d001      	beq.n	16580 <memcmp+0x18>
   1657c:	429a      	cmp	r2, r3
   1657e:	d0f7      	beq.n	16570 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   16580:	1ad0      	subs	r0, r2, r3
}
   16582:	bd10      	pop	{r4, pc}
		return 0;
   16584:	4610      	mov	r0, r2
   16586:	e7fc      	b.n	16582 <memcmp+0x1a>

00016588 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   16588:	b510      	push	{r4, lr}
   1658a:	1e43      	subs	r3, r0, #1
   1658c:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   1658e:	4291      	cmp	r1, r2
   16590:	d100      	bne.n	16594 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   16592:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   16594:	f811 4b01 	ldrb.w	r4, [r1], #1
   16598:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   1659c:	e7f7      	b.n	1658e <memcpy+0x6>

0001659e <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   1659e:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   165a0:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   165a2:	4402      	add	r2, r0
   165a4:	4293      	cmp	r3, r2
   165a6:	d100      	bne.n	165aa <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   165a8:	4770      	bx	lr
		*(d_byte++) = c_byte;
   165aa:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   165ae:	e7f9      	b.n	165a4 <memset+0x6>

000165b0 <_stdout_hook_default>:
}
   165b0:	f04f 30ff 	mov.w	r0, #4294967295
   165b4:	4770      	bx	lr

000165b6 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   165b6:	b2cb      	uxtb	r3, r1
   165b8:	210c      	movs	r1, #12
   165ba:	6902      	ldr	r2, [r0, #16]
   165bc:	fb03 2101 	mla	r1, r3, r1, r2
   165c0:	6c08      	ldr	r0, [r1, #64]	; 0x40
}
   165c2:	f000 0007 	and.w	r0, r0, #7
   165c6:	4770      	bx	lr

000165c8 <set_off_state>:
	__asm__ volatile(
   165c8:	f04f 0320 	mov.w	r3, #32
   165cc:	f3ef 8211 	mrs	r2, BASEPRI
   165d0:	f383 8812 	msr	BASEPRI_MAX, r3
   165d4:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   165d8:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   165da:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   165de:	d001      	beq.n	165e4 <set_off_state+0x1c>
   165e0:	428b      	cmp	r3, r1
   165e2:	d107      	bne.n	165f4 <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   165e4:	2301      	movs	r3, #1
   165e6:	6003      	str	r3, [r0, #0]
	int err = 0;
   165e8:	2000      	movs	r0, #0
	__asm__ volatile(
   165ea:	f382 8811 	msr	BASEPRI, r2
   165ee:	f3bf 8f6f 	isb	sy
}
   165f2:	4770      	bx	lr
		err = -EPERM;
   165f4:	f04f 30ff 	mov.w	r0, #4294967295
   165f8:	e7f7      	b.n	165ea <set_off_state+0x22>

000165fa <set_starting_state>:
{
   165fa:	b510      	push	{r4, lr}
	__asm__ volatile(
   165fc:	f04f 0320 	mov.w	r3, #32
   16600:	f3ef 8211 	mrs	r2, BASEPRI
   16604:	f383 8812 	msr	BASEPRI_MAX, r3
   16608:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   1660c:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   1660e:	f003 0407 	and.w	r4, r3, #7
   16612:	2c01      	cmp	r4, #1
   16614:	d106      	bne.n	16624 <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   16616:	6001      	str	r1, [r0, #0]
	int err = 0;
   16618:	2000      	movs	r0, #0
	__asm__ volatile(
   1661a:	f382 8811 	msr	BASEPRI, r2
   1661e:	f3bf 8f6f 	isb	sy
}
   16622:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   16624:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   16628:	428b      	cmp	r3, r1
		err = -EALREADY;
   1662a:	bf14      	ite	ne
   1662c:	f04f 30ff 	movne.w	r0, #4294967295
   16630:	f06f 0077 	mvneq.w	r0, #119	; 0x77
   16634:	e7f1      	b.n	1661a <set_starting_state+0x20>

00016636 <set_on_state>:
	__asm__ volatile(
   16636:	f04f 0320 	mov.w	r3, #32
   1663a:	f3ef 8211 	mrs	r2, BASEPRI
   1663e:	f383 8812 	msr	BASEPRI_MAX, r3
   16642:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   16646:	6803      	ldr	r3, [r0, #0]
   16648:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1664c:	f043 0302 	orr.w	r3, r3, #2
   16650:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   16652:	f382 8811 	msr	BASEPRI, r2
   16656:	f3bf 8f6f 	isb	sy
}
   1665a:	4770      	bx	lr

0001665c <onoff_started_callback>:
{
   1665c:	b410      	push	{r4}
	notify(mgr, 0);
   1665e:	241c      	movs	r4, #28
	return &data->mgr[type];
   16660:	6900      	ldr	r0, [r0, #16]
   16662:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   16664:	fb03 0004 	mla	r0, r3, r4, r0
   16668:	2100      	movs	r1, #0
}
   1666a:	bc10      	pop	{r4}
	notify(mgr, 0);
   1666c:	4710      	bx	r2

0001666e <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   1666e:	2000      	movs	r0, #0
   16670:	f7fc bc6c 	b.w	12f4c <nrfx_clock_start>

00016674 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   16674:	2000      	movs	r0, #0
   16676:	f7fc bc9b 	b.w	12fb0 <nrfx_clock_stop>

0001667a <blocking_start_callback>:
{
   1667a:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   1667c:	f7fe bddc 	b.w	15238 <z_impl_k_sem_give>

00016680 <api_stop>:
{
   16680:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   16682:	230c      	movs	r3, #12
   16684:	b2cc      	uxtb	r4, r1
   16686:	4363      	muls	r3, r4
{
   16688:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   1668a:	6900      	ldr	r0, [r0, #16]
   1668c:	3340      	adds	r3, #64	; 0x40
   1668e:	2180      	movs	r1, #128	; 0x80
   16690:	4418      	add	r0, r3
   16692:	f7ff ff99 	bl	165c8 <set_off_state>
	if (err < 0) {
   16696:	2800      	cmp	r0, #0
   16698:	db05      	blt.n	166a6 <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   1669a:	6869      	ldr	r1, [r5, #4]
   1669c:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
   166a0:	6863      	ldr	r3, [r4, #4]
   166a2:	4798      	blx	r3
	return 0;
   166a4:	2000      	movs	r0, #0
}
   166a6:	bd38      	pop	{r3, r4, r5, pc}

000166a8 <api_start>:
{
   166a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	err = set_starting_state(&subdata->flags, ctx);
   166ac:	270c      	movs	r7, #12
   166ae:	b2cd      	uxtb	r5, r1
   166b0:	436f      	muls	r7, r5
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   166b2:	6904      	ldr	r4, [r0, #16]
{
   166b4:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   166b6:	f107 0040 	add.w	r0, r7, #64	; 0x40
   166ba:	2180      	movs	r1, #128	; 0x80
   166bc:	4420      	add	r0, r4
{
   166be:	4690      	mov	r8, r2
   166c0:	4699      	mov	r9, r3
	err = set_starting_state(&subdata->flags, ctx);
   166c2:	f7ff ff9a 	bl	165fa <set_starting_state>
	if (err < 0) {
   166c6:	2800      	cmp	r0, #0
   166c8:	db07      	blt.n	166da <api_start+0x32>
	subdata->cb = cb;
   166ca:	443c      	add	r4, r7
	subdata->user_data = user_data;
   166cc:	e9c4 890e 	strd	r8, r9, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
   166d0:	6873      	ldr	r3, [r6, #4]
   166d2:	f853 3035 	ldr.w	r3, [r3, r5, lsl #3]
   166d6:	4798      	blx	r3
	return 0;
   166d8:	2000      	movs	r0, #0
}
   166da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000166de <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   166de:	6843      	ldr	r3, [r0, #4]
}
   166e0:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   166e2:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   166e4:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   166e6:	600b      	str	r3, [r1, #0]
}
   166e8:	4770      	bx	lr

000166ea <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   166ea:	6843      	ldr	r3, [r0, #4]
   166ec:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   166ee:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   166f0:	4042      	eors	r2, r0
   166f2:	400a      	ands	r2, r1
   166f4:	4042      	eors	r2, r0
    p_reg->OUT = value;
   166f6:	605a      	str	r2, [r3, #4]
}
   166f8:	2000      	movs	r0, #0
   166fa:	4770      	bx	lr

000166fc <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   166fc:	6843      	ldr	r3, [r0, #4]
}
   166fe:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   16700:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   16702:	6099      	str	r1, [r3, #8]
}
   16704:	4770      	bx	lr

00016706 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   16706:	6843      	ldr	r3, [r0, #4]
}
   16708:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1670a:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   1670c:	60d9      	str	r1, [r3, #12]
}
   1670e:	4770      	bx	lr

00016710 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   16710:	6843      	ldr	r3, [r0, #4]
}
   16712:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   16714:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   16716:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   16718:	404b      	eors	r3, r1
    p_reg->OUT = value;
   1671a:	6053      	str	r3, [r2, #4]
}
   1671c:	4770      	bx	lr

0001671e <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1671e:	6903      	ldr	r3, [r0, #16]
{
   16720:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   16722:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   16724:	b158      	cbz	r0, 1673e <gpio_nrfx_manage_callback+0x20>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   16726:	2400      	movs	r4, #0
   16728:	4281      	cmp	r1, r0
   1672a:	d113      	bne.n	16754 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   1672c:	6808      	ldr	r0, [r1, #0]
   1672e:	b95c      	cbnz	r4, 16748 <gpio_nrfx_manage_callback+0x2a>
   16730:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   16732:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   16734:	42a1      	cmp	r1, r4
   16736:	d100      	bne.n	1673a <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   16738:	6098      	str	r0, [r3, #8]
	parent->next = child;
   1673a:	2000      	movs	r0, #0
   1673c:	6008      	str	r0, [r1, #0]
	if (set) {
   1673e:	b972      	cbnz	r2, 1675e <gpio_nrfx_manage_callback+0x40>
	return 0;
   16740:	2000      	movs	r0, #0
}
   16742:	bd30      	pop	{r4, r5, pc}
   16744:	4628      	mov	r0, r5
   16746:	e7ef      	b.n	16728 <gpio_nrfx_manage_callback+0xa>
   16748:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   1674a:	6898      	ldr	r0, [r3, #8]
   1674c:	4281      	cmp	r1, r0
	list->tail = node;
   1674e:	bf08      	it	eq
   16750:	609c      	streq	r4, [r3, #8]
}
   16752:	e7f2      	b.n	1673a <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   16754:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   16756:	4604      	mov	r4, r0
   16758:	2d00      	cmp	r5, #0
   1675a:	d1f3      	bne.n	16744 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   1675c:	b13a      	cbz	r2, 1676e <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   1675e:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   16760:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   16762:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   16764:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   16766:	2800      	cmp	r0, #0
   16768:	d1ea      	bne.n	16740 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   1676a:	6099      	str	r1, [r3, #8]
}
   1676c:	e7e9      	b.n	16742 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   1676e:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   16772:	e7e6      	b.n	16742 <gpio_nrfx_manage_callback+0x24>

00016774 <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   16774:	6843      	ldr	r3, [r0, #4]
   16776:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   16778:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   1677c:	05d1      	lsls	r1, r2, #23
   1677e:	d518      	bpl.n	167b2 <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   16780:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   16784:	b1aa      	cbz	r2, 167b2 <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   16786:	f04f 0120 	mov.w	r1, #32
   1678a:	f3ef 8211 	mrs	r2, BASEPRI
   1678e:	f381 8812 	msr	BASEPRI_MAX, r1
   16792:	f3bf 8f6f 	isb	sy
   16796:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   1679a:	b131      	cbz	r1, 167aa <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1679c:	2100      	movs	r1, #0
   1679e:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   167a2:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   167a6:	2101      	movs	r1, #1
   167a8:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   167aa:	f382 8811 	msr	BASEPRI, r2
   167ae:	f3bf 8f6f 	isb	sy
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
   167b2:	6842      	ldr	r2, [r0, #4]
   167b4:	6852      	ldr	r2, [r2, #4]
   167b6:	06d2      	lsls	r2, r2, #27
   167b8:	d515      	bpl.n	167e6 <uarte_nrfx_isr_int+0x72>
	__asm__ volatile(
   167ba:	f04f 0120 	mov.w	r1, #32
   167be:	f3ef 8211 	mrs	r2, BASEPRI
   167c2:	f381 8812 	msr	BASEPRI_MAX, r1
   167c6:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   167ca:	f8d3 1158 	ldr.w	r1, [r3, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
   167ce:	b111      	cbz	r1, 167d6 <uarte_nrfx_isr_int+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
   167d0:	2100      	movs	r1, #0
   167d2:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    p_reg->INTENCLR = mask;
   167d6:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
   167da:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
	__asm__ volatile(
   167de:	f382 8811 	msr	BASEPRI, r2
   167e2:	f3bf 8f6f 	isb	sy
}
   167e6:	4770      	bx	lr

000167e8 <uarte_nrfx_config_get>:
{
   167e8:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   167ea:	6902      	ldr	r2, [r0, #16]
   167ec:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   167f0:	e883 0003 	stmia.w	r3, {r0, r1}
}
   167f4:	2000      	movs	r0, #0
   167f6:	4770      	bx	lr

000167f8 <uarte_nrfx_err_check>:
	return config->uarte_regs;
   167f8:	6843      	ldr	r3, [r0, #4]
   167fa:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   167fc:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   16800:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   16804:	4770      	bx	lr

00016806 <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   16806:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   16808:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1680a:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   1680e:	b940      	cbnz	r0, 16822 <is_tx_ready+0x1c>
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
   16810:	6852      	ldr	r2, [r2, #4]
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   16812:	0792      	lsls	r2, r2, #30
   16814:	d406      	bmi.n	16824 <is_tx_ready+0x1e>
   16816:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   1681a:	3800      	subs	r0, #0
   1681c:	bf18      	it	ne
   1681e:	2001      	movne	r0, #1
   16820:	4770      	bx	lr
   16822:	2001      	movs	r0, #1
}
   16824:	4770      	bx	lr

00016826 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   16826:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   16828:	6902      	ldr	r2, [r0, #16]
	return config->uarte_regs;
   1682a:	681b      	ldr	r3, [r3, #0]
   1682c:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   16830:	b148      	cbz	r0, 16846 <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   16832:	2000      	movs	r0, #0
	*c = data->rx_data;
   16834:	7c52      	ldrb	r2, [r2, #17]
   16836:	700a      	strb	r2, [r1, #0]
   16838:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   1683c:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   16840:	2201      	movs	r2, #1
   16842:	601a      	str	r2, [r3, #0]
	return 0;
   16844:	4770      	bx	lr
		return -1;
   16846:	f04f 30ff 	mov.w	r0, #4294967295
}
   1684a:	4770      	bx	lr

0001684c <entropy_cc3xx_rng_init>:
			return -EINVAL;
		}
	#endif

	return 0;
}
   1684c:	2000      	movs	r0, #0
   1684e:	4770      	bx	lr

00016850 <entropy_cc3xx_rng_get_entropy>:
{
   16850:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16852:	460f      	mov	r7, r1
   16854:	4616      	mov	r6, r2
	size_t chunk_size = CTR_DRBG_MAX_REQUEST;
   16856:	f44f 6580 	mov.w	r5, #1024	; 0x400
	size_t offset = 0;
   1685a:	2400      	movs	r4, #0
	int res = -EINVAL;
   1685c:	f06f 0015 	mvn.w	r0, #21
	while (offset < length) {
   16860:	42a6      	cmp	r6, r4
   16862:	d801      	bhi.n	16868 <entropy_cc3xx_rng_get_entropy+0x18>
}
   16864:	b003      	add	sp, #12
   16866:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if ((length - offset) < CTR_DRBG_MAX_REQUEST) {
   16868:	1b33      	subs	r3, r6, r4
   1686a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   1686e:	bf38      	it	cc
   16870:	461d      	movcc	r5, r3
			res = spm_request_random_number(buffer + offset,
   16872:	aa01      	add	r2, sp, #4
   16874:	4629      	mov	r1, r5
   16876:	1938      	adds	r0, r7, r4
   16878:	f7ff fe11 	bl	1649e <spm_request_random_number>
		if (olen != chunk_size) {
   1687c:	9b01      	ldr	r3, [sp, #4]
   1687e:	42ab      	cmp	r3, r5
   16880:	d103      	bne.n	1688a <entropy_cc3xx_rng_get_entropy+0x3a>
		if (res != 0) {
   16882:	2800      	cmp	r0, #0
   16884:	d1ee      	bne.n	16864 <entropy_cc3xx_rng_get_entropy+0x14>
		offset += chunk_size;
   16886:	442c      	add	r4, r5
   16888:	e7ea      	b.n	16860 <entropy_cc3xx_rng_get_entropy+0x10>
			return -EINVAL;
   1688a:	f06f 0015 	mvn.w	r0, #21
   1688e:	e7e9      	b.n	16864 <entropy_cc3xx_rng_get_entropy+0x14>

00016890 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   16890:	4770      	bx	lr

00016892 <nrf_modem_os_busywait>:
	z_impl_k_busy_wait(usec_to_wait);
   16892:	f000 bb24 	b.w	16ede <z_impl_k_busy_wait>

00016896 <nrf_modem_os_is_in_isr>:
	return k_is_in_isr();
   16896:	f000 b9ca 	b.w	16c2e <k_is_in_isr>

0001689a <nrf_modem_os_sem_give>:
	z_impl_k_sem_give(sem);
   1689a:	f7fe bccd 	b.w	15238 <z_impl_k_sem_give>

0001689e <nrf_modem_os_sem_take>:
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   1689e:	1c4b      	adds	r3, r1, #1
{
   168a0:	b5d0      	push	{r4, r6, r7, lr}
   168a2:	4604      	mov	r4, r0
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   168a4:	d01a      	beq.n	168dc <nrf_modem_os_sem_take+0x3e>
   168a6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   168aa:	f240 36e7 	movw	r6, #999	; 0x3e7
   168ae:	2700      	movs	r7, #0
   168b0:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   168b4:	fbc0 6701 	smlal	r6, r7, r0, r1
   168b8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   168bc:	2300      	movs	r3, #0
   168be:	4630      	mov	r0, r6
   168c0:	4639      	mov	r1, r7
   168c2:	f7f9 fcbb 	bl	1023c <__aeabi_uldivmod>
   168c6:	4602      	mov	r2, r0
   168c8:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
   168ca:	4620      	mov	r0, r4
   168cc:	f7fe fcd4 	bl	15278 <z_impl_k_sem_take>
	if (err == -EAGAIN) {
   168d0:	f110 0f0b 	cmn.w	r0, #11
}
   168d4:	bf0c      	ite	eq
   168d6:	2074      	moveq	r0, #116	; 0x74
   168d8:	2000      	movne	r0, #0
   168da:	bdd0      	pop	{r4, r6, r7, pc}
	err = k_sem_take((struct k_sem *)sem, timeout == -1 ? K_FOREVER : K_MSEC(timeout));
   168dc:	f04f 32ff 	mov.w	r2, #4294967295
   168e0:	4613      	mov	r3, r2
   168e2:	e7f2      	b.n	168ca <nrf_modem_os_sem_take+0x2c>

000168e4 <read_task_create>:
{
   168e4:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(NRF_MODEM_APPLICATION_IRQ,
   168e6:	201c      	movs	r0, #28
   168e8:	2200      	movs	r2, #0
   168ea:	2106      	movs	r1, #6
   168ec:	f7fa fe20 	bl	11530 <z_arm_irq_priority_set>
}
   168f0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(NRF_MODEM_APPLICATION_IRQ);
   168f4:	201c      	movs	r0, #28
   168f6:	f7fa bdfd 	b.w	114f4 <arch_irq_enable>

000168fa <nrf_modem_os_trace_put>:
	if (err) {
		LOG_ERR("nrf_modem_trace_processed_callback failed, err %d", err);
	}
#endif
	return 0;
}
   168fa:	2000      	movs	r0, #0
   168fc:	4770      	bx	lr

000168fe <k_sys_fatal_error_handler>:
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
		sys_arch_reboot(0);
   168fe:	2000      	movs	r0, #0
{
   16900:	b508      	push	{r3, lr}
		sys_arch_reboot(0);
   16902:	f7fb f82b 	bl	1195c <sys_arch_reboot>

00016906 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   16906:	4700      	bx	r0

00016908 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   16908:	f000 bae9 	b.w	16ede <z_impl_k_busy_wait>

0001690c <nrfx_clock_enable>:
{
   1690c:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   1690e:	2005      	movs	r0, #5
   16910:	f7fa fe00 	bl	11514 <arch_irq_is_enabled>
   16914:	b920      	cbnz	r0, 16920 <nrfx_clock_enable+0x14>
}
   16916:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   1691a:	2005      	movs	r0, #5
   1691c:	f7fa bdea 	b.w	114f4 <arch_irq_enable>
   16920:	bd08      	pop	{r3, pc}

00016922 <rpc_handle_ctrl_message>:
   16922:	2902      	cmp	r1, #2
   16924:	b510      	push	{r4, lr}
   16926:	4604      	mov	r4, r0
   16928:	d005      	beq.n	16936 <rpc_handle_ctrl_message+0x14>
   1692a:	2904      	cmp	r1, #4
   1692c:	d001      	beq.n	16932 <rpc_handle_ctrl_message+0x10>
   1692e:	2901      	cmp	r1, #1
   16930:	d107      	bne.n	16942 <rpc_handle_ctrl_message+0x20>
   16932:	2000      	movs	r0, #0
   16934:	bd10      	pop	{r4, pc}
   16936:	6880      	ldr	r0, [r0, #8]
   16938:	2800      	cmp	r0, #0
   1693a:	d0fa      	beq.n	16932 <rpc_handle_ctrl_message+0x10>
   1693c:	f000 f831 	bl	169a2 <rpc_transport_local_data_free>
   16940:	e7f7      	b.n	16932 <rpc_handle_ctrl_message+0x10>
   16942:	6880      	ldr	r0, [r0, #8]
   16944:	b108      	cbz	r0, 1694a <rpc_handle_ctrl_message+0x28>
   16946:	f000 f82c 	bl	169a2 <rpc_transport_local_data_free>
   1694a:	4620      	mov	r0, r4
   1694c:	f000 f825 	bl	1699a <rpc_transport_msg_free>
   16950:	e7ef      	b.n	16932 <rpc_handle_ctrl_message+0x10>

00016952 <rpc_message_send>:
   16952:	6843      	ldr	r3, [r0, #4]
   16954:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   16958:	f043 0302 	orr.w	r3, r3, #2
   1695c:	6043      	str	r3, [r0, #4]
   1695e:	f000 b824 	b.w	169aa <rpc_transport_data_msg_send>

00016962 <rpc_message_alloc>:
   16962:	b570      	push	{r4, r5, r6, lr}
   16964:	4606      	mov	r6, r0
   16966:	b130      	cbz	r0, 16976 <rpc_message_alloc+0x14>
   16968:	f000 f819 	bl	1699e <rpc_transport_data_alloc>
   1696c:	4605      	mov	r5, r0
   1696e:	b918      	cbnz	r0, 16978 <rpc_message_alloc+0x16>
   16970:	2400      	movs	r4, #0
   16972:	4620      	mov	r0, r4
   16974:	bd70      	pop	{r4, r5, r6, pc}
   16976:	4605      	mov	r5, r0
   16978:	f000 f80d 	bl	16996 <rpc_transport_data_msg_alloc>
   1697c:	4604      	mov	r4, r0
   1697e:	b110      	cbz	r0, 16986 <rpc_message_alloc+0x24>
   16980:	60c6      	str	r6, [r0, #12]
   16982:	6085      	str	r5, [r0, #8]
   16984:	e7f5      	b.n	16972 <rpc_message_alloc+0x10>
   16986:	2d00      	cmp	r5, #0
   16988:	d0f2      	beq.n	16970 <rpc_message_alloc+0xe>
   1698a:	4628      	mov	r0, r5
   1698c:	f000 f809 	bl	169a2 <rpc_transport_local_data_free>
   16990:	e7ef      	b.n	16972 <rpc_message_alloc+0x10>

00016992 <rpc_message_data_free>:
   16992:	f000 b808 	b.w	169a6 <rpc_transport_peer_data_free>

00016996 <rpc_transport_data_msg_alloc>:
   16996:	f7fd b99f 	b.w	13cd8 <rpc_transport_ipc_data_msg_alloc>

0001699a <rpc_transport_msg_free>:
   1699a:	f7fd b9e9 	b.w	13d70 <rpc_transport_ipc_msg_free>

0001699e <rpc_transport_data_alloc>:
   1699e:	f7fd b9cd 	b.w	13d3c <rpc_transport_ipc_data_alloc>

000169a2 <rpc_transport_local_data_free>:
   169a2:	f000 b804 	b.w	169ae <rpc_transport_ipc_local_data_free>

000169a6 <rpc_transport_peer_data_free>:
   169a6:	f000 b809 	b.w	169bc <rpc_transport_ipc_peer_data_free>

000169aa <rpc_transport_data_msg_send>:
   169aa:	f7fd b959 	b.w	13c60 <rpc_transport_ipc_data_msg_send>

000169ae <rpc_transport_ipc_local_data_free>:
   169ae:	b508      	push	{r3, lr}
   169b0:	f7fc f9f6 	bl	12da0 <nrf_modem_os_shm_tx_free>
   169b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   169b8:	f7fc b9bc 	b.w	12d34 <nrf_modem_os_application_irq_set>

000169bc <rpc_transport_ipc_peer_data_free>:
   169bc:	b510      	push	{r4, lr}
   169be:	4604      	mov	r4, r0
   169c0:	f7fd f99c 	bl	13cfc <rpc_transport_ipc_ctrl_msg_alloc>
   169c4:	2101      	movs	r1, #1
   169c6:	2200      	movs	r2, #0
   169c8:	7001      	strb	r1, [r0, #0]
   169ca:	2102      	movs	r1, #2
   169cc:	6084      	str	r4, [r0, #8]
   169ce:	7042      	strb	r2, [r0, #1]
   169d0:	7081      	strb	r1, [r0, #2]
   169d2:	70c2      	strb	r2, [r0, #3]
   169d4:	f7fd f962 	bl	13c9c <rpc_transport_ipc_ctrl_msg_send>
   169d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   169dc:	f7fc b9aa 	b.w	12d34 <nrf_modem_os_application_irq_set>

000169e0 <rpc_client_request_alloc>:
   169e0:	b508      	push	{r3, lr}
   169e2:	f7ff ffbe 	bl	16962 <rpc_message_alloc>
   169e6:	b100      	cbz	r0, 169ea <rpc_client_request_alloc+0xa>
   169e8:	3008      	adds	r0, #8
   169ea:	bd08      	pop	{r3, pc}

000169ec <rpc_client_request_send>:
   169ec:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
   169f0:	4610      	mov	r0, r2
   169f2:	f840 1d08 	str.w	r1, [r0, #-8]!
   169f6:	f7ff bfac 	b.w	16952 <rpc_message_send>

000169fa <rpc_client_data_free>:
   169fa:	f7ff bfca 	b.w	16992 <rpc_message_data_free>

000169fe <ip_interface_request_create>:
   169fe:	b570      	push	{r4, r5, r6, lr}
   16a00:	4606      	mov	r6, r0
   16a02:	4618      	mov	r0, r3
   16a04:	460d      	mov	r5, r1
   16a06:	4614      	mov	r4, r2
   16a08:	f7ff ffea 	bl	169e0 <rpc_client_request_alloc>
   16a0c:	b148      	cbz	r0, 16a22 <ip_interface_request_create+0x24>
   16a0e:	2300      	movs	r3, #0
   16a10:	2208      	movs	r2, #8
   16a12:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   16a16:	60c4      	str	r4, [r0, #12]
   16a18:	6105      	str	r5, [r0, #16]
   16a1a:	7202      	strb	r2, [r0, #8]
   16a1c:	7243      	strb	r3, [r0, #9]
   16a1e:	7283      	strb	r3, [r0, #10]
   16a20:	72c3      	strb	r3, [r0, #11]
   16a22:	bd70      	pop	{r4, r5, r6, pc}

00016a24 <ip_interface_wait>:
   16a24:	b538      	push	{r3, r4, r5, lr}
   16a26:	4605      	mov	r5, r0
   16a28:	f7fd fb28 	bl	1407c <interface_socket_wait>
   16a2c:	4604      	mov	r4, r0
   16a2e:	b938      	cbnz	r0, 16a40 <ip_interface_wait+0x1c>
   16a30:	4628      	mov	r0, r5
   16a32:	f7fd fb9d 	bl	14170 <interface_socket_from_handle_get>
   16a36:	b118      	cbz	r0, 16a40 <ip_interface_wait+0x1c>
   16a38:	6844      	ldr	r4, [r0, #4]
   16a3a:	b10c      	cbz	r4, 16a40 <ip_interface_wait+0x1c>
   16a3c:	2300      	movs	r3, #0
   16a3e:	6043      	str	r3, [r0, #4]
   16a40:	4620      	mov	r0, r4
   16a42:	bd38      	pop	{r3, r4, r5, pc}

00016a44 <secure_client_socket>:
   16a44:	f04f 33ff 	mov.w	r3, #4294967295
   16a48:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16a4a:	9301      	str	r3, [sp, #4]
   16a4c:	680b      	ldr	r3, [r1, #0]
   16a4e:	4606      	mov	r6, r0
   16a50:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   16a54:	600b      	str	r3, [r1, #0]
   16a56:	680b      	ldr	r3, [r1, #0]
   16a58:	460c      	mov	r4, r1
   16a5a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   16a5e:	600b      	str	r3, [r1, #0]
   16a60:	680f      	ldr	r7, [r1, #0]
   16a62:	463a      	mov	r2, r7
   16a64:	f7fd fe50 	bl	14708 <secure_socket_attach_initiate>
   16a68:	4605      	mov	r5, r0
   16a6a:	b950      	cbnz	r0, 16a82 <secure_client_socket+0x3e>
   16a6c:	220c      	movs	r2, #12
   16a6e:	4630      	mov	r0, r6
   16a70:	4611      	mov	r1, r2
   16a72:	ab01      	add	r3, sp, #4
   16a74:	f7ff ffd6 	bl	16a24 <ip_interface_wait>
   16a78:	4605      	mov	r5, r0
   16a7a:	b128      	cbz	r0, 16a88 <secure_client_socket+0x44>
   16a7c:	2877      	cmp	r0, #119	; 0x77
   16a7e:	d000      	beq.n	16a82 <secure_client_socket+0x3e>
   16a80:	6027      	str	r7, [r4, #0]
   16a82:	4628      	mov	r0, r5
   16a84:	b003      	add	sp, #12
   16a86:	bdf0      	pop	{r4, r5, r6, r7, pc}
   16a88:	4630      	mov	r0, r6
   16a8a:	f7fd fe2b 	bl	146e4 <hostname_free>
   16a8e:	6823      	ldr	r3, [r4, #0]
   16a90:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   16a94:	6023      	str	r3, [r4, #0]
   16a96:	6823      	ldr	r3, [r4, #0]
   16a98:	0c1b      	lsrs	r3, r3, #16
   16a9a:	041b      	lsls	r3, r3, #16
   16a9c:	f043 030c 	orr.w	r3, r3, #12
   16aa0:	6023      	str	r3, [r4, #0]
   16aa2:	6823      	ldr	r3, [r4, #0]
   16aa4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   16aa8:	6023      	str	r3, [r4, #0]
   16aaa:	6823      	ldr	r3, [r4, #0]
   16aac:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   16ab0:	6023      	str	r3, [r4, #0]
   16ab2:	e7e6      	b.n	16a82 <secure_client_socket+0x3e>

00016ab4 <nrf_modem_recoverable_error_handler>:
   16ab4:	4770      	bx	lr

00016ab6 <nrf_modem_platform_error_handler>:
   16ab6:	b508      	push	{r3, lr}
   16ab8:	f7ff fffc 	bl	16ab4 <nrf_modem_recoverable_error_handler>
   16abc:	bd08      	pop	{r3, pc}

00016abe <rpc_transport_ipc_fault_handler>:
   16abe:	f7ff bffa 	b.w	16ab6 <nrf_modem_platform_error_handler>

00016ac2 <nrf_modem_platform_init>:
   16ac2:	b513      	push	{r0, r1, r4, lr}
   16ac4:	4604      	mov	r4, r0
   16ac6:	f7fc f971 	bl	12dac <nrf_modem_os_init>
   16aca:	6a23      	ldr	r3, [r4, #32]
   16acc:	4668      	mov	r0, sp
   16ace:	9400      	str	r4, [sp, #0]
   16ad0:	f88d 3004 	strb.w	r3, [sp, #4]
   16ad4:	f7fd f972 	bl	13dbc <rpc_transport_ipc_init>
   16ad8:	4604      	mov	r4, r0
   16ada:	b948      	cbnz	r0, 16af0 <nrf_modem_platform_init+0x2e>
   16adc:	f7fd fac2 	bl	14064 <interface_init>
   16ae0:	f7fd ff06 	bl	148f0 <nrf_modem_at_init>
   16ae4:	4604      	mov	r4, r0
   16ae6:	b918      	cbnz	r0, 16af0 <nrf_modem_platform_init+0x2e>
   16ae8:	f7fd fb7a 	bl	141e0 <ip_interface_init>
   16aec:	f7fd fe5e 	bl	147ac <tls_interface_init>
   16af0:	4620      	mov	r0, r4
   16af2:	b002      	add	sp, #8
   16af4:	bd10      	pop	{r4, pc}

00016af6 <z_device_state_init>:
}
   16af6:	4770      	bx	lr

00016af8 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   16af8:	b138      	cbz	r0, 16b0a <z_device_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   16afa:	68c3      	ldr	r3, [r0, #12]
   16afc:	8818      	ldrh	r0, [r3, #0]
   16afe:	f3c0 0008 	ubfx	r0, r0, #0, #9
   16b02:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
   16b06:	4258      	negs	r0, r3
   16b08:	4158      	adcs	r0, r3
}
   16b0a:	4770      	bx	lr

00016b0c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   16b0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16b0e:	4605      	mov	r5, r0
   16b10:	460e      	mov	r6, r1
	__asm__ volatile(
   16b12:	f04f 0320 	mov.w	r3, #32
   16b16:	f3ef 8711 	mrs	r7, BASEPRI
   16b1a:	f383 8812 	msr	BASEPRI_MAX, r3
   16b1e:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   16b22:	f7fe fed7 	bl	158d4 <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   16b26:	4631      	mov	r1, r6
   16b28:	4604      	mov	r4, r0
   16b2a:	4628      	mov	r0, r5
   16b2c:	f7ff fee7 	bl	168fe <k_sys_fatal_error_handler>
	__asm__ volatile(
   16b30:	f387 8811 	msr	BASEPRI, r7
   16b34:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   16b38:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   16b3a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   16b3e:	f7fa bf1f 	b.w	11980 <z_impl_k_thread_abort>

00016b42 <k_heap_init>:
{
   16b42:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   16b44:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   16b48:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   16b4c:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   16b4e:	f7ff bbeb 	b.w	16328 <sys_heap_init>

00016b52 <k_heap_aligned_alloc>:
SYS_INIT(statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   16b52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16b56:	b087      	sub	sp, #28
   16b58:	4604      	mov	r4, r0
   16b5a:	460e      	mov	r6, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   16b5c:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
{
   16b60:	4617      	mov	r7, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   16b62:	f000 f9c0 	bl	16ee6 <sys_clock_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   16b66:	f104 0914 	add.w	r9, r4, #20
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   16b6a:	4605      	mov	r5, r0
   16b6c:	4688      	mov	r8, r1
	__asm__ volatile(
   16b6e:	f04f 0320 	mov.w	r3, #32
   16b72:	f3ef 8b11 	mrs	fp, BASEPRI
   16b76:	f383 8812 	msr	BASEPRI_MAX, r3
   16b7a:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   16b7e:	f104 0a0c 	add.w	sl, r4, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   16b82:	463a      	mov	r2, r7
   16b84:	4631      	mov	r1, r6
   16b86:	4620      	mov	r0, r4
   16b88:	f7ff fb66 	bl	16258 <sys_heap_aligned_alloc>
   16b8c:	9005      	str	r0, [sp, #20]
		now = sys_clock_tick_get();
   16b8e:	f7ff f855 	bl	15c3c <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   16b92:	9b05      	ldr	r3, [sp, #20]
   16b94:	b13b      	cbz	r3, 16ba6 <k_heap_aligned_alloc+0x54>
	__asm__ volatile(
   16b96:	f38b 8811 	msr	BASEPRI, fp
   16b9a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   16b9e:	4618      	mov	r0, r3
   16ba0:	b007      	add	sp, #28
   16ba2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   16ba6:	1a2a      	subs	r2, r5, r0
   16ba8:	9202      	str	r2, [sp, #8]
   16baa:	eb68 0201 	sbc.w	r2, r8, r1
   16bae:	9203      	str	r2, [sp, #12]
   16bb0:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   16bb4:	2901      	cmp	r1, #1
   16bb6:	f172 0200 	sbcs.w	r2, r2, #0
   16bba:	dbec      	blt.n	16b96 <k_heap_aligned_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   16bbc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   16bc0:	4659      	mov	r1, fp
   16bc2:	e9cd 2300 	strd	r2, r3, [sp]
   16bc6:	4648      	mov	r0, r9
   16bc8:	4652      	mov	r2, sl
   16bca:	f7fe fd21 	bl	15610 <z_pend_curr>
	__asm__ volatile(
   16bce:	f04f 0320 	mov.w	r3, #32
   16bd2:	f3ef 8b11 	mrs	fp, BASEPRI
   16bd6:	f383 8812 	msr	BASEPRI_MAX, r3
   16bda:	f3bf 8f6f 	isb	sy
   16bde:	e7d0      	b.n	16b82 <k_heap_aligned_alloc+0x30>

00016be0 <k_heap_alloc>:

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   16be0:	b507      	push	{r0, r1, r2, lr}
	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_heap, alloc, h, timeout);

	void *ret = k_heap_aligned_alloc(h, sizeof(void *), bytes, timeout);
   16be2:	e9cd 2300 	strd	r2, r3, [sp]
   16be6:	460a      	mov	r2, r1
   16be8:	2104      	movs	r1, #4
   16bea:	f7ff ffb2 	bl	16b52 <k_heap_aligned_alloc>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, alloc, h, timeout, ret);

	return ret;
}
   16bee:	b003      	add	sp, #12
   16bf0:	f85d fb04 	ldr.w	pc, [sp], #4

00016bf4 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   16bf4:	b538      	push	{r3, r4, r5, lr}
   16bf6:	4604      	mov	r4, r0
   16bf8:	f04f 0320 	mov.w	r3, #32
   16bfc:	f3ef 8511 	mrs	r5, BASEPRI
   16c00:	f383 8812 	msr	BASEPRI_MAX, r3
   16c04:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   16c08:	f7ff faed 	bl	161e6 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   16c0c:	f104 000c 	add.w	r0, r4, #12
   16c10:	f000 f90f 	bl	16e32 <z_unpend_all>
   16c14:	b130      	cbz	r0, 16c24 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   16c16:	4629      	mov	r1, r5
   16c18:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   16c1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   16c20:	f7fe bb9c 	b.w	1535c <z_reschedule>
	__asm__ volatile(
   16c24:	f385 8811 	msr	BASEPRI, r5
   16c28:	f3bf 8f6f 	isb	sy
}
   16c2c:	bd38      	pop	{r3, r4, r5, pc}

00016c2e <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   16c2e:	f3ef 8005 	mrs	r0, IPSR
}
   16c32:	3800      	subs	r0, #0
   16c34:	bf18      	it	ne
   16c36:	2001      	movne	r0, #1
   16c38:	4770      	bx	lr

00016c3a <z_pm_save_idle_exit>:
{
   16c3a:	b508      	push	{r3, lr}
	pm_system_resume();
   16c3c:	f7fa fb70 	bl	11320 <pm_system_resume>
}
   16c40:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   16c44:	f7ff be24 	b.w	16890 <sys_clock_idle_exit>

00016c48 <z_impl_k_mutex_init>:
{
   16c48:	4603      	mov	r3, r0
	mutex->owner = NULL;
   16c4a:	2000      	movs	r0, #0
   16c4c:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   16c50:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   16c54:	4770      	bx	lr

00016c56 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   16c56:	b13a      	cbz	r2, 16c68 <z_impl_k_sem_init+0x12>
   16c58:	428a      	cmp	r2, r1
   16c5a:	d305      	bcc.n	16c68 <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   16c5c:	e9c0 1202 	strd	r1, r2, [r0, #8]
   16c60:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   16c64:	2000      	movs	r0, #0
   16c66:	4770      	bx	lr
		return -EINVAL;
   16c68:	f06f 0015 	mvn.w	r0, #21
}
   16c6c:	4770      	bx	lr

00016c6e <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   16c6e:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   16c72:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   16c74:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   16c76:	2300      	movs	r3, #0
	node->prev = NULL;
   16c78:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   16c7c:	4770      	bx	lr

00016c7e <unpend_thread_no_timeout>:
{
   16c7e:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   16c80:	f7ff fff5 	bl	16c6e <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   16c84:	7b43      	ldrb	r3, [r0, #13]
   16c86:	f023 0302 	bic.w	r3, r3, #2
   16c8a:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   16c8c:	2300      	movs	r3, #0
   16c8e:	6083      	str	r3, [r0, #8]
}
   16c90:	bd08      	pop	{r3, pc}

00016c92 <z_unpend_thread_no_timeout>:
{
   16c92:	b508      	push	{r3, lr}
	__asm__ volatile(
   16c94:	f04f 0320 	mov.w	r3, #32
   16c98:	f3ef 8111 	mrs	r1, BASEPRI
   16c9c:	f383 8812 	msr	BASEPRI_MAX, r3
   16ca0:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   16ca4:	f7ff ffeb 	bl	16c7e <unpend_thread_no_timeout>
	__asm__ volatile(
   16ca8:	f381 8811 	msr	BASEPRI, r1
   16cac:	f3bf 8f6f 	isb	sy
}
   16cb0:	bd08      	pop	{r3, pc}

00016cb2 <z_unpend_thread>:
{
   16cb2:	b510      	push	{r4, lr}
	__asm__ volatile(
   16cb4:	f04f 0320 	mov.w	r3, #32
   16cb8:	f3ef 8411 	mrs	r4, BASEPRI
   16cbc:	f383 8812 	msr	BASEPRI_MAX, r3
   16cc0:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   16cc4:	f7ff ffdb 	bl	16c7e <unpend_thread_no_timeout>
	__asm__ volatile(
   16cc8:	f384 8811 	msr	BASEPRI, r4
   16ccc:	f3bf 8f6f 	isb	sy
}
   16cd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   16cd4:	3018      	adds	r0, #24
   16cd6:	f000 b8bc 	b.w	16e52 <z_abort_timeout>

00016cda <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   16cda:	4603      	mov	r3, r0
   16cdc:	b920      	cbnz	r0, 16ce8 <z_reschedule_irqlock+0xe>
   16cde:	f3ef 8205 	mrs	r2, IPSR
	if (resched(key)) {
   16ce2:	b90a      	cbnz	r2, 16ce8 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   16ce4:	f7fa bc70 	b.w	115c8 <arch_swap>
   16ce8:	f383 8811 	msr	BASEPRI, r3
   16cec:	f3bf 8f6f 	isb	sy
}
   16cf0:	4770      	bx	lr

00016cf2 <z_reschedule_unlocked>:
	__asm__ volatile(
   16cf2:	f04f 0320 	mov.w	r3, #32
   16cf6:	f3ef 8011 	mrs	r0, BASEPRI
   16cfa:	f383 8812 	msr	BASEPRI_MAX, r3
   16cfe:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   16d02:	f7ff bfea 	b.w	16cda <z_reschedule_irqlock>

00016d06 <z_priq_dumb_best>:
{
   16d06:	4603      	mov	r3, r0
	return list->head == list;
   16d08:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   16d0a:	4283      	cmp	r3, r0
   16d0c:	d003      	beq.n	16d16 <z_priq_dumb_best+0x10>
	if (n != NULL) {
   16d0e:	2800      	cmp	r0, #0
   16d10:	bf38      	it	cc
   16d12:	2000      	movcc	r0, #0
   16d14:	4770      	bx	lr
	struct k_thread *thread = NULL;
   16d16:	2000      	movs	r0, #0
}
   16d18:	4770      	bx	lr

00016d1a <z_ready_thread>:
{
   16d1a:	b510      	push	{r4, lr}
   16d1c:	f04f 0320 	mov.w	r3, #32
   16d20:	f3ef 8411 	mrs	r4, BASEPRI
   16d24:	f383 8812 	msr	BASEPRI_MAX, r3
   16d28:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   16d2c:	f7fe fbdc 	bl	154e8 <ready_thread>
	__asm__ volatile(
   16d30:	f384 8811 	msr	BASEPRI, r4
   16d34:	f3bf 8f6f 	isb	sy
}
   16d38:	bd10      	pop	{r4, pc}

00016d3a <z_thread_timeout>:
{
   16d3a:	4601      	mov	r1, r0
   16d3c:	b510      	push	{r4, lr}
	__asm__ volatile(
   16d3e:	f04f 0320 	mov.w	r3, #32
   16d42:	f3ef 8411 	mrs	r4, BASEPRI
   16d46:	f383 8812 	msr	BASEPRI_MAX, r3
   16d4a:	f3bf 8f6f 	isb	sy
		if (!killed) {
   16d4e:	f810 3c0b 	ldrb.w	r3, [r0, #-11]
   16d52:	f013 0f28 	tst.w	r3, #40	; 0x28
   16d56:	d10d      	bne.n	16d74 <z_thread_timeout+0x3a>
			if (thread->base.pended_on != NULL) {
   16d58:	f851 3c10 	ldr.w	r3, [r1, #-16]
	struct k_thread *thread = CONTAINER_OF(timeout,
   16d5c:	3818      	subs	r0, #24
			if (thread->base.pended_on != NULL) {
   16d5e:	b10b      	cbz	r3, 16d64 <z_thread_timeout+0x2a>
				unpend_thread_no_timeout(thread);
   16d60:	f7ff ff8d 	bl	16c7e <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   16d64:	f811 3c0b 	ldrb.w	r3, [r1, #-11]
   16d68:	f023 0314 	bic.w	r3, r3, #20
   16d6c:	f801 3c0b 	strb.w	r3, [r1, #-11]
			ready_thread(thread);
   16d70:	f7fe fbba 	bl	154e8 <ready_thread>
	__asm__ volatile(
   16d74:	f384 8811 	msr	BASEPRI, r4
   16d78:	f3bf 8f6f 	isb	sy
}
   16d7c:	bd10      	pop	{r4, pc}

00016d7e <add_to_waitq_locked>:
{
   16d7e:	b538      	push	{r3, r4, r5, lr}
   16d80:	4604      	mov	r4, r0
   16d82:	460d      	mov	r5, r1
	unready_thread(thread);
   16d84:	f7fe fc06 	bl	15594 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   16d88:	7b63      	ldrb	r3, [r4, #13]
   16d8a:	f043 0302 	orr.w	r3, r3, #2
   16d8e:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   16d90:	b1b5      	cbz	r5, 16dc0 <add_to_waitq_locked+0x42>
	return list->head == list;
   16d92:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   16d94:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   16d96:	429d      	cmp	r5, r3
   16d98:	bf08      	it	eq
   16d9a:	2300      	moveq	r3, #0
   16d9c:	2b00      	cmp	r3, #0
   16d9e:	bf38      	it	cc
   16da0:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   16da2:	b19b      	cbz	r3, 16dcc <add_to_waitq_locked+0x4e>
	int32_t b1 = thread_1->base.prio;
   16da4:	f994 100e 	ldrsb.w	r1, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   16da8:	f993 200e 	ldrsb.w	r2, [r3, #14]
	if (b1 != b2) {
   16dac:	4291      	cmp	r1, r2
   16dae:	d008      	beq.n	16dc2 <add_to_waitq_locked+0x44>
		return b2 - b1;
   16db0:	1a52      	subs	r2, r2, r1
		if (z_sched_prio_cmp(thread, t) > 0) {
   16db2:	2a00      	cmp	r2, #0
   16db4:	dd05      	ble.n	16dc2 <add_to_waitq_locked+0x44>
	sys_dnode_t *const prev = successor->prev;
   16db6:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   16db8:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   16dbc:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   16dbe:	605c      	str	r4, [r3, #4]
}
   16dc0:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   16dc2:	686a      	ldr	r2, [r5, #4]
   16dc4:	4293      	cmp	r3, r2
   16dc6:	d001      	beq.n	16dcc <add_to_waitq_locked+0x4e>
   16dc8:	681b      	ldr	r3, [r3, #0]
   16dca:	e7ea      	b.n	16da2 <add_to_waitq_locked+0x24>
	sys_dnode_t *const tail = list->tail;
   16dcc:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   16dce:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   16dd2:	601c      	str	r4, [r3, #0]
	list->tail = node;
   16dd4:	606c      	str	r4, [r5, #4]
   16dd6:	e7f3      	b.n	16dc0 <add_to_waitq_locked+0x42>

00016dd8 <z_unpend1_no_timeout>:
{
   16dd8:	b510      	push	{r4, lr}
	__asm__ volatile(
   16dda:	f04f 0320 	mov.w	r3, #32
   16dde:	f3ef 8411 	mrs	r4, BASEPRI
   16de2:	f383 8812 	msr	BASEPRI_MAX, r3
   16de6:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   16dea:	f7ff ff8c 	bl	16d06 <z_priq_dumb_best>
		if (thread != NULL) {
   16dee:	4601      	mov	r1, r0
   16df0:	b108      	cbz	r0, 16df6 <z_unpend1_no_timeout+0x1e>
			unpend_thread_no_timeout(thread);
   16df2:	f7ff ff44 	bl	16c7e <unpend_thread_no_timeout>
	__asm__ volatile(
   16df6:	f384 8811 	msr	BASEPRI, r4
   16dfa:	f3bf 8f6f 	isb	sy
}
   16dfe:	4608      	mov	r0, r1
   16e00:	bd10      	pop	{r4, pc}

00016e02 <z_unpend_first_thread>:
{
   16e02:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   16e04:	f04f 0320 	mov.w	r3, #32
   16e08:	f3ef 8511 	mrs	r5, BASEPRI
   16e0c:	f383 8812 	msr	BASEPRI_MAX, r3
   16e10:	f3bf 8f6f 	isb	sy
		thread = _priq_wait_best(&wait_q->waitq);
   16e14:	f7ff ff77 	bl	16d06 <z_priq_dumb_best>
		if (thread != NULL) {
   16e18:	4604      	mov	r4, r0
   16e1a:	b120      	cbz	r0, 16e26 <z_unpend_first_thread+0x24>
			unpend_thread_no_timeout(thread);
   16e1c:	f7ff ff2f 	bl	16c7e <unpend_thread_no_timeout>
   16e20:	3018      	adds	r0, #24
   16e22:	f000 f816 	bl	16e52 <z_abort_timeout>
	__asm__ volatile(
   16e26:	f385 8811 	msr	BASEPRI, r5
   16e2a:	f3bf 8f6f 	isb	sy
}
   16e2e:	4620      	mov	r0, r4
   16e30:	bd38      	pop	{r3, r4, r5, pc}

00016e32 <z_unpend_all>:
{
   16e32:	b538      	push	{r3, r4, r5, lr}
   16e34:	4605      	mov	r5, r0
	int need_sched = 0;
   16e36:	2000      	movs	r0, #0
	return list->head == list;
   16e38:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   16e3a:	42a5      	cmp	r5, r4
   16e3c:	d000      	beq.n	16e40 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   16e3e:	b904      	cbnz	r4, 16e42 <z_unpend_all+0x10>
}
   16e40:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   16e42:	4620      	mov	r0, r4
   16e44:	f7ff ff35 	bl	16cb2 <z_unpend_thread>
		z_ready_thread(thread);
   16e48:	4620      	mov	r0, r4
   16e4a:	f7ff ff66 	bl	16d1a <z_ready_thread>
		need_sched = 1;
   16e4e:	2001      	movs	r0, #1
   16e50:	e7f2      	b.n	16e38 <z_unpend_all+0x6>

00016e52 <z_abort_timeout>:
{
   16e52:	b510      	push	{r4, lr}
	__asm__ volatile(
   16e54:	f04f 0220 	mov.w	r2, #32
   16e58:	f3ef 8411 	mrs	r4, BASEPRI
   16e5c:	f382 8812 	msr	BASEPRI_MAX, r2
   16e60:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   16e64:	6803      	ldr	r3, [r0, #0]
   16e66:	b13b      	cbz	r3, 16e78 <z_abort_timeout+0x26>
			remove_timeout(to);
   16e68:	f7fe fdb0 	bl	159cc <remove_timeout>
			ret = 0;
   16e6c:	2000      	movs	r0, #0
	__asm__ volatile(
   16e6e:	f384 8811 	msr	BASEPRI, r4
   16e72:	f3bf 8f6f 	isb	sy
}
   16e76:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   16e78:	f06f 0015 	mvn.w	r0, #21
   16e7c:	e7f7      	b.n	16e6e <z_abort_timeout+0x1c>

00016e7e <z_get_next_timeout_expiry>:
{
   16e7e:	b510      	push	{r4, lr}
	__asm__ volatile(
   16e80:	f04f 0320 	mov.w	r3, #32
   16e84:	f3ef 8411 	mrs	r4, BASEPRI
   16e88:	f383 8812 	msr	BASEPRI_MAX, r3
   16e8c:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   16e90:	f7fe fdb6 	bl	15a00 <next_timeout>
	__asm__ volatile(
   16e94:	f384 8811 	msr	BASEPRI, r4
   16e98:	f3bf 8f6f 	isb	sy
}
   16e9c:	bd10      	pop	{r4, pc}

00016e9e <z_set_timeout_expiry>:
{
   16e9e:	b570      	push	{r4, r5, r6, lr}
   16ea0:	4604      	mov	r4, r0
   16ea2:	460d      	mov	r5, r1
	__asm__ volatile(
   16ea4:	f04f 0320 	mov.w	r3, #32
   16ea8:	f3ef 8611 	mrs	r6, BASEPRI
   16eac:	f383 8812 	msr	BASEPRI_MAX, r3
   16eb0:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   16eb4:	f7fe fda4 	bl	15a00 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   16eb8:	2801      	cmp	r0, #1
   16eba:	dd05      	ble.n	16ec8 <z_set_timeout_expiry+0x2a>
   16ebc:	42a0      	cmp	r0, r4
   16ebe:	db03      	blt.n	16ec8 <z_set_timeout_expiry+0x2a>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
   16ec0:	4629      	mov	r1, r5
   16ec2:	4620      	mov	r0, r4
   16ec4:	f7fb fda4 	bl	12a10 <sys_clock_set_timeout>
	__asm__ volatile(
   16ec8:	f386 8811 	msr	BASEPRI, r6
   16ecc:	f3bf 8f6f 	isb	sy
}
   16ed0:	bd70      	pop	{r4, r5, r6, pc}

00016ed2 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   16ed2:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   16ed4:	f7fe feb2 	bl	15c3c <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   16ed8:	bd08      	pop	{r3, pc}

00016eda <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   16eda:	f7fe beaf 	b.w	15c3c <sys_clock_tick_get>

00016ede <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   16ede:	b108      	cbz	r0, 16ee4 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   16ee0:	f7fa b9ca 	b.w	11278 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   16ee4:	4770      	bx	lr

00016ee6 <sys_clock_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
   16ee6:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   16ee8:	1c4b      	adds	r3, r1, #1
   16eea:	bf08      	it	eq
   16eec:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
   16ef0:	4604      	mov	r4, r0
   16ef2:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   16ef4:	d013      	beq.n	16f1e <sys_clock_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   16ef6:	ea54 0105 	orrs.w	r1, r4, r5
   16efa:	d103      	bne.n	16f04 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   16efc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   16f00:	f7fe be9c 	b.w	15c3c <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   16f04:	f06f 0101 	mvn.w	r1, #1
   16f08:	1a0a      	subs	r2, r1, r0
   16f0a:	f04f 31ff 	mov.w	r1, #4294967295
   16f0e:	eb61 0305 	sbc.w	r3, r1, r5
   16f12:	2a00      	cmp	r2, #0
   16f14:	f173 0100 	sbcs.w	r1, r3, #0
   16f18:	db02      	blt.n	16f20 <sys_clock_timeout_end_calc+0x3a>
			return Z_TICK_ABS(dt);
   16f1a:	4610      	mov	r0, r2
   16f1c:	4619      	mov	r1, r3
}
   16f1e:	bd38      	pop	{r3, r4, r5, pc}
		return sys_clock_tick_get() + MAX(1, dt);
   16f20:	f7fe fe8c 	bl	15c3c <sys_clock_tick_get>
   16f24:	2c01      	cmp	r4, #1
   16f26:	f175 0300 	sbcs.w	r3, r5, #0
   16f2a:	bfbc      	itt	lt
   16f2c:	2401      	movlt	r4, #1
   16f2e:	2500      	movlt	r5, #0
   16f30:	1820      	adds	r0, r4, r0
   16f32:	eb45 0101 	adc.w	r1, r5, r1
   16f36:	e7f2      	b.n	16f1e <sys_clock_timeout_end_calc+0x38>

00016f38 <k_timer_init>:
	timer->status = 0U;
   16f38:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   16f3a:	e9c0 1208 	strd	r1, r2, [r0, #32]
   16f3e:	f100 0218 	add.w	r2, r0, #24
	list->tail = (sys_dnode_t *)list;
   16f42:	e9c0 2206 	strd	r2, r2, [r0, #24]
	node->prev = NULL;
   16f46:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
   16f4a:	6303      	str	r3, [r0, #48]	; 0x30
	timer->user_data = NULL;
   16f4c:	6343      	str	r3, [r0, #52]	; 0x34
}
   16f4e:	4770      	bx	lr

00016f50 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   16f50:	b510      	push	{r4, lr}
   16f52:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
   16f54:	f7ff ff7d 	bl	16e52 <z_abort_timeout>

	if (inactive) {
   16f58:	b9b0      	cbnz	r0, 16f88 <z_impl_k_timer_stop+0x38>
		return;
	}

	if (timer->stop_fn != NULL) {
   16f5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16f5c:	b10b      	cbz	r3, 16f62 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   16f5e:	4620      	mov	r0, r4
   16f60:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
   16f62:	f104 0018 	add.w	r0, r4, #24
   16f66:	f7ff ff37 	bl	16dd8 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
   16f6a:	b168      	cbz	r0, 16f88 <z_impl_k_timer_stop+0x38>
			z_ready_thread(pending_thread);
   16f6c:	f7ff fed5 	bl	16d1a <z_ready_thread>
	__asm__ volatile(
   16f70:	f04f 0320 	mov.w	r3, #32
   16f74:	f3ef 8011 	mrs	r0, BASEPRI
   16f78:	f383 8812 	msr	BASEPRI_MAX, r3
   16f7c:	f3bf 8f6f 	isb	sy
			z_reschedule_unlocked();
		}
	}
}
   16f80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   16f84:	f7ff bea9 	b.w	16cda <z_reschedule_irqlock>
   16f88:	bd10      	pop	{r4, pc}

00016f8a <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   16f8a:	4770      	bx	lr

00016f8c <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   16f8c:	f7fb bf88 	b.w	12ea0 <SystemInit>
